{"version":3,"file":"js/../js/test.js","mappings":"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","sources":["webpack://astry/./js/css-grammar.ts","webpack://astry/./js/html-grammar.ts","webpack://astry/./js/json-grammar.ts","webpack://astry/./js/scanner.ts","webpack://astry/webpack/bootstrap","webpack://astry/webpack/runtime/global","webpack://astry/./js/test.ts"],"sourcesContent":["import {\r\n    Scanner, OPERATIONS, HOOK_MODE, IScanEnv,\r\n    IPattern, Token,\r\n    IPosition, ISourceLocation,\r\n} from \"./scanner\"\r\n\r\n\r\nconst {\r\n    FINISH,\r\n    WRAP, UNWRAP, UNWRAP_ALL,\r\n    OPTION,\r\n    SPLIT,\r\n    NO_COLLECT, NO_CAPTURE,\r\n    MARK_AS_ROOT, FORK_IN_PARENT, FORK_IN_ROOT,\r\n    END, END_ON_LEFT,\r\n    useKey,\r\n    node, key, pick, hook, pipe, prev, merge,\r\n\r\n    MATCH_BEGIN,\r\n    MATCH_END,\r\n    MATCH_EOF,\r\n    MERGE_ALL_TOKENS,\r\n    UNFOLD\r\n} = OPERATIONS;\r\n\r\n\r\n\r\nconst MATCH_WHITE_SPACE_CHARACHER: IPattern = [` `, `\\n`, `\\t`];\r\nconst CLEAR_COMMENT: IPattern = [\r\n    [\r\n        NO_COLLECT,\r\n        [\r\n            [\"//\", WRAP, [\"\\n\", [MATCH_EOF]], UNWRAP],\r\n            [\"/*\", WRAP, [\"*/\", [MATCH_EOF]], UNWRAP],\r\n        ],\r\n    ]\r\n]\r\n\r\nconst CLEAR_WHITE_SPACE_CHARACHER: IPattern = [\r\n    [NO_COLLECT, MATCH_WHITE_SPACE_CHARACHER]\r\n];\r\n\r\n\r\nconst TEST_KEYWORD_BOUNDARY: IPattern = [\r\n    [NO_CAPTURE, [\" \", \"\\n\", `\\t`, \"(\", \")\", \"{\", \"}\", \":\"]]\r\n];\r\n\r\nconst NODE_LIST = function (tokens: Array<any>) {\r\n    return tokens.filter(token => !(token instanceof Token));\r\n}\r\nconst Declaration = node(\"Declaration\").Wrapper;\r\n\r\nconst THROW_TOKEN_ERROR = hook(function (env, start, end) {\r\n    console.log(\"Invalid or unexpected token\", start, end);\r\n}, HOOK_MODE.RESOLVE);\r\n\r\nconst MATCH_STRING: IPattern = [\r\n    [\r\n        `\"`, WRAP,\r\n        [\r\n            [THROW_TOKEN_ERROR, `\\n`],\r\n            [`\\\\`, [`\\\\`, `\\n`, `\"`]],\r\n            [`\"`, UNWRAP]\r\n        ]\r\n\r\n    ],\r\n    [\r\n        `'`, WRAP,\r\n        [\r\n            [THROW_TOKEN_ERROR, `\\n`],\r\n            [`\\\\`, [`\\\\`, `\\n`, `'`]],\r\n            [`'`, UNWRAP]\r\n        ]\r\n    ],\r\n]\r\n\r\n// 不包含 '' \"\" 的 url 地址可能会包含断义字符 / 影响判别，这里通过单独匹配给出结果\r\nconst MATCH_URL: IPattern = [\r\n    [\r\n        MATCH_BEGIN, \"url(\", WRAP,\r\n        [\r\n            [MATCH_STRING],\r\n            [CLEAR_WHITE_SPACE_CHARACHER],\r\n            [\")\", UNWRAP]\r\n        ],\r\n    ]\r\n];\r\n\r\nconst MATCH_CSS_ATTRIBUTE_VALUE: IPattern = [\r\n    [\r\n        MARK_AS_ROOT,\r\n        [\r\n            [MATCH_STRING],\r\n            [MATCH_URL],\r\n            [\r\n                // 使能在 ( 后被断句\r\n                // 这里没做额外检验允许括号前的空格\r\n                MERGE_ALL_TOKENS,\r\n                prev(null, true), \"(\"\r\n            ],\r\n            \")\",\r\n            [CLEAR_WHITE_SPACE_CHARACHER],\r\n            [CLEAR_COMMENT],\r\n            [\r\n                MERGE_ALL_TOKENS,\r\n                prev(null, true),\r\n                \"%\"\r\n            ],\r\n            \"/\",\r\n            \",\"\r\n        ]\r\n    ]\r\n]\r\nconst MATCH_CSS_ATTRIBUTE: IPattern = [\r\n    [CLEAR_COMMENT],\r\n    [CLEAR_WHITE_SPACE_CHARACHER],\r\n    [   //通用样式匹配\r\n        merge(function ([key, value]) {\r\n            return useKey(key, value);\r\n        }),\r\n        prev(function (token: any) {\r\n            if (token instanceof Token) {\r\n                return true;\r\n            }\r\n            debugger;\r\n        }),\r\n        NO_COLLECT, \":\", WRAP,\r\n        [\r\n            [MATCH_CSS_ATTRIBUTE_VALUE],\r\n            [\"!important\", NO_CAPTURE, [MATCH_END, \" \", \"\\n\", \"}\", \";\"]],\r\n            [NO_CAPTURE, \"}\", UNWRAP],\r\n            [NO_COLLECT, \";\", UNWRAP],\r\n            [MATCH_EOF, UNWRAP]\r\n        ]\r\n    ]\r\n]\r\n\r\nconst CSSStyleRule = [\r\n    node(\"CSSStyleRule\"),\r\n    key(\"selectorText\", function (token: Token) { return token.trim() }),\r\n    prev(function (token: any) {\r\n        if (token instanceof Token) {\r\n            return true;\r\n        }\r\n        debugger;\r\n        // error\r\n    }),\r\n    key(\"style\"),\r\n    node(\r\n        \"CSSStyleDeclaration\",\r\n        /*function ([token]: [Array<any>], env: ScanEnv, start: Position, end: Position) {\r\n            token.push(\r\n                useKey(\"cssText\", env.input.slice(start.offset + 1, end.offset - 1))\r\n            )\r\n        }*/\r\n        undefined, true\r\n    ),\r\n    \"{\", WRAP,\r\n    [\r\n        [\"}\", UNWRAP],\r\n        [MATCH_CSS_ATTRIBUTE]\r\n    ],\r\n];\r\nconst CSSMediaRule = [\r\n    MARK_AS_ROOT,\r\n    node(\"CSSMediaRule\"),\r\n    \"@media\", TEST_KEYWORD_BOUNDARY, WRAP,\r\n    key(\"media\"),\r\n    prev(function (token: Token) {\r\n        const value = token.value;\r\n        return value.length - value.match(/\\S|$/).index;\r\n    }, true),\r\n    key(\"cssRules\", NODE_LIST),\r\n    \"{\", WRAP,\r\n    FORK_IN_ROOT,\r\n    \"}\", UNWRAP_ALL\r\n];\r\nconst CSSKeyframesRule = [\r\n    node(\"CSSKeyframesRule\"),\r\n    \"@keyframes\", TEST_KEYWORD_BOUNDARY, WRAP,\r\n    key(\"name\"),\r\n    prev(function (token: any) {\r\n        if (token instanceof Token) {\r\n            return true;\r\n        }\r\n        debugger;\r\n    }),\r\n    key(\"cssRules\", NODE_LIST),\r\n    \"{\", WRAP,\r\n    [\r\n        [\"}\", UNWRAP_ALL],\r\n        [\r\n            node(\"CSSKeyframeRule\"),\r\n            \"{\", WRAP,\r\n            [\r\n                [\"}\", UNWRAP],\r\n                [MATCH_CSS_ATTRIBUTE]\r\n            ]\r\n        ]\r\n    ]\r\n];\r\nconst CSSFontFaceRule = [\r\n    node(\"CSSFontFaceRule\"),\r\n    \"@font-face\", TEST_KEYWORD_BOUNDARY, WRAP,\r\n    \"{\", WRAP,\r\n    [\r\n        [\"}\", UNWRAP_ALL],\r\n        [MATCH_CSS_ATTRIBUTE]\r\n    ]\r\n];\r\nconst CSSSupportsRule = [\r\n    MARK_AS_ROOT,\r\n    node(\"CSSSupportsRule\"),\r\n    pick(function (tokens: Array<any>) {\r\n        return [\r\n            useKey(\"conditionText\", tokens[1].value.trim()),\r\n            useKey(\"cssRules\", NODE_LIST(tokens[2]))\r\n        ];\r\n    }),\r\n    \"@supports\", TEST_KEYWORD_BOUNDARY, WRAP,\r\n    \"{\", WRAP,\r\n    FORK_IN_ROOT,\r\n    \"}\", UNWRAP_ALL\r\n];\r\n\r\nexport {\r\n    MATCH_CSS_ATTRIBUTE_VALUE,\r\n    MATCH_CSS_ATTRIBUTE\r\n}\r\nexport default <IPattern>[\r\n    [CLEAR_COMMENT],\r\n    [NO_COLLECT, [[\"\", MATCH_WHITE_SPACE_CHARACHER]]],\r\n    CSSSupportsRule,\r\n    CSSStyleRule,\r\n    CSSMediaRule,\r\n    CSSKeyframesRule,\r\n    CSSFontFaceRule\r\n];\r\n","import {\r\n    Scanner, OPERATIONS, HOOK_MODE, IScanEnv,\r\n    IPattern, Token,\r\n    IPosition, ISourceLocation,\r\n} from \"./scanner\"\r\n\r\n\r\nconst {\r\n    FINISH,\r\n    WRAP, UNWRAP, UNWRAP_ALL,\r\n    OPTION,\r\n    SPLIT,\r\n    NO_COLLECT, NO_CAPTURE,\r\n    MARK_AS_ROOT, FORK_IN_PARENT, FORK_IN_ROOT,\r\n    END, END_ON_LEFT,\r\n    useKey,\r\n    node, key, pick, hook, pipe, prev, merge,\r\n\r\n    MATCH_BEGIN,\r\n    MATCH_END,\r\n    MATCH_EOF,\r\n    MERGE_ALL_TOKENS\r\n} = OPERATIONS;\r\n\r\nimport CSSGrammar from \"./css-grammar\";\r\n\r\n\r\nconst SELF_CLOSING_TAGS = [\r\n    \"area\",\r\n    \"base\",\r\n    \"br\",\r\n    \"col\",\r\n    \"embed\",\r\n    \"hr\",\r\n    \"img\",\r\n    \"input\",\r\n    \"link\",\r\n    \"meta\",\r\n    \"param\",\r\n    \"source\",\r\n    \"track\",\r\n    \"wbr\",\r\n    \"command\",\r\n    \"keygen\",\r\n    \"menuitem\"\r\n];\r\n\r\nconst MATCH_WHITE_SPACE_CHARACHER: IPattern = [` `, `\\n`, `\\t`];\r\nconst CLEAR_WHITE_SPACE_CHARACHER: IPattern = [\r\n    [NO_COLLECT, MATCH_WHITE_SPACE_CHARACHER]\r\n];\r\n\r\nconst MATCH_ATTRIBUTES: IPattern = [\r\n    [CLEAR_WHITE_SPACE_CHARACHER],\r\n    [\"=\"],\r\n    [`\"`, WRAP, `\"`, UNWRAP],\r\n    [`'`, WRAP, `'`, UNWRAP],\r\n];\r\n\r\n\r\n\r\n\r\nconst MATCH_TAG_END: IPattern = [\r\n    [\r\n        hook(function ({ tokens }) {\r\n            if (tokens[0][2].value !== tokens[tokens.length - 1][1].value) {\r\n                return -2;\r\n            }\r\n        }, HOOK_MODE.RESOLVE),\r\n        \"</\", WRAP,\r\n        [\r\n            [MATCH_WHITE_SPACE_CHARACHER],\r\n            [\">\", UNWRAP_ALL]\r\n        ]\r\n\r\n    ]\r\n];\r\n\r\n\r\nconst THROW_TOKEN_ERROR = hook(function (env, start, end) {\r\n    console.log(\"Invalid or unexpected token\", start, end);\r\n}, HOOK_MODE.RESOLVE);\r\n\r\nconst MATCH_SCRIPT_TEXT: IPattern = [\r\n    [\r\n        `\"`, WRAP,\r\n        [\r\n            [THROW_TOKEN_ERROR, `\\n`],\r\n            [`\"`, UNWRAP]\r\n        ]\r\n\r\n    ],\r\n    [\r\n        `'`, WRAP,\r\n        [\r\n            [THROW_TOKEN_ERROR, `\\n`],\r\n            [`'`, UNWRAP]\r\n        ]\r\n\r\n    ],\r\n    [\"//\", WRAP, [\"\\n\", [OPERATIONS.MATCH_EOF]], UNWRAP],\r\n    [\"/*\", WRAP, [\"*/\", [OPERATIONS.MATCH_EOF]], UNWRAP],\r\n    [\r\n        MARK_AS_ROOT,\r\n        `\\``, WRAP,\r\n        [\r\n            [\r\n                `$`,\r\n                `{`, WRAP,\r\n                FORK_IN_ROOT,\r\n                `}`, UNWRAP\r\n            ],\r\n            [`\\``, UNWRAP]\r\n        ]\r\n    ],\r\n];\r\n\r\nconst MATCH_SCRIPT_END: IPattern = [\r\n    [\r\n        hook(function (env) {\r\n            env.useEscape = true;\r\n            env.ignoreCase = false;\r\n        }, HOOK_MODE.CAPTURE/*HOOK_MODE.LEFT_ASSOCIATIVE*/),\r\n        MATCH_SCRIPT_TEXT\r\n    ],\r\n    [\r\n        hook(function (env) {\r\n            env.useEscape = false;\r\n            env.ignoreCase = true;\r\n        }, HOOK_MODE.RESOLVE),\r\n        MATCH_TAG_END,\r\n    ]\r\n];\r\n\r\nconst CSSScanner = new Scanner(\r\n    [\r\n        [CSSGrammar],\r\n        [\r\n            hook(function (env) {\r\n                env.end = env.offset;\r\n            }, HOOK_MODE.RESOLVE),\r\n            MATCH_TAG_END\r\n        ]\r\n    ],\r\n    { useEscape: true }\r\n);\r\n\r\nconst MATCH_STYLE_END: IPattern = [\r\n\r\n    [// 使用内联 JS 编译\r\n        hook(function (env) {\r\n            const end = env.end;\r\n            env.useEscape = true;\r\n            env.ignoreCase = false;\r\n\r\n            CSSScanner.scan(env);\r\n\r\n            env.end = end;\r\n        }, HOOK_MODE.CAPTURE),\r\n\r\n        hook(function (env) {\r\n            env.useEscape = false;\r\n            env.ignoreCase = true;\r\n        }, HOOK_MODE.RESOLVE),\r\n        \"\", UNWRAP_ALL,\r\n    ]\r\n\r\n    /*\r\n    // 内联整个 CSS Pattern 编译消耗很大\r\n    [MARK_AS_ROOT, CSSGrammar],\r\n    [\r\n        hook(function (env) {\r\n            env.useEscape = true;\r\n            env.ignoreCase = false;\r\n        }, HOOK_MODE.CAPTURE),\r\n        hook(function (env) {\r\n            env.useEscape = false;\r\n            env.ignoreCase = true;\r\n        }, HOOK_MODE.RESOLVE),\r\n        MATCH_TAG_END,\r\n    ]\r\n    */\r\n];\r\n\r\nconst TextNode = node(\"Text\").Wrapper;\r\n\r\n\r\nexport {\r\n    formatTokens,\r\n    SELF_CLOSING_TAGS\r\n};\r\nexport default <IPattern>[\r\n    [\r\n        node(\"DocumentType\"),\r\n        pick(function (tokens: Array<any>) {\r\n            tokens[1] = useKey(\"name\", tokens[1].value);\r\n            return tokens;\r\n        }),\r\n        \"<!doctype\", WRAP,\r\n        [\r\n            [CLEAR_WHITE_SPACE_CHARACHER],\r\n            [\">\", UNWRAP]\r\n        ],\r\n    ],\r\n    [\r\n        node(\"Comment\"),\r\n        key(\"data\", function (tokens) {\r\n            return tokens[1].value;\r\n        }),\r\n        \"<!--\", WRAP, \"-->\", UNWRAP\r\n    ],\r\n    [\r\n        MARK_AS_ROOT,\r\n        node(\"HTMLElement\"),\r\n        pick(collectChildNodes),\r\n        pick(collectAttrs),\r\n        pick(collectTagName),\r\n        \"<\", WRAP,\r\n        [\r\n            [MATCH_ATTRIBUTES],\r\n            [\"/>\", UNWRAP],\r\n            [\r\n                \">\", WRAP,\r\n                [\r\n                    [FORK_IN_ROOT],\r\n                    [MATCH_TAG_END]\r\n                ]\r\n            ]\r\n        ],\r\n    ],\r\n    matchCustomTag(\"script\", MATCH_SCRIPT_END),\r\n    matchCustomTag(\"style\", MATCH_STYLE_END),\r\n    matchCustomTag(\"textarea\", MATCH_TAG_END),\r\n    matchSelfClosingTag(SELF_CLOSING_TAGS),\r\n]\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction matchSelfClosingTag(tagName: IPattern) {\r\n    return [\r\n        node(\"HTMLElement\"),\r\n        pick(collectChildNodes),\r\n        pick(collectAttrs),\r\n        pick(collectTagName),\r\n        \"<\", SPLIT,\r\n        tagName,\r\n        SPLIT,\r\n        [\r\n            [\r\n                [\"/>\", \">\"],\r\n                hook(function (env) {//使折叠次数一致\r\n                    const { tokens, hookPoint } = env;\r\n                    tokens.push(tokens.splice(hookPoint));\r\n                }, HOOK_MODE.RESOLVE),\r\n                FINISH,\r\n            ],\r\n            [\r\n                NO_COLLECT, [\" \", \"\\n\"],\r\n                WRAP,\r\n                [\r\n                    [MATCH_ATTRIBUTES],\r\n                    [\r\n                        [\"/>\", \">\"],\r\n                        UNWRAP\r\n                    ]\r\n                ]\r\n            ]\r\n        ]\r\n    ];\r\n\r\n}\r\nfunction matchCustomTag(tagName: IPattern, tagEnd: IPattern) {\r\n    return [\r\n        node(\"HTMLElement\"),\r\n        pick(collectChildNodes),\r\n        pick(collectAttrs),\r\n        pick(collectTagName),\r\n        \"<\", SPLIT,\r\n        tagName,\r\n        SPLIT,\r\n        [\r\n            [\r\n                \"/>\",\r\n                hook(function (env) {//使折叠次数一致\r\n                    const { tokens, hookPoint } = env;\r\n                    tokens.push(tokens.splice(hookPoint));\r\n                }, HOOK_MODE.RESOLVE),\r\n                FINISH\r\n            ],\r\n            [\r\n                WRAP, \">\",\r\n                WRAP, //保持折叠次数，统一使用同一个 hook 逻辑处理\r\n                tagEnd\r\n            ],\r\n            [\r\n                NO_COLLECT, [\" \", \"\\n\"],\r\n                WRAP,\r\n                [\r\n                    [\"/>\", UNWRAP_ALL],\r\n                    [MATCH_ATTRIBUTES],\r\n                    [\">\", WRAP, tagEnd]\r\n                ]\r\n            ]\r\n        ],\r\n    ]\r\n}\r\n\r\n\r\nfunction collectAttrs(tokens: Array<any>) {\r\n    const attrs = [];\r\n\r\n    for (let i = 1; i < tokens.length - 1; i += 1) {\r\n        let key = getValue(tokens[i]);\r\n        let value = \"\";\r\n        if (getValue(tokens[i + 1]) === \"=\") {\r\n            value = getValue(tokens[i += 2]);\r\n        }\r\n        attrs.push({ key, value });\r\n    }\r\n    tokens.splice(1, tokens.length - 2, useKey(\"attrs\", attrs));\r\n    return tokens;\r\n\r\n    function getValue(token: any) {\r\n        if (token instanceof Token) {\r\n            return token.value;\r\n        } else if (token instanceof Array) {\r\n            return token.map(getValue);\r\n        }\r\n        return token;\r\n    }\r\n}\r\n\r\nfunction formatTokens(tokens: Array<any>) {\r\n    const result = [];\r\n\r\n    let textNode: any, textToken: Token;\r\n    walk(tokens);\r\n\r\n    return result;\r\n\r\n    function walk(token: any) {\r\n        if (token instanceof Array) {\r\n            token.forEach(walk);\r\n        } else {\r\n            if (token instanceof Token) {\r\n                if (textToken) {\r\n                    textToken = textToken.concat(token);\r\n                } else {\r\n                    textToken = token;\r\n                    textNode = new TextNode();\r\n                    result.push(textNode);\r\n                }\r\n                textNode.data = textToken.value;\r\n                textNode.loc = textToken.loc;\r\n                return;\r\n            }\r\n            textNode = textToken = null;\r\n            result.push(token);\r\n        }\r\n    }\r\n}\r\n\r\nfunction collectChildNodes(tokens: Array<any>) {\r\n    const nodes = tokens.pop();\r\n    tokens.push(\r\n        useKey(\r\n            \"childNodes\",\r\n            nodes instanceof Array\r\n                ? formatTokens(nodes.slice(1, -1))\r\n                : []\r\n        )\r\n    );\r\n    return tokens;\r\n}\r\n\r\nfunction collectTagName(tokens: Array<any>) {\r\n    tokens.splice(0, 2, useKey(\"tagName\", tokens[1].value.toUpperCase()))\r\n    return tokens;\r\n}\r\n","\r\nimport {\r\n    Scanner, OPERATIONS, HOOK_MODE, IScanEnv,\r\n    IPattern, Token,\r\n    IPosition, ISourceLocation,\r\n} from \"./scanner\"\r\n\r\n\r\nconst {\r\n    FINISH,\r\n    WRAP, UNWRAP, UNWRAP_ALL,\r\n    OPTION,\r\n    SPLIT,\r\n    NO_COLLECT, NO_CAPTURE,\r\n    MARK_AS_ROOT, FORK_IN_PARENT, FORK_IN_ROOT,\r\n    END, END_ON_LEFT,\r\n    useKey,\r\n    node, key, pick, hook, pipe, prev, merge,\r\n\r\n    MATCH_BEGIN,\r\n    MATCH_END,\r\n    MATCH_EOF,\r\n    MERGE_ALL_TOKENS\r\n} = OPERATIONS;\r\n\r\nconst TEST_KEYWORD_BOUNDARY = [\r\n    [NO_CAPTURE, [\"\", \" \", \"\\n\", `\\t`, \",\", \"(\", \")\", \"{\", \"}\", \":\", \"[\", \"]\"]]\r\n];\r\nconst THROW_TOKEN_ERROR = hook(function (env, start, end) {\r\n    console.log(\"Invalid or unexpected token\", start, end);\r\n}, HOOK_MODE.RESOLVE);\r\n\r\nconst LITERAL_VALUE_MAP = { true: true, false: false, null: null };\r\nconst COLLECT_STRING = [\r\n    [\r\n        pick(function (tokens, env, start, end) {\r\n            return [env.input.slice(start.offset, end.offset), tokens[1].value];\r\n        }),\r\n        `\"`,\r\n        hook(function (env) {\r\n            env.useEscape = true;\r\n        }, HOOK_MODE.CAPTURE),\r\n        WRAP,\r\n        [\r\n            [THROW_TOKEN_ERROR, \"\\n\"],\r\n            [\r\n                `\"`,\r\n                hook(function (env) {\r\n                    env.useEscape = false;\r\n                }, HOOK_MODE.CAPTURE),\r\n                UNWRAP,\r\n            ]\r\n        ]\r\n    ]\r\n];\r\n\r\n\r\nconst MATCH_WHITE_SPACE_CHARACHER = [` `, `\\n`, `\\t`];\r\n\r\nconst CLEAR_WHITE_SPACE_CHARACHER = [\r\n    [NO_COLLECT, MATCH_WHITE_SPACE_CHARACHER]\r\n];\r\n\r\nconst Literal = node(\"Literal\").Wrapper;\r\n\r\nconst PARSE_NUMBER_LITERAL = pipe(\r\n    function (token: Token, env, start, end) {\r\n        let value: any = token.value;\r\n        const result: any = /^(-?[1-9][0-9]*|0)(.[0-9]+)?([eE][-+]?[0-9]+)?$/g.exec(value);\r\n        if (result) {\r\n            const [, int, frac, exp] = result;\r\n            value = int | 0;\r\n            frac && (value += frac % 1);\r\n            exp && (value *= Math.pow(10, exp.slice(1) | 0));\r\n        } else {\r\n            debugger;\r\n        }\r\n        return Object.assign(   //  Number(value)\r\n            new Literal(),\r\n            { raw: token.value, value: value, loc: { start, end } }\r\n        );\r\n    } ,\r\n);\r\n\r\n\r\nexport default <IPattern>[\r\n    [PARSE_NUMBER_LITERAL, CLEAR_WHITE_SPACE_CHARACHER],\r\n    [\r\n        node(\"Literal\", function ([[raw, value]]: any) {\r\n            return [\r\n                useKey(\"raw\", raw),\r\n                useKey(\"value\", value)\r\n            ];\r\n        }),\r\n        [\r\n            [COLLECT_STRING],\r\n            [\r\n                pick(function ({ value }: Token) {\r\n                    return [value, LITERAL_VALUE_MAP[value]]\r\n                }),\r\n                \"\",\r\n                [\"true\", \"false\", \"null\"]\r\n                , TEST_KEYWORD_BOUNDARY\r\n            ]\r\n        ]\r\n    ],\r\n    [\r\n        node(\"Object\", function ([tokens]: [Array<any>]) {\r\n            return useKey(\"children\", tokens.filter(\r\n                function (token) {\r\n                    if (token instanceof Token) {\r\n                        debugger;\r\n                        return false;\r\n                    }\r\n                    return true;\r\n                }\r\n            ));\r\n        }),\r\n        NO_COLLECT, \"{\", WRAP,\r\n        [\r\n            [NO_COLLECT, \"}\", UNWRAP],\r\n            [CLEAR_WHITE_SPACE_CHARACHER],\r\n            [\r\n                node(\"Identifier\", function ([[raw, value]]: any) {\r\n                    return [\r\n                        useKey(\"value\", value),\r\n                        useKey(\"raw\", raw)\r\n                    ]\r\n                }),\r\n                COLLECT_STRING,\r\n                node(\"Property\", function ([key, [value]]) {\r\n                    const props = [useKey(\"key\", key)];\r\n                    if (value.length === 1 && !(value[0] instanceof Token)) {\r\n                        props.push(useKey(\"value\", value[0]));\r\n                    } else {\r\n                        debugger;\r\n                    }\r\n                    return props;\r\n                }),\r\n                prev(),\r\n                WRAP,\r\n                [\r\n                    [CLEAR_WHITE_SPACE_CHARACHER],\r\n                    [\r\n                        NO_COLLECT, \":\", WRAP,\r\n                        FORK_IN_ROOT,\r\n                        PARSE_NUMBER_LITERAL,\r\n                        [\r\n                            [NO_CAPTURE, \"}\", UNWRAP, UNWRAP],\r\n                            [NO_COLLECT, \",\", UNWRAP, UNWRAP],\r\n                        ]\r\n                    ]\r\n                ]\r\n            ]\r\n        ]\r\n    ],\r\n    [\r\n        node(\"Array\", function ([tokens]: [Array<any>]) {\r\n            const children = [];\r\n            for (let i = 0, len = tokens.length; i < len; i += 2) {\r\n                let value = tokens[i];\r\n                let spearator = tokens[i + 1];\r\n                if (!spearator || (spearator.value === \",\" && i < len - 2)) {\r\n                    if (!(value instanceof Token)) {\r\n                        children.push(value);\r\n                        continue;\r\n                    }\r\n                }\r\n                debugger;\r\n                break;\r\n            }\r\n            return useKey(\"children\", children);\r\n        }),\r\n        NO_COLLECT, \"[\", WRAP,\r\n        FORK_IN_ROOT,\r\n        PARSE_NUMBER_LITERAL,\r\n        [\r\n            [NO_COLLECT, \"]\", UNWRAP],\r\n            [\",\"]\r\n        ]\r\n    ]\r\n];\r\n\r\n\r\n","\r\n\r\n\r\nexport {\r\n    Scanner, OPERATIONS, HOOK_MODE, IScanEnv,\r\n    IPattern, Token,\r\n    IPosition, ISourceLocation,\r\n    UseKey, unwrapTokens\r\n}\r\n\r\ntype IScanEnv = {\r\n    tokens: Array<any>,\r\n    input: string,\r\n    begin: number,\r\n    offset: number,\r\n    end: number,\r\n    line: number,\r\n    column: number,\r\n    useFold: boolean,\r\n    useEscape: boolean,\r\n    ignoreCase: boolean,\r\n    hookPoint: number, // 用于指定当前钩子方法目标 token 位置\r\n}\r\n\r\n\r\nconst enum HOOK_MODE {\r\n    RESOLVE = 0b1,\r\n    CAPTURE = 0b10,\r\n    PIPE = 0b100\r\n    //LEFT_ASSOCIATIVE = 0b101\r\n}\r\n\r\ninterface IPosition {\r\n    offset: number,\r\n    line: number,\r\n    column: number\r\n}\r\ninterface ISourceLocation {\r\n    start: IPosition,\r\n    end: IPosition\r\n}\r\n\r\n\r\ntype IPattern = Hook\r\n    | string\r\n    | String    // 用于在不占用 string 描述空间的基础上，清晰的定义一些操作指令\r\n    | Array<\r\n        string  //  单段字符串不需要在数组内也能简化的声明为一个分支\r\n        | Array<IPattern>    //  其他内容需要被数组包裹\r\n    > // Array 代表 Pattern 内的分支 Pattern\r\n\r\n\r\nenum SCOPE {\r\n    NODE, START, BEGIN, CURSOR, BACK_POINT, USE_FOLD\r\n}\r\n\r\n\r\ninterface IScope {\r\n    [SCOPE.NODE]: any,\r\n    [SCOPE.START]: IPosition,\r\n    [SCOPE.BEGIN]: IPosition,\r\n    [SCOPE.CURSOR]: IPosition,\r\n    [SCOPE.BACK_POINT]: number,\r\n    [SCOPE.USE_FOLD]: boolean\r\n}\r\n\r\ntype ISlices = Array<[IPosition, Hook[]]>;\r\n\r\ntype IResolveState = [any, IPosition, ISlices, number];\r\n\r\n\r\n\r\nabstract class Hook {\r\n    mode: HOOK_MODE = HOOK_MODE.RESOLVE;\r\n    abstract use(env: IScanEnv, start: IPosition, end: IPosition, begin: IPosition): any\r\n}\r\n\r\n\r\n\r\n\r\nclass Node extends Hook {\r\n    static NODE_MAP = {};\r\n    public Wrapper: any;\r\n    constructor(\r\n        public type: string,\r\n        public map?: (tokens: Array<any>, env: IScanEnv, start: IPosition, end: IPosition) => any,\r\n        private useContent?: boolean\r\n    ) {\r\n        super();\r\n        this.Wrapper = Node.NODE_MAP[type] || (\r\n            Node.NODE_MAP[type] = eval(\r\n                `(function ${type}(){this.type=\"${type}\";})`\r\n            )\r\n        );\r\n    }\r\n    use(env: IScanEnv, start: IPosition, end: IPosition) {\r\n\r\n        let { tokens, hookPoint } = env;\r\n\r\n        const node = new this.Wrapper();\r\n        node.loc = { start, end };\r\n        let addItem = function (item: UseKey) {\r\n            node[item.key] = item.value;\r\n        }\r\n        if (this.useContent) {\r\n            const content = node.content = [];\r\n            addItem = function (item: UseKey) {\r\n                content.push(item);\r\n            }\r\n        }\r\n        tokens = tokens.splice(hookPoint);\r\n        if (this.map) {\r\n            tokens = this.map(tokens, env, start, end) || tokens;\r\n        }\r\n        walk(tokens);\r\n        env.tokens.push(node);\r\n\r\n        function walk(token: any) {\r\n            if (token instanceof Array) {\r\n                token.forEach(walk);\r\n            } else if (token instanceof UseKey) {\r\n                addItem(token);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nclass UseKey {\r\n    constructor(public key: string, public value: any) { }\r\n}\r\n\r\nclass Key extends Hook {\r\n    static Wrapper = UseKey;\r\n    constructor(public key: string, public map?: (token: any, env: IScanEnv, start: IPosition, end: IPosition) => any) {\r\n        super();\r\n    }\r\n    use(env: IScanEnv, start: IPosition, end: IPosition) {\r\n        let { tokens, hookPoint } = env;\r\n        let token = tokens[hookPoint];\r\n        this.map && (token = this.map(token, env, start, end) || token);\r\n        tokens.splice(hookPoint, 1, new UseKey(this.key, token));\r\n    }\r\n}\r\n\r\nclass Merge extends Hook {\r\n    constructor(public map: (tokens: Array<any>, env: IScanEnv, start: IPosition, end: IPosition) => any) {\r\n        super();\r\n    }\r\n    use(env: IScanEnv, start: IPosition, end: IPosition) {\r\n        let { tokens, hookPoint } = env;\r\n\r\n        tokens.push(this.map(tokens.splice(hookPoint), env, start, end));\r\n    }\r\n}\r\n\r\nclass Prev extends Hook {\r\n    constructor(\r\n        public match?: (token: Token | any, env: IScanEnv) => number | boolean,\r\n        public onlyToken?: boolean\r\n    ) {\r\n        super();\r\n    }\r\n    use(env: IScanEnv) {\r\n\r\n        let { tokens, hookPoint } = env;\r\n        hookPoint -= 1;\r\n        let prev = tokens[hookPoint];\r\n        if (!this.onlyToken || prev instanceof Token) {\r\n            if (this.match) {\r\n                let res = this.match(prev, env);\r\n                if (res) {\r\n                    if (typeof res === \"number\" && res !== prev.value.length) {\r\n                        tokens.splice(\r\n                            hookPoint, 1,\r\n                            prev.slice(0, -res), prev.slice(-res)\r\n                        );\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            env.hookPoint -= 1;\r\n        }\r\n    }\r\n}\r\nclass Pipe extends Hook {\r\n    mode = HOOK_MODE.PIPE;\r\n    constructor(public pipe: (token: any, env: IScanEnv, start: IPosition, end: IPosition) => any) {\r\n        super();\r\n    }\r\n    use(env: IScanEnv, start: IPosition, end: IPosition) {\r\n        let { tokens, hookPoint } = env;\r\n        let res = this.pipe(tokens[hookPoint], env, start, end);\r\n        if (res !== undefined) {\r\n            tokens[hookPoint] = res;\r\n        } else {\r\n            tokens.splice(hookPoint, 1);\r\n        }\r\n    }\r\n}\r\nclass Pick extends Pipe {\r\n    mode = HOOK_MODE.RESOLVE;\r\n}\r\n\r\nclass Call extends Hook {\r\n    constructor(\r\n        public use: (env: IScanEnv, start: IPosition, end: IPosition, begin: IPosition) => any,\r\n        public mode: HOOK_MODE\r\n    ) {\r\n        super();\r\n    }\r\n}\r\nclass NoCapture extends Hook {\r\n    mode = HOOK_MODE.CAPTURE;\r\n    constructor() {\r\n        super()\r\n    }\r\n    use(env: IScanEnv, start: IPosition, end: IPosition) {\r\n        let { tokens, hookPoint } = env;\r\n        tokens.splice(hookPoint, 1);\r\n        if (start.offset < env.offset/*end.offset === env.offset*/) {\r\n            env.offset = start.offset;\r\n            env.line = start.line;\r\n            env.column = start.column;\r\n        }\r\n    }\r\n}\r\n\r\nnamespace OPERATIONS {\r\n    export const\r\n        FINISH = new String(\"FINISH\"),\r\n        WRAP = new String(\"WRAP\"),\r\n        UNWRAP = new String(\"UNWRAP\"),\r\n        UNWRAP_ALL = new String(\"UNWRAP_ALL\"),\r\n        OPTION = new String(\"OPTION\"),\r\n        SPLIT = new String(\"SPLIT\"),\r\n        NO_COLLECT = new String(\"NO_COLLECT\"),\r\n        NO_CAPTURE = new String(\"NO_CAPTURE\"),\r\n        MARK_AS_ROOT = new String(\"MARK_AS_ROOT\"),\r\n        FORK_IN_PARENT = new String(\"FORK_IN_PARENT\"),\r\n        FORK_IN_ROOT = new String(\"FORK_IN_ROOT\"),\r\n        END = new String(\"END\"),\r\n        END_ON_LEFT = new String(\"END_ON_LEFT\");\r\n\r\n    export const useKey = function (key: string | Token, value: any) {\r\n        return new UseKey(key.toString(), value);\r\n    }\r\n\r\n    export const\r\n        node = function (\r\n            val: string,\r\n            map?: (tokens: Array<any>, env: IScanEnv, start: IPosition, end: IPosition) => any,\r\n            useContent = false,\r\n            mode = HOOK_MODE.RESOLVE\r\n        ) {\r\n            const node = new Node(val, map, useContent);\r\n            node.mode = mode;\r\n            return node;\r\n        },\r\n        key = function (val: string, map?: (token: any, env: IScanEnv, start: IPosition, end: IPosition) => any) {\r\n            return new Key(val, map);\r\n        },\r\n        pick = function (map?: (token: any, env: IScanEnv, start: IPosition, end: IPosition) => any) {\r\n            return new Pick(map || function () { });\r\n        },\r\n        hook = function (fn: (env: IScanEnv, start: IPosition, end: IPosition, begin: IPosition) => void, mode = HOOK_MODE.RESOLVE) {\r\n            return new Call(fn, mode);\r\n        },\r\n        pipe = function (pipe?: (token: any, env: IScanEnv, start: IPosition, end: IPosition) => any) {\r\n            return new Pipe(pipe || function () { });\r\n        },\r\n        prev = function (match?: (token: Token | any, env: IScanEnv) => number | boolean, onlyToken?: boolean) {\r\n            return new Prev(match, onlyToken);\r\n        },\r\n        merge = function (\r\n            map: (tokens: Array<any>, env: IScanEnv, start: IPosition, end: IPosition) => any\r\n                = function (tokens) { return tokens; }\r\n        ) {\r\n            return new Merge(map);\r\n        };\r\n\r\n\r\n\r\n    export const\r\n        MATCH_BEGIN = \"\",\r\n        MATCH_END = \"\",\r\n        MATCH_EOF: IPattern = [[\"\", \"\"]],\r\n        MERGE_ALL_TOKENS = merge(\r\n            function (tokens: Array<Token>) {\r\n                return tokens.reduce((res, token) => res.concat(token));\r\n            }\r\n        ),\r\n        UNFOLD = hook(function (env) {\r\n            const { tokens, hookPoint } = env;\r\n            for (const item of tokens.splice(hookPoint)) {\r\n                if (item instanceof Array) {\r\n                    tokens.push(...item);\r\n                } else {\r\n                    tokens.push(item);\r\n                }\r\n            }\r\n        }, HOOK_MODE.RESOLVE);\r\n}\r\n\r\n\r\nnamespace MARKS {\r\n    export const\r\n        FINISH = OPERATIONS.FINISH,\r\n        END = OPERATIONS.END,\r\n        END_ON_LEFT = OPERATIONS.END_ON_LEFT,\r\n        UNWRAP = OPERATIONS.UNWRAP,\r\n        WRAP = OPERATIONS.WRAP,\r\n        ROOT = new String(\"ROOT\");\r\n\r\n\r\n    export const\r\n        RESOLVE = \"_RESOLVE_\",\r\n        TYPE = \"_TYPE_\",\r\n        ROLL = \"_ROLL_\",\r\n        PARENT = \"_PARENT_\",\r\n        COLLECT = \"_COLLECT_\",\r\n        BUBBING_HOOKS = \"_BUBBING_HOOKS_\",\r\n        CAPTURING_HOOKS = \"_CAPTURING_HOOKS_\",\r\n        SLICE_HOOKS = \"_SLICE_HOOKS_\",\r\n        IGNORE_TESTS = \"_IGNORE_TESTS_\";\r\n\r\n\r\n\r\n    export const RESOLVE_TYPE_SET: Set<String> = new Set([\r\n        OPERATIONS.FINISH,\r\n        OPERATIONS.END,\r\n        OPERATIONS.END_ON_LEFT,\r\n        OPERATIONS.UNWRAP,\r\n        OPERATIONS.UNWRAP_ALL,\r\n        OPERATIONS.WRAP,\r\n        ROOT    // 只是个占位\r\n    ]);\r\n}\r\n\r\nclass Scanner {\r\n\r\n    private scanTree: Record<string, any>;\r\n    public useEscape = false;\r\n    public useFold = true;\r\n    public ignoreCase = false;\r\n    constructor(\r\n        pattern: IPattern,\r\n        configure?: { useEscape?: boolean, useFold?: boolean, ignoreCase?: boolean }\r\n    ) {\r\n        this.scanTree = build(pattern);\r\n        configure && Object.assign(this, configure);\r\n    }\r\n\r\n    scan(options: IScanEnv | string) {\r\n        let env = typeof options === \"string\" ? {\r\n            tokens: [],\r\n            input: options,\r\n            begin: 0,\r\n            offset: 0,\r\n            end: options.length,\r\n            line: 1,\r\n            column: 1,\r\n            useFold: this.useFold,\r\n            useEscape: this.useEscape,\r\n            ignoreCase: this.ignoreCase,\r\n            hookPoint: 0\r\n        } : options;\r\n\r\n        let matchPool: Array<[any, ISlices]> = [];\r\n        let scopeStack: Array<IScope> = [[\r\n            this.scanTree,\r\n            getPosition(), getPosition(), getPosition(),\r\n            0, false\r\n        ]];\r\n        let resolveState: IResolveState;\r\n        let hasEscape = 0;\r\n        let isBegin = true;\r\n\r\n\r\n        let cpos: IPosition;\r\n        while (true) {\r\n\r\n            if (!hasEscape) {\r\n                // 如果启用 useEscape 模式，字符捕获焦点从可能的 \\ 号开始\r\n                cpos = getPosition();\r\n            }\r\n\r\n            let char: string;\r\n\r\n            if (!isBegin) {\r\n\r\n                if (env.offset >= env.end) {\r\n\r\n                    // 首个匹配符为 \"\" 则代表匹配每一轮的开始\r\n                    // 当前面存在匹配符，后面出现的单独的 \"\" 匹配符则代表匹配输入内容的结束\r\n                    // 如果仅匹配输入内容的结束，可以这样描述 : [\"\",\"\"]\r\n\r\n                    if (\r\n                        scopeStack[0][SCOPE.CURSOR].offset < cpos.offset\r\n                    ) {// 匹配扫描过程已结束\r\n                        if (match(\"\") || resolve()) {\r\n                            return env;\r\n                        }\r\n                        if (env.offset < env.end) {\r\n                            break;\r\n                        }\r\n                        matchPool.length = 0;\r\n                        match(\"\");\r\n                    }\r\n                    if (matchPool.length) {\r\n                        const state = resolveState;\r\n                        match(\"\", true);\r\n                        // 仅匹配 OPERATIONS.MATCH_EOF 的 [\"\",\"\"] \r\n                        // 排除 OPERATIONS.MATCH_BEGIN OPERATIONS.MATCH_END 的 \"\"\r\n                        if (state !== resolveState && resolve()) {\r\n                            return env;\r\n                        }\r\n                    }\r\n                    if (scopeStack[0][SCOPE.CURSOR].offset < cpos.offset) {\r\n                        collect(scopeStack[0][SCOPE.CURSOR], cpos, null);\r\n                    }\r\n                    break;\r\n                }\r\n\r\n                char = env.input[env.offset];\r\n                env.offset += 1;\r\n\r\n                switch (char) {\r\n                    case \"\\r\":\r\n                        if (env.input[env.offset] !== \"\\n\") {\r\n                            //env.column = 0;\r\n                            break;\r\n                        }\r\n                        // 将 \\r\\n 归类为 \\n 处理\r\n                        char = \"\\n\";\r\n                        env.offset += 1;\r\n                    case \"\\n\":\r\n                        env.line += 1;\r\n                        env.column = 0;\r\n                        break;\r\n                }\r\n                env.column += 1;\r\n                env.ignoreCase && (char = char.toLowerCase());\r\n\r\n                if (env.useEscape) {\r\n                    if (char === \"\\\\\") {\r\n                        hasEscape ^= 1;\r\n                        if (hasEscape) {\r\n                            continue;\r\n                        }\r\n                    } else if (hasEscape) {\r\n                        hasEscape = 0;\r\n                        char = \"\\\\\" + char;\r\n                    }\r\n                }\r\n            } else {\r\n                char = \"\";\r\n                isBegin = false;\r\n            }\r\n            \r\n            if (match(char)) {\r\n                return env;\r\n            }\r\n        }\r\n\r\n        return env;\r\n\r\n\r\n        function getPosition(): IPosition {\r\n            return { offset: env.offset, line: env.line, column: env.column }\r\n        }\r\n\r\n        function match(key: string, noResolve?: boolean) {\r\n            const pool = matchPool;\r\n            const scopeNode = scopeStack[0][SCOPE.NODE];\r\n\r\n            matchPool = [];\r\n\r\n            let node: any;\r\n            let slices: ISlices;\r\n            let hasBranch: boolean;\r\n            let hasScopeNode = false;\r\n\r\n            while (true) {\r\n                if (pool.length) {\r\n                    [node, slices] = pool.shift();\r\n                } else if (!resolveState && !hasScopeNode) {\r\n                    node = scopeNode;\r\n                    slices = null;\r\n                } else {\r\n                    break;\r\n                }\r\n                hasScopeNode = hasScopeNode || (node === scopeNode);\r\n                hasBranch = false;\r\n\r\n                resolveState = walk(node, slices)\r\n                    || node[MARKS.ROLL] && walk(node[MARKS.ROLL], slices)\r\n                    || resolveState;\r\n            }\r\n\r\n\r\n            if (!noResolve && matchPool.length === 0 && resolve()) {\r\n                return true;\r\n            }\r\n\r\n            function walk(parent: any, slices?: ISlices): IResolveState {\r\n                let node = parent[key];\r\n                if (!node) {\r\n                    return;\r\n                }\r\n                if (!slices) {\r\n                    slices = [[cpos, parent[MARKS.CAPTURING_HOOKS]]];\r\n                } else if (hasBranch) {\r\n                    slices = slices.slice();\r\n                }\r\n                hasBranch = true;\r\n\r\n                matchPool.push([node, slices]);\r\n                if (node[MARKS.CAPTURING_HOOKS]) {\r\n                    slices.push([getPosition(), node[MARKS.CAPTURING_HOOKS]]);\r\n                }\r\n\r\n                if (!node[MARKS.RESOLVE]) {\r\n                    return;\r\n                } else {\r\n                    node = node[MARKS.RESOLVE];\r\n                }\r\n                return [node, getPosition(), slices, scopeStack.length];\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        function resolve() {\r\n            if (!resolveState) {\r\n                return;\r\n            }\r\n\r\n            const [node, { offset, line, column }, splits, stackSize] = resolveState;\r\n            scopeStack.splice(0, scopeStack.length - stackSize);\r\n            env.offset = offset;\r\n            env.line = line;\r\n            env.column = column;\r\n\r\n            let backSteps = finallize(node, splits, true);\r\n            if (backSteps > 0) {\r\n                return true;\r\n            }\r\n\r\n            if (backSteps < 0) {\r\n                do {\r\n                    const scope = scopeStack.shift();\r\n                    let tokens = env.tokens;\r\n                    if (scope[SCOPE.USE_FOLD]) {\r\n                        (env.tokens = tokens.shift()).pop();\r\n                    } else {\r\n                        tokens.length = scope[SCOPE.BACK_POINT];\r\n                    }\r\n                } while (++backSteps < 0)\r\n            }\r\n            //rollback(res);\r\n            resolveState = null;\r\n            isBegin = true;\r\n        }\r\n\r\n        function finallize(node: any, slices: ISlices, use_collect?: boolean): number {\r\n\r\n            let type = node[MARKS.TYPE];\r\n\r\n            const scope = scopeStack[0];\r\n            const startPos = slices[0][0];\r\n            let len = env.tokens.length;\r\n\r\n            if (use_collect) {\r\n\r\n                let hooks: Array<Hook>;\r\n                let sliceHooks = node[MARKS.SLICE_HOOKS];\r\n                if (sliceHooks) {\r\n                    hooks = slices[0][1];\r\n                    hooks && (hooks = hooks.filter(item => sliceHooks.has(item)));\r\n                }\r\n                collect(scope[SCOPE.CURSOR], startPos, hooks);\r\n            }\r\n\r\n            if (type === MARKS.WRAP) {\r\n                return wrap(node, slices, use_collect);\r\n            }\r\n\r\n            const hookPoint = env.tokens.length;\r\n\r\n            if (use_collect && type !== MARKS.END_ON_LEFT) {\r\n                let res = collectSlices(slices, node[MARKS.SLICE_HOOKS]);\r\n                if (res < 0) {\r\n                    env.tokens.length = len;\r\n                    return res + 1;\r\n                }\r\n            }\r\n            env.hookPoint = hookPoint;\r\n\r\n            if (type === MARKS.UNWRAP) {\r\n                return unwrap(node, slices);\r\n            } else {\r\n                const cursorPos = getPosition();\r\n                const res = useHook(node[MARKS.BUBBING_HOOKS], startPos, cursorPos);\r\n                if (res < 0) {\r\n                    env.tokens.length = len;\r\n                    return res + 1;\r\n                }\r\n                if (type !== MARKS.END_ON_LEFT) {\r\n                    scope[SCOPE.CURSOR] = cursorPos;\r\n                } else {\r\n                    env.offset = startPos.offset;\r\n                    env.line = startPos.line;\r\n                    env.column = startPos.column;\r\n                    scope[SCOPE.CURSOR] = startPos;\r\n                    return 1;\r\n                }\r\n                return type !== MARKS.END ? res : 1;\r\n            }\r\n\r\n        }\r\n\r\n\r\n        function wrap(node: any, slices: ISlices, use_collect?: boolean) {\r\n            const { useFold, tokens } = env;\r\n            const backPoint = tokens.length;\r\n            const startPos = slices[0][0];\r\n            const beginPos = getPosition();\r\n            const cursorPos = getPosition();\r\n            scopeStack.unshift([\r\n                node,\r\n                startPos, beginPos, cursorPos,\r\n                backPoint, useFold\r\n            ]);\r\n\r\n            if (useFold) {\r\n                env.tokens = [tokens];\r\n                env.hookPoint = 1;\r\n            }\r\n\r\n\r\n            let backSteps = use_collect ? collectSlices(\r\n                slices,\r\n                node[MARKS.SLICE_HOOKS]\r\n            ) : 0;\r\n\r\n            if (backSteps >= 0) {\r\n                backSteps = useHook(node[MARKS.BUBBING_HOOKS], startPos, cursorPos, beginPos);\r\n                if (backSteps >= 0) {\r\n                    node = node[MARKS.RESOLVE];\r\n                    return node ? finallize(node, slices, false) : backSteps;\r\n                }\r\n            }\r\n            return backSteps;\r\n        }\r\n\r\n\r\n        function unwrap(node: any, slices: ISlices) {\r\n\r\n            const scope = scopeStack.shift();\r\n\r\n            if (scope[SCOPE.USE_FOLD]) {\r\n                let tokens = env.tokens.shift()\r\n                env.hookPoint = tokens.length;\r\n                tokens.push(env.tokens);\r\n                env.tokens = tokens;\r\n            }\r\n\r\n            let backSteps = useHook(\r\n                node[MARKS.BUBBING_HOOKS],\r\n                scope[SCOPE.START],\r\n                getPosition(),\r\n                scope[SCOPE.BEGIN],\r\n            );\r\n            if (backSteps >= 0) {\r\n                node = node[MARKS.RESOLVE];\r\n\r\n                scopeStack[0][SCOPE.CURSOR] = getPosition();\r\n                if (node) {\r\n                    backSteps = finallize(node, slices, false);\r\n                    if (backSteps >= 0) {\r\n                        return backSteps;\r\n                    }\r\n                } else {\r\n                    return backSteps;\r\n                }\r\n            }\r\n            scopeStack.unshift(scope);\r\n            if (scope[SCOPE.USE_FOLD]) {\r\n                let tokens = env.tokens.pop();\r\n\r\n                tokens.unshift(env.tokens);\r\n                env.tokens = tokens;\r\n            }\r\n            return backSteps + 1;\r\n        }\r\n\r\n        function useHook(hooks: Array<Hook>, start: IPosition, end: IPosition, begin?: IPosition): number {\r\n            for (const hook of hooks) {\r\n                let res = hook.use(env, start, end, begin);\r\n                if (res < 0) {\r\n                    return res;\r\n                }\r\n            }\r\n            return 0;\r\n        }\r\n\r\n        function collect(start: IPosition, end: IPosition, hooks: Array<Hook>) {\r\n            let res: any = 0;\r\n            if (start.offset < end.offset) {\r\n                let { tokens } = env;\r\n                env.hookPoint = tokens.length;\r\n                tokens.push(\r\n                    new Token(\r\n                        env.input.slice(start.offset, end.offset),\r\n                        start,\r\n                        end\r\n                    )\r\n                );\r\n                if (hooks) {\r\n                    res = useHook(hooks, start, end);\r\n                }\r\n            }\r\n            return res;\r\n        }\r\n\r\n        function collectSlices(\r\n            slices: ISlices,\r\n            sliceHooks: Set<Hook>\r\n        ) {\r\n            let cursor = slices[0][0];\r\n            if (sliceHooks) {\r\n                for (let i = 1; i < slices.length; i += 1) {\r\n                    let [next, hooks] = slices[i];\r\n                    hooks = hooks.filter(item => sliceHooks.has(item));\r\n                    if (hooks.length) {\r\n                        const res = collect(cursor, next, hooks);\r\n                        if (res < 0) {\r\n                            return res;\r\n                        }\r\n                        cursor = next;\r\n                    }\r\n                }\r\n            }\r\n            return collect(cursor, getPosition(), null);\r\n        }\r\n    }\r\n}\r\n\r\n\r\nclass Token {\r\n\r\n    loc: ISourceLocation;\r\n\r\n    constructor(public value: string, start: IPosition, end: IPosition) {\r\n        this.loc = { start, end };\r\n    }\r\n    trim() {\r\n        const found = this.value.match(/^\\s*|\\s*$/gm);\r\n        return this.slice(found[0].length, this.value.length - found[1].length);\r\n    }\r\n    concat(token: Token) {\r\n        return new Token(this.value + token.value, this.loc.start, token.loc.end);\r\n    }\r\n    slice(beginIndex: number, endIndex = this.value.length) {\r\n        let { value, loc: { start, end } } = this;\r\n        let { offset, line, column } = start;\r\n        let index = 0;\r\n\r\n        if (endIndex < 0) {\r\n            endIndex = value.length + endIndex;\r\n        }\r\n        if (beginIndex < 0) {\r\n            beginIndex = value.length + beginIndex;\r\n        }\r\n        if (beginIndex > endIndex) {\r\n            endIndex = beginIndex;\r\n        }\r\n        const range = [beginIndex, endIndex].map(\r\n            function (limit): IPosition {\r\n                if (limit === 0) {\r\n                    return start;\r\n                }\r\n                if (limit === value.length) {\r\n                    return end;\r\n                }\r\n                while (index < limit) {\r\n                    if (value[index] === \"\\n\") {\r\n                        line += 1;\r\n                        column = 1;\r\n                    } else {\r\n                        column += 1;\r\n                    }\r\n                    index += 1;\r\n                }\r\n                return { offset: offset + limit, line, column }\r\n            }\r\n        )\r\n        return new Token(value.slice(beginIndex, endIndex), range[0], range[1]);\r\n    }\r\n    toString() {\r\n        return this.value;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\ntype HookStack = Array<Hook | HookStack | RootStack>;\r\ntype HookList = Array<Hook>;\r\n\r\nclass RootStack extends Array<Hook | HookStack> { }\r\n\r\ntype BubbleTable = Array<HookStack>;\r\ntype CaptureTable = Array<HookList>;\r\ntype BuildResult = [Array<any>, BubbleTable, CaptureTable];\r\n\r\nfunction build(pattern: IPattern): Record<string, any> {\r\n    const matchTree = { [MARKS.TYPE]: MARKS.ROOT };\r\n    const [nodes, bubbling_map, capturing_map] = buildRule(\r\n        [pattern],\r\n        [matchTree],\r\n        [[new RootStack()]],\r\n        [[]],\r\n        [matchTree]\r\n    );\r\n    for (let i = 0; i < nodes.length; i += 1) {\r\n        // 被省去 MARKS.FINISH 的描述自动补全\r\n        const node = nodes[i];\r\n        if (!MARKS.RESOLVE_TYPE_SET.has(node[MARKS.TYPE])) {\r\n            buildKey(MARKS.FINISH, [node], [bubbling_map[i]], [capturing_map[i]]);\r\n        }\r\n    }\r\n    return matchTree;\r\n}\r\n\r\n\r\nfunction buildRule(\r\n    patterns: Array<IPattern>,\r\n    nodes: Array<any>,\r\n    bubbleTable: BubbleTable,\r\n    captureTable: CaptureTable,\r\n    scopeChain: Array<any>\r\n): BuildResult {\r\n\r\n    const rsRule: Array<IPattern> = [];\r\n    let index = 0;\r\n    let key: IPattern;\r\n    while (index < patterns.length) {\r\n        let ndepth = 0, begin = index;\r\n        const forkChain: Array<number | String> = [];\r\n\r\n        while (true) {\r\n            if (patterns[index] === OPERATIONS.FORK_IN_ROOT) {\r\n                if (ndepth) {\r\n                    forkChain.push(ndepth);\r\n                    ndepth = 0;\r\n                }\r\n                forkChain.push(OPERATIONS.FORK_IN_ROOT);\r\n            } else if (patterns[index] === OPERATIONS.FORK_IN_PARENT) {\r\n                ndepth += 1;\r\n            } else {\r\n                break;\r\n            }\r\n            index += 1;\r\n        }\r\n\r\n        if (index !== begin) {\r\n            ndepth && forkChain.push(ndepth);\r\n\r\n            for (let node of nodes) {\r\n                let parent: any = node;\r\n                let cursor = 0;\r\n                for (let d of forkChain) {\r\n                    if (d === OPERATIONS.FORK_IN_ROOT) {\r\n                        parent = scopeChain[cursor++];\r\n                    } else {\r\n                        do {\r\n                            parent = parent[MARKS.PARENT];\r\n                            if (parent === scopeChain[cursor]) {\r\n                                cursor += 1;\r\n                            }\r\n                        } while (--(<number>d) > 0)\r\n                    }\r\n                }\r\n                if (node[MARKS.ROLL] !== parent) {\r\n                    if (node[MARKS.ROLL]) {\r\n                        debugger;   // 暂不支持一个匹配路径存在多个 FORK 匹配（用不到）\r\n                    }\r\n                    node[MARKS.ROLL] = parent;\r\n                }\r\n            }\r\n            continue;\r\n        }\r\n\r\n        switch (key = patterns[index]) {\r\n            case OPERATIONS.NO_CAPTURE:\r\n            case OPERATIONS.NO_COLLECT:\r\n                rsRule.push(key);\r\n            case OPERATIONS.SPLIT:\r\n                setHook(null);\r\n                break;\r\n\r\n            case OPERATIONS.OPTION:\r\n                return walk(\r\n                    [\r\n                        rsRule.concat(patterns.slice(index + 1)),\r\n                        rsRule.concat(patterns.slice(index + 2))\r\n                    ],\r\n                    function (pattern) {\r\n                        return buildRule(\r\n                            pattern,\r\n                            nodes,\r\n                            bubbleTable.map(hooks => hooks.slice()),\r\n                            captureTable.map(maps => maps.slice()),\r\n                            scopeChain\r\n                        )\r\n                    }\r\n                );\r\n\r\n            case OPERATIONS.MARK_AS_ROOT:\r\n                patterns = rsRule.concat(patterns.slice(index + 1));\r\n                return walk(nodes, function (node, index) {\r\n                    const bubbleHooks = bubbleTable[index];\r\n                    return buildRule(\r\n                        patterns,\r\n                        [node],\r\n                        [[new RootStack(...<HookStack>bubbleHooks[0])].concat(bubbleHooks.slice(1))],\r\n                        [captureTable[index]],\r\n                        [node].concat(scopeChain)\r\n                    )\r\n                });\r\n            default:\r\n                if (key instanceof Hook) {\r\n                    setHook(key);\r\n                } else {\r\n                    if (key instanceof Array) {\r\n                        [nodes, bubbleTable, captureTable] = walk(key, function (item) {\r\n                            return (item instanceof Array ? buildRule : buildKey)(\r\n                                item, nodes,\r\n                                bubbleTable.map(hooks => hooks.slice()),\r\n                                captureTable.map(maps => maps.slice()),\r\n                                scopeChain\r\n                            )\r\n                        })\r\n                    } else {\r\n                        [nodes, bubbleTable, captureTable] = buildKey(key, nodes, bubbleTable, captureTable);\r\n                    }\r\n                    while (rsRule.length) {\r\n                        setHook(\r\n                            rsRule.shift() === OPERATIONS.NO_COLLECT\r\n                                ? OPERATIONS.pipe()\r\n                                : new NoCapture()\r\n                        );\r\n                    }\r\n                }\r\n                break;\r\n        }\r\n\r\n        index += 1;\r\n    }\r\n\r\n    return [nodes, bubbleTable, captureTable];\r\n\r\n\r\n    function walk(\r\n        list: Array<any>,\r\n        next: (item: any, index: number) => BuildResult\r\n    ): BuildResult {\r\n\r\n        let newNodes: Array<any> = [];\r\n        let newBubbleTable: Array<HookStack> = [];\r\n        let newCaptureTable: Array<any[]> = [];\r\n\r\n        for (let i = 0; i < list.length; i += 1) {\r\n            const res = next(list[i], i);\r\n            newNodes = newNodes.concat(res[0]);\r\n            newBubbleTable = newBubbleTable.concat(res[1]);\r\n            newCaptureTable = newCaptureTable.concat(res[2]);\r\n        }\r\n\r\n\r\n        return [newNodes, newBubbleTable, newCaptureTable];\r\n\r\n    }\r\n    function setHook(hook: Hook) {\r\n\r\n        if (!hook) {\r\n            hook = new Call(function () { }, HOOK_MODE.CAPTURE);\r\n            for (let i = 0; i < nodes.length; i += 1) {\r\n                MARKS.RESOLVE_TYPE_SET.has(nodes[i][MARKS.TYPE]) || addHook(i);\r\n            }\r\n            return;\r\n        }\r\n        switch (hook.mode) {\r\n            case HOOK_MODE.RESOLVE:\r\n                bubbleTable.forEach(hooks => hooks.push(<Hook>key));\r\n                break;\r\n            case HOOK_MODE.PIPE:\r\n            case HOOK_MODE.CAPTURE:\r\n                for (let i = 0; i < nodes.length; i += 1) {\r\n                    addHook(i);\r\n                }\r\n                break;\r\n        }\r\n        function addHook(index: number) {\r\n            const node = nodes[index];\r\n            const type = node[MARKS.TYPE];\r\n            // 实际使用中不会刻意用到共用钩子的情况，统一使之不共用可降低声明成本和更符合声明直觉\r\n            const h = Object.create(hook);\r\n            if (hook.mode !== HOOK_MODE.PIPE && MARKS.RESOLVE_TYPE_SET.has(type)) {\r\n                node[MARKS.BUBBING_HOOKS].push(h);\r\n            } else {\r\n                (\r\n                    node[MARKS.CAPTURING_HOOKS]\r\n                    || (node[MARKS.CAPTURING_HOOKS] = [])\r\n                ).push(h);\r\n                captureTable[index].push(h);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\nfunction buildKey(\r\n    key: any,\r\n    nodes: Array<any>,\r\n    bubbleTable: BubbleTable,\r\n    captureTable: CaptureTable,\r\n    scopeChain?: Array<any>\r\n): BuildResult {\r\n    if (typeof key === \"string\") {\r\n        if (/^[\\s\\S]?$/.test(key)) {\r\n            key = [key];\r\n        }\r\n        for (let i = 0; i < key.length; i += 1) {\r\n            nodes = nodes.map(function (node) {\r\n                return node[key[i]] || (node[key[i]] = { [MARKS.PARENT]: node });\r\n            });\r\n        }\r\n    } else if (MARKS.RESOLVE_TYPE_SET.has(key)) {\r\n\r\n        nodes = nodes.map(function (node, i) {\r\n\r\n            let bubbleHooks: HookStack = bubbleTable[i];\r\n            let captureHooks = captureTable[i];\r\n            captureTable[i] = [];\r\n\r\n            if (key === OPERATIONS.UNWRAP_ALL) {\r\n                key = OPERATIONS.UNWRAP;\r\n                if (!(bubbleHooks[0] instanceof RootStack)) {\r\n                    if (bubbleHooks.length > 1) {\r\n                        bubbleHooks[0] = (<HookStack>bubbleHooks[0]).concat(bubbleHooks.slice(1));\r\n                    }\r\n                    do {\r\n                        bubbleTable[i] = [bubbleHooks[0][0]];\r\n                        bubbleHooks = <HookStack>bubbleHooks[0];\r\n\r\n                        node = getResolveNode(node, key, bubbleHooks, captureHooks);\r\n                    } while (!(bubbleHooks[0] instanceof RootStack))\r\n                }\r\n            } else {\r\n                if (key === OPERATIONS.UNWRAP) {\r\n                    bubbleTable[i] = [bubbleHooks[0][0]];\r\n                    bubbleHooks = (<HookStack>bubbleHooks[0]).concat(bubbleHooks.slice(1));\r\n                } else if (key === OPERATIONS.WRAP) {\r\n                    bubbleTable[i] = [bubbleHooks];\r\n                    bubbleHooks = [];\r\n                } else {\r\n                    bubbleTable[i] = [bubbleHooks[0]];\r\n                }\r\n\r\n                node = getResolveNode(node, key, bubbleHooks, captureHooks);\r\n\r\n            }\r\n            return node;\r\n        });\r\n\r\n    } else {\r\n        debugger;\r\n    }\r\n    return [nodes, bubbleTable, captureTable];\r\n\r\n    function getResolveNode(\r\n        node: any, type: string,\r\n        bubbleHooks: HookStack, sliceHooks: HookList\r\n    ) {\r\n        if (node[MARKS.RESOLVE]) {\r\n            // 如果存在重复定义的 pattern 则这里会执行\r\n            debugger;\r\n        }\r\n        return node[MARKS.RESOLVE] = {\r\n            [MARKS.PARENT]: node,\r\n            [MARKS.TYPE]: type,\r\n            [MARKS.SLICE_HOOKS]: sliceHooks.length\r\n                ? new Set(sliceHooks.splice(0))\r\n                : null,\r\n            [MARKS.BUBBING_HOOKS]: bubbleHooks.slice(1).reverse()\r\n        };\r\n    }\r\n\r\n}\r\n\r\nfunction unwrapTokens(tokens: any) {\r\n    if (tokens instanceof Token) {\r\n        return tokens.value;\r\n    }\r\n    if (tokens instanceof Array) {\r\n        return tokens.map(unwrapTokens);\r\n    }\r\n    return tokens;\r\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","// \\@ts-nocheck\r\n\r\nimport { Scanner, OPERATIONS } from \"./scanner\"\r\n\r\nimport CSSGrammar from \"./css-grammar\";\r\n\r\nimport HTMLGrammar from \"./html-grammar\";\r\n\r\nimport JSONGrammar from \"./json-grammar\";\r\n\r\n\r\nconst {\r\n    FINISH,\r\n    WRAP, UNWRAP, UNWRAP_ALL,\r\n    OPTION,\r\n    SPLIT,\r\n    NO_COLLECT, NO_CAPTURE,\r\n    MARK_AS_ROOT, FORK_IN_PARENT, FORK_IN_ROOT,\r\n    END, END_ON_LEFT,\r\n    useKey,\r\n    node, key, pick, hook, pipe, prev, merge,\r\n\r\n    MATCH_BEGIN,\r\n    MATCH_END,\r\n    MATCH_EOF,\r\n    MERGE_ALL_TOKENS\r\n} = OPERATIONS;\r\n\r\nglobal.Scanner = Scanner;\r\n\r\n\r\nconst cssScanner = global.cssScanner = new Scanner(CSSGrammar, { useEscape: true });\r\n\r\ntrue && console.log(\r\n    \"css\",\r\n    cssScanner.scan(global.css_text = `\r\n\r\n@media screen and (min-width: 480px) {\r\n    body {\r\n        background:   lightgreen reply\r\n    }\r\n}\r\n\r\n#main {\r\n    border: 1px solid black;\r\n}\r\n\r\nul li {\r\n\tpadding: 5px;\r\n}\r\n\r\n@font-face {\r\n    src: url('~@/static/iconfont.ttf');\r\n}\r\n\r\n@font-face {\r\n    font-family:  MyHelvetica  !important;\r\n    src: local(\"Helvetica Neue Bold\"),\r\n    local(\"HelveticaNeue-Bold\"),\r\n    url(MgOpenModernaBold.ttf);\r\n    font-weight: bold\r\n}\r\n@keyframes test{\r\n    from, 50%{\r\n        transform:translate(50%,0);\r\n    }\r\n    to{\r\n        transform:translate(100px,0);\r\n    }\r\n}\r\n@media only screen and (min-width: 320px) and (max-width: 480px) and (resolution: 150dpi) {\r\n    body {\r\n        line-height: 1.4\r\n    }\r\n}\r\n\r\n`)\r\n);\r\n\r\n\r\n\r\nconst htmlScanner = global.htmlScanner = new Scanner(HTMLGrammar, { useEscape: false, useFold: true, ignoreCase: true });\r\n\r\n// production 版本注释区的有用文本会被去除\r\ntrue && console.log(\r\n    \"html\",\r\n    htmlScanner.scan(\r\n        global.html_text = (function () {\r\n            /*\r\n    <!DOCTYPE html>\r\n    <html>\r\n      <head>\r\n        <title>test</title>\r\n        <meta charset=\"UTF-8\">\r\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n        <style>\r\n        @media screen and (min-width: 480px) {\r\n        body {\r\n            background:   lightgreen reply\r\n        }\r\n    }\r\n    #main {\r\n        border: 1px solid black;\r\n    }\r\n    \r\n    ul li {\r\n        padding: 5px;\r\n    }\r\n        \\</style>\r\n        </span>\r\n        </style>\r\n      </head>\r\n    <body>\r\n        <script/>\r\n        <script>s\\\"d\"43<span>5\" `sd${sdfsf\"</script>\"}` ff </text>f//</span>\r\n        </script>\r\n        <script id=\"test\">sd\"43<span>5\"f//</sciprt>\r\n        </script>\r\n        <span id=\"ss\">s\r\n        <input  id=\"test\"/>\r\n        <span></span>\r\n        s</span>\r\n        <textarea id=\"test\"><span></span><span></textarea >\r\n        <!--<span>-->\r\n        <span>sdfd</test></test2></span>\r\n        <span/>\r\n        <span alt=\"test\" sss eee/>sdfdsf\r\n        <span title = \"test\">test</span>\r\n        <input>\r\n        </text>\r\n        <input/>\r\n        <input  placeholder=\"test\">\r\n        <h1>My First Heading</h1>\r\n        <p>My first paragraph.</p>\r\n    </body>\r\n    </html>\r\n            */\r\n        }).toString().replace(/(^[\\s\\S]*?\\/\\*)|(\\*\\/[\\s\\S]*?$)/g, \"\")\r\n    )\r\n);\r\n\r\n\r\nconst jsonScanner = global.jsonScanner = new Scanner(JSONGrammar);\r\ntrue && console.log(\r\n    \"json\",\r\n    jsonScanner.scan(global.json_text = `\r\n{\r\n    \"key1\": [  true, false, null] ,\r\n    \"key2\"  : {\r\n        \"key3\"  : [1, 2, \"3\\\r\n        \" , 13.33e-10 , 1e-3]\r\n    },\r\n    \"KEY3\":334\r\n}\r\n`)\r\n);\r\n\r\n\r\nconst test = new Scanner([\r\n    [\r\n        [\r\n            \"||\",\r\n            \"|\",\r\n        ],\r\n        NO_COLLECT,\r\n        OPTION,\r\n        [\r\n            [\r\n                [` `, `\\t`, `\\n`],\r\n                OPTION,\r\n                [\r\n                    [\r\n                        [` `, `\\t`, `\\n`],\r\n                        FORK_IN_PARENT\r\n                    ]\r\n                ]\r\n            ]\r\n        ]\r\n\r\n    ]\r\n], { useEscape: true });\r\n\r\nconsole.log(test.scan(\"|| |  |||||\").tokens);\r\n\r\n"],"names":["FINISH","WRAP","UNWRAP","UNWRAP_ALL","OPTION","SPLIT","NO_COLLECT","NO_CAPTURE","MARK_AS_ROOT","FORK_IN_PARENT","FORK_IN_ROOT","END","END_ON_LEFT","useKey","node","key","pick","hook","pipe","prev","merge","MATCH_BEGIN","MATCH_END","MATCH_EOF","MERGE_ALL_TOKENS","UNFOLD","OPERATIONS","MATCH_WHITE_SPACE_CHARACHER","CLEAR_COMMENT","CLEAR_WHITE_SPACE_CHARACHER","TEST_KEYWORD_BOUNDARY","NODE_LIST","tokens","filter","token","Token","THROW_TOKEN_ERROR","Wrapper","env","start","end","console","log","MATCH_STRING","MATCH_CSS_ATTRIBUTE_VALUE","MATCH_CSS_ATTRIBUTE","value","CSSStyleRule","trim","undefined","CSSMediaRule","length","match","index","CSSKeyframesRule","CSSFontFaceRule","CSSSupportsRule","SELF_CLOSING_TAGS","MATCH_ATTRIBUTES","MATCH_TAG_END","MATCH_SCRIPT_TEXT","MATCH_SCRIPT_END","useEscape","ignoreCase","CSSScanner","Scanner","offset","MATCH_STYLE_END","scan","TextNode","tagName","matchCustomTag","tagEnd","collectChildNodes","collectAttrs","collectTagName","hookPoint","push","splice","attrs","i","getValue","Array","map","formatTokens","result","textNode","textToken","walk","forEach","concat","data","loc","nodes","pop","slice","toUpperCase","LITERAL_VALUE_MAP","true","false","null","COLLECT_STRING","input","Literal","PARSE_NUMBER_LITERAL","exec","int","frac","exp","Math","pow","Object","assign","raw","props","children","len","spearator","SCOPE","MARKS","Hook","mode","Node","constructor","type","useContent","super","this","NODE_MAP","eval","use","addItem","item","content","UseKey","Key","Merge","Prev","onlyToken","res","Pipe","Pick","Call","NoCapture","line","column","String","toString","val","fn","reduce","ROOT","RESOLVE","TYPE","ROLL","PARENT","COLLECT","BUBBING_HOOKS","CAPTURING_HOOKS","SLICE_HOOKS","IGNORE_TESTS","RESOLVE_TYPE_SET","Set","pattern","configure","useFold","scanTree","build","options","resolveState","cpos","begin","matchPool","scopeStack","getPosition","hasEscape","isBegin","char","CURSOR","resolve","state","collect","toLowerCase","noResolve","pool","scopeNode","NODE","slices","hasBranch","hasScopeNode","shift","parent","splits","stackSize","backSteps","finallize","scope","USE_FOLD","BACK_POINT","use_collect","startPos","hooks","sliceHooks","has","backPoint","beginPos","cursorPos","unshift","collectSlices","useHook","wrap","START","BEGIN","unwrap","cursor","next","found","beginIndex","endIndex","range","limit","RootStack","matchTree","bubbling_map","capturing_map","buildRule","buildKey","patterns","bubbleTable","captureTable","scopeChain","rsRule","ndepth","forkChain","setHook","maps","bubbleHooks","d","list","newNodes","newBubbleTable","newCaptureTable","addHook","h","create","test","captureHooks","getResolveNode","reverse","unwrapTokens","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","g","globalThis","Function","e","window","cssScanner","css_text","htmlScanner","html_text","replace","jsonScanner","json_text"],"sourceRoot":""}