{"version":3,"file":"js/../js/html-grammar.js","mappings":"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","sources":["webpack://astry/./js/css-grammar.ts","webpack://astry/./js/scanner.ts","webpack://astry/webpack/bootstrap","webpack://astry/./js/html-grammar.ts"],"sourcesContent":["import {\r\n    Scanner, OPERATIONS, HOOK_MODE, IScanEnv,\r\n    IPattern, Token,\r\n    IPosition, ISourceLocation,\r\n} from \"./scanner\"\r\n\r\n\r\nconst {\r\n    FINISH,\r\n    WRAP, UNWRAP, UNWRAP_ALL,\r\n    OPTION,\r\n    SPLIT,\r\n    NO_COLLECT, NO_CAPTURE,\r\n    MARK_AS_ROOT, FORK_IN_PARENT, FORK_IN_ROOT,\r\n    END, END_ON_LEFT,\r\n    useKey,\r\n    node, key, pick, hook, pipe, prev, merge,\r\n\r\n    MATCH_BEGIN,\r\n    MATCH_END,\r\n    MATCH_EOF,\r\n    MERGE_ALL_TOKENS,\r\n    UNFOLD\r\n} = OPERATIONS;\r\n\r\n\r\n\r\nconst MATCH_WHITE_SPACE_CHARACHER: IPattern = [` `, `\\n`, `\\t`];\r\nconst CLEAR_COMMENT: IPattern = [\r\n    [\r\n        NO_COLLECT,\r\n        [\r\n            [\"//\", WRAP, [\"\\n\", [MATCH_EOF]], UNWRAP],\r\n            [\"/*\", WRAP, [\"*/\", [MATCH_EOF]], UNWRAP],\r\n        ],\r\n    ]\r\n]\r\n\r\nconst CLEAR_WHITE_SPACE_CHARACHER: IPattern = [\r\n    [NO_COLLECT, MATCH_WHITE_SPACE_CHARACHER]\r\n];\r\n\r\n\r\nconst TEST_KEYWORD_BOUNDARY: IPattern = [\r\n    [NO_CAPTURE, [\" \", \"\\n\", `\\t`, \"(\", \")\", \"{\", \"}\", \":\"]]\r\n];\r\n\r\nconst NODE_LIST = function (tokens: Array<any>) {\r\n    return tokens.filter(token => !(token instanceof Token));\r\n}\r\nconst Declaration = node(\"Declaration\").Wrapper;\r\n\r\nconst THROW_TOKEN_ERROR = hook(function (env, start, end) {\r\n    console.log(\"Invalid or unexpected token\", start, end);\r\n}, HOOK_MODE.RESOLVE);\r\n\r\nconst MATCH_STRING: IPattern = [\r\n    [\r\n        `\"`, WRAP,\r\n        [\r\n            [THROW_TOKEN_ERROR, `\\n`],\r\n            [`\\\\`, [`\\\\`, `\\n`, `\"`]],\r\n            [`\"`, UNWRAP]\r\n        ]\r\n\r\n    ],\r\n    [\r\n        `'`, WRAP,\r\n        [\r\n            [THROW_TOKEN_ERROR, `\\n`],\r\n            [`\\\\`, [`\\\\`, `\\n`, `'`]],\r\n            [`'`, UNWRAP]\r\n        ]\r\n    ],\r\n]\r\n\r\n// 不包含 '' \"\" 的 url 地址可能会包含断义字符 / 影响判别，这里通过单独匹配给出结果\r\nconst MATCH_URL: IPattern = [\r\n    [\r\n        MATCH_BEGIN, \"url(\", WRAP,\r\n        [\r\n            [MATCH_STRING],\r\n            [CLEAR_WHITE_SPACE_CHARACHER],\r\n            [\")\", UNWRAP]\r\n        ],\r\n    ]\r\n];\r\n\r\nconst MATCH_CSS_ATTRIBUTE_VALUE: IPattern = [\r\n    [\r\n        MARK_AS_ROOT,\r\n        [\r\n            [MATCH_STRING],\r\n            [MATCH_URL],\r\n            [\r\n                // 使能在 ( 后被断句\r\n                // 这里没做额外检验允许括号前的空格\r\n                MERGE_ALL_TOKENS,\r\n                prev(null, true), \"(\"\r\n            ],\r\n            \")\",\r\n            [CLEAR_WHITE_SPACE_CHARACHER],\r\n            [CLEAR_COMMENT],\r\n            [\r\n                MERGE_ALL_TOKENS,\r\n                prev(null, true),\r\n                \"%\"\r\n            ],\r\n            \"/\",\r\n            \",\"\r\n        ]\r\n    ]\r\n]\r\nconst MATCH_CSS_ATTRIBUTE: IPattern = [\r\n    [CLEAR_COMMENT],\r\n    [CLEAR_WHITE_SPACE_CHARACHER],\r\n    [   //通用样式匹配\r\n        merge(function ([key, value]) {\r\n            return useKey(key, value);\r\n        }),\r\n        prev(function (token: any) {\r\n            if (token instanceof Token) {\r\n                return true;\r\n            }\r\n            debugger;\r\n        }),\r\n        NO_COLLECT, \":\", WRAP,\r\n        [\r\n            [MATCH_CSS_ATTRIBUTE_VALUE],\r\n            [\"!important\", NO_CAPTURE, [MATCH_END, \" \", \"\\n\", \"}\", \";\"]],\r\n            [NO_CAPTURE, \"}\", UNWRAP],\r\n            [NO_COLLECT, \";\", UNWRAP],\r\n            [MATCH_EOF, UNWRAP]\r\n        ]\r\n    ]\r\n]\r\n\r\nconst CSSStyleRule = [\r\n    node(\"CSSStyleRule\"),\r\n    key(\"selectorText\", function (token: Token) { return token.trim() }),\r\n    prev(function (token: any) {\r\n        if (token instanceof Token) {\r\n            return true;\r\n        }\r\n        debugger;\r\n        // error\r\n    }),\r\n    key(\"style\"),\r\n    node(\r\n        \"CSSStyleDeclaration\",\r\n        /*function ([token]: [Array<any>], env: ScanEnv, start: Position, end: Position) {\r\n            token.push(\r\n                useKey(\"cssText\", env.input.slice(start.offset + 1, end.offset - 1))\r\n            )\r\n        }*/\r\n        undefined, true\r\n    ),\r\n    \"{\", WRAP,\r\n    [\r\n        [\"}\", UNWRAP],\r\n        [MATCH_CSS_ATTRIBUTE]\r\n    ],\r\n];\r\nconst CSSMediaRule = [\r\n    MARK_AS_ROOT,\r\n    node(\"CSSMediaRule\"),\r\n    \"@media\", TEST_KEYWORD_BOUNDARY, WRAP,\r\n    key(\"media\"),\r\n    prev(function (token: Token) {\r\n        const value = token.value;\r\n        return value.length - value.match(/\\S|$/).index;\r\n    }, true),\r\n    key(\"cssRules\", NODE_LIST),\r\n    \"{\", WRAP,\r\n    FORK_IN_ROOT,\r\n    \"}\", UNWRAP_ALL\r\n];\r\nconst CSSKeyframesRule = [\r\n    node(\"CSSKeyframesRule\"),\r\n    \"@keyframes\", TEST_KEYWORD_BOUNDARY, WRAP,\r\n    key(\"name\"),\r\n    prev(function (token: any) {\r\n        if (token instanceof Token) {\r\n            return true;\r\n        }\r\n        debugger;\r\n    }),\r\n    key(\"cssRules\", NODE_LIST),\r\n    \"{\", WRAP,\r\n    [\r\n        [\"}\", UNWRAP_ALL],\r\n        [\r\n            node(\"CSSKeyframeRule\"),\r\n            \"{\", WRAP,\r\n            [\r\n                [\"}\", UNWRAP],\r\n                [MATCH_CSS_ATTRIBUTE]\r\n            ]\r\n        ]\r\n    ]\r\n];\r\nconst CSSFontFaceRule = [\r\n    node(\"CSSFontFaceRule\"),\r\n    \"@font-face\", TEST_KEYWORD_BOUNDARY, WRAP,\r\n    \"{\", WRAP,\r\n    [\r\n        [\"}\", UNWRAP_ALL],\r\n        [MATCH_CSS_ATTRIBUTE]\r\n    ]\r\n];\r\nconst CSSSupportsRule = [\r\n    MARK_AS_ROOT,\r\n    node(\"CSSSupportsRule\"),\r\n    pick(function (tokens: Array<any>) {\r\n        return [\r\n            useKey(\"conditionText\", tokens[1].value.trim()),\r\n            useKey(\"cssRules\", NODE_LIST(tokens[2]))\r\n        ];\r\n    }),\r\n    \"@supports\", TEST_KEYWORD_BOUNDARY, WRAP,\r\n    \"{\", WRAP,\r\n    FORK_IN_ROOT,\r\n    \"}\", UNWRAP_ALL\r\n];\r\n\r\n\r\n\r\nexport {\r\n    MATCH_CSS_ATTRIBUTE_VALUE,\r\n    MATCH_CSS_ATTRIBUTE\r\n}\r\n\r\nexport default <IPattern>[\r\n    [CLEAR_COMMENT],\r\n    [NO_COLLECT, [[\"\", MATCH_WHITE_SPACE_CHARACHER]]],\r\n    CSSSupportsRule,\r\n    CSSStyleRule,\r\n    CSSMediaRule,\r\n    CSSKeyframesRule,\r\n    CSSFontFaceRule\r\n];\r\n","\r\n\r\n\r\nexport {\r\n    Scanner, OPERATIONS, HOOK_MODE, IScanEnv,\r\n    IPattern, Token,\r\n    IPosition, ISourceLocation,\r\n    UseKey, unwrapTokens\r\n}\r\n\r\ntype IScanEnv = {\r\n    tokens: Array<any>,\r\n    input: string,\r\n    begin: number,\r\n    offset: number,\r\n    end: number,\r\n    line: number,\r\n    column: number,\r\n    useFold: boolean,\r\n    useEscape: boolean,\r\n    ignoreCase: boolean,\r\n    hookPoint: number, // 用于指定当前钩子方法目标 token 位置\r\n}\r\n\r\n\r\nconst enum HOOK_MODE {\r\n    RESOLVE = 0b1,\r\n    CAPTURE = 0b10,\r\n    PIPE = 0b100\r\n    //LEFT_ASSOCIATIVE = 0b101\r\n}\r\n\r\ninterface IPosition {\r\n    offset: number,\r\n    line: number,\r\n    column: number\r\n}\r\ninterface ISourceLocation {\r\n    start: IPosition,\r\n    end: IPosition\r\n}\r\n\r\n\r\ntype IPattern = Hook\r\n    | string\r\n    | String    // 用于在不占用 string 描述空间的基础上，清晰的定义一些操作指令\r\n    | Array<\r\n        string  //  单段字符串不需要在数组内也能简化的声明为一个分支\r\n        | Array<IPattern>    //  其他内容需要被数组包裹\r\n    > // Array 代表 Pattern 内的分支 Pattern\r\n\r\nabstract class Hook {\r\n    mode: HOOK_MODE = HOOK_MODE.RESOLVE;\r\n    abstract use(env: IScanEnv, start: IPosition, end: IPosition): any\r\n}\r\n\r\nclass Node extends Hook {\r\n    static NODE_MAP = {};\r\n    public Wrapper: any;\r\n    constructor(\r\n        public type: string,\r\n        public map?: (tokens: Array<any>, env: IScanEnv, start: IPosition, end: IPosition) => any,\r\n        private useContent?: boolean\r\n    ) {\r\n        super();\r\n        this.Wrapper = Node.NODE_MAP[type] || (\r\n            Node.NODE_MAP[type] = eval(\r\n                `(function ${type}(){this.type=\"${type}\";})`\r\n            )\r\n        );\r\n    }\r\n    use(env: IScanEnv, start: IPosition, end: IPosition) {\r\n\r\n        let { tokens, hookPoint } = env;\r\n\r\n        const node = new this.Wrapper();\r\n        node.loc = { start, end };\r\n        let addItem = function (item: UseKey) {\r\n            node[item.key] = item.value;\r\n        }\r\n        if (this.useContent) {\r\n            const content = node.content = [];\r\n            addItem = function (item: UseKey) {\r\n                content.push(item);\r\n            }\r\n        }\r\n        tokens = tokens.splice(hookPoint);\r\n        if (this.map) {\r\n            tokens = this.map(tokens, env, start, end) || tokens;\r\n        }\r\n        walk(tokens);\r\n        env.tokens.push(node);\r\n\r\n        function walk(token: any) {\r\n            if (token instanceof Array) {\r\n                token.forEach(walk);\r\n            } else if (token instanceof UseKey) {\r\n                addItem(token);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nclass UseKey {\r\n    constructor(public key: string, public value: any) { }\r\n}\r\n\r\nclass Key extends Hook {\r\n    static Wrapper = UseKey;\r\n    constructor(public key: string, public map?: (token: any, env: IScanEnv, start: IPosition, end: IPosition) => any) {\r\n        super();\r\n    }\r\n    use(env: IScanEnv, start: IPosition, end: IPosition) {\r\n        let { tokens, hookPoint } = env;\r\n        let token = tokens[hookPoint];\r\n        this.map && (token = this.map(token, env, start, end) || token);\r\n        tokens.splice(hookPoint, 1, new UseKey(this.key, token));\r\n    }\r\n}\r\n\r\nclass Merge extends Hook {\r\n    constructor(public map: (tokens: Array<any>, env: IScanEnv, start: IPosition, end: IPosition) => any) {\r\n        super();\r\n    }\r\n    use(env: IScanEnv, start: IPosition, end: IPosition) {\r\n        let { tokens, hookPoint } = env;\r\n\r\n        tokens.push(this.map(tokens.splice(hookPoint), env, start, end));\r\n    }\r\n}\r\n\r\nclass Prev extends Hook {\r\n    constructor(\r\n        public match?: (token: Token | any, env: IScanEnv) => number | boolean,\r\n        public onlyToken?: boolean\r\n    ) {\r\n        super();\r\n    }\r\n    use(env: IScanEnv) {\r\n\r\n        let { tokens, hookPoint } = env;\r\n        hookPoint -= 1;\r\n        let prev = tokens[hookPoint];\r\n        if (!this.onlyToken || prev instanceof Token) {\r\n            if (this.match) {\r\n                let res = this.match(prev, env);\r\n                if (res) {\r\n                    if (typeof res === \"number\" && res !== prev.value.length) {\r\n                        tokens.splice(\r\n                            hookPoint, 1,\r\n                            prev.slice(0, -res), prev.slice(-res)\r\n                        );\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            env.hookPoint -= 1;\r\n        }\r\n    }\r\n}\r\nclass Pipe extends Hook {\r\n    mode = HOOK_MODE.PIPE;\r\n    constructor(public pipe: (token: any, env: IScanEnv, start: IPosition, end: IPosition) => any) {\r\n        super();\r\n    }\r\n    use(env: IScanEnv, start: IPosition, end: IPosition) {\r\n        let { tokens, hookPoint } = env;\r\n        let res = this.pipe(tokens[hookPoint], env, start, end);\r\n        if (res !== undefined) {\r\n            tokens[hookPoint] = res;\r\n        } else {\r\n            tokens.splice(hookPoint, 1);\r\n        }\r\n    }\r\n}\r\nclass Pick extends Pipe {\r\n    mode = HOOK_MODE.RESOLVE;\r\n}\r\n\r\nclass Call extends Hook {\r\n    constructor(\r\n        public use: (env: IScanEnv, start: IPosition, end: IPosition) => any,\r\n        public mode: HOOK_MODE\r\n    ) {\r\n        super();\r\n    }\r\n}\r\nclass NoCapture extends Hook {\r\n    mode = HOOK_MODE.CAPTURE;\r\n    constructor() {\r\n        super()\r\n    }\r\n    use(env: IScanEnv, start: IPosition, end: IPosition) {\r\n        let { tokens, hookPoint } = env;\r\n        tokens.splice(hookPoint, 1);\r\n        if (start.offset < env.offset/*end.offset === env.offset*/) {\r\n            env.offset = start.offset;\r\n            env.line = start.line;\r\n            env.column = start.column;\r\n        }\r\n    }\r\n}\r\n\r\nnamespace OPERATIONS {\r\n    export const\r\n        FINISH = new String(\"FINISH\"),\r\n        WRAP = new String(\"WRAP\"),\r\n        UNWRAP = new String(\"UNWRAP\"),\r\n        UNWRAP_ALL = new String(\"UNWRAP_ALL\"),\r\n        OPTION = new String(\"OPTION\"),\r\n        SPLIT = new String(\"SPLIT\"),\r\n        NO_COLLECT = new String(\"NO_COLLECT\"),\r\n        NO_CAPTURE = new String(\"NO_CAPTURE\"),\r\n        MARK_AS_ROOT = new String(\"MARK_AS_ROOT\"),\r\n        FORK_IN_PARENT = new String(\"FORK_IN_PARENT\"),\r\n        FORK_IN_ROOT = new String(\"FORK_IN_ROOT\"),\r\n        END = new String(\"END\"),\r\n        END_ON_LEFT = new String(\"END_ON_LEFT\");\r\n\r\n    export const useKey = function (key: string | Token, value: any) {\r\n        return new UseKey(key.toString(), value);\r\n    }\r\n\r\n    export const\r\n        node = function (\r\n            val: string,\r\n            map?: (tokens: Array<any>, env: IScanEnv, start: IPosition, end: IPosition) => any,\r\n            useContent = false,\r\n            mode = HOOK_MODE.RESOLVE\r\n        ) {\r\n            const node = new Node(val, map, useContent);\r\n            node.mode = mode;\r\n            return node;\r\n        },\r\n        key = function (val: string, map?: (token: any, env: IScanEnv, start: IPosition, end: IPosition) => any) {\r\n            return new Key(val, map);\r\n        },\r\n        pick = function (map?: (token: any, env: IScanEnv, start: IPosition, end: IPosition) => any) {\r\n            return new Pick(map || function () { });\r\n        },\r\n        hook = function (fn: (env: IScanEnv, start: IPosition, end: IPosition) => void, mode = HOOK_MODE.RESOLVE) {\r\n            return new Call(fn, mode);\r\n        },\r\n        pipe = function (pipe?: (token: any, env: IScanEnv, start: IPosition, end: IPosition) => any) {\r\n            return new Pipe(pipe || function () { });\r\n        },\r\n        prev = function (match?: (token: Token | any, env: IScanEnv) => number | boolean, onlyToken?: boolean) {\r\n            return new Prev(match, onlyToken);\r\n        },\r\n        merge = function (\r\n            map: (tokens: Array<any>, env: IScanEnv, start: IPosition, end: IPosition) => any\r\n                = function (tokens) { return tokens; }\r\n        ) {\r\n            return new Merge(map);\r\n        };\r\n\r\n\r\n\r\n    export const\r\n        MATCH_BEGIN = \"\",\r\n        MATCH_END = \"\",\r\n        MATCH_EOF: IPattern = [[\"\", \"\"]],\r\n        MERGE_ALL_TOKENS = merge(\r\n            function (tokens: Array<Token>) {\r\n                return tokens.reduce((res, token) => res.concat(token));\r\n            }\r\n        ),\r\n        UNFOLD = hook(function (env) {\r\n            const { tokens, hookPoint } = env;\r\n            for (const item of tokens.splice(hookPoint)) {\r\n                if (item instanceof Array) {\r\n                    tokens.push(...item);\r\n                } else {\r\n                    tokens.push(item);\r\n                }\r\n            }\r\n        }, HOOK_MODE.RESOLVE);\r\n}\r\n\r\n\r\nnamespace MARKS {\r\n    export const\r\n        FINISH = OPERATIONS.FINISH,\r\n        END = OPERATIONS.END,\r\n        END_ON_LEFT = OPERATIONS.END_ON_LEFT,\r\n        UNWRAP = OPERATIONS.UNWRAP,\r\n        WRAP = OPERATIONS.WRAP,\r\n        ROOT = new String(\"ROOT\");\r\n\r\n\r\n    export const\r\n        RESOLVE = \"_RESOLVE_\",\r\n        TYPE = \"_TYPE_\",\r\n        ROLL = \"_ROLL_\",\r\n        PARENT = \"_PARENT_\",\r\n        COLLECT = \"_COLLECT_\",\r\n        BUBBING_HOOKS = \"_BUBBING_HOOKS_\",\r\n        CAPTURING_HOOKS = \"_CAPTURING_HOOKS_\",\r\n        SLICE_HOOKS = \"_SLICE_HOOKS_\",\r\n        IGNORE_TESTS = \"_IGNORE_TESTS_\";\r\n\r\n\r\n\r\n    export const RESOLVE_TYPE_SET: Set<String> = new Set([\r\n        OPERATIONS.FINISH,\r\n        OPERATIONS.END,\r\n        OPERATIONS.END_ON_LEFT,\r\n        OPERATIONS.UNWRAP,\r\n        OPERATIONS.UNWRAP_ALL,\r\n        OPERATIONS.WRAP,\r\n        ROOT    // 只是个占位\r\n    ]);\r\n}\r\n\r\nenum SCOPE {\r\n    NODE, START, CURSOR, BACK_POINT, USE_FOLD\r\n}\r\n\r\ninterface IScope {\r\n    [SCOPE.NODE]: any,\r\n    [SCOPE.START]: IPosition,\r\n    [SCOPE.CURSOR]: IPosition,\r\n    [SCOPE.BACK_POINT]: number,\r\n    [SCOPE.USE_FOLD]: boolean\r\n}\r\n\r\ntype ISlices = Array<[IPosition, Hook[]]>;\r\n\r\ntype IResolveState = [any, IPosition, ISlices, number];\r\n\r\n\r\nclass Scanner {\r\n\r\n    private scanTree: Record<string, any>;\r\n    public useEscape = false;\r\n    public useFold = true;\r\n    public ignoreCase = false;\r\n    constructor(\r\n        pattern: IPattern,\r\n        configure?: { useEscape?: boolean, useFold?: boolean, ignoreCase?: boolean }\r\n    ) {\r\n        this.scanTree = build(pattern);\r\n        configure && Object.assign(this, configure);\r\n    }\r\n\r\n    scan(options: IScanEnv | string) {\r\n        let env = typeof options === \"string\" ? {\r\n            tokens: [],\r\n            input: options,\r\n            begin: 0,\r\n            offset: 0,\r\n            end: options.length,\r\n            line: 1,\r\n            column: 1,\r\n            useFold: this.useFold,\r\n            useEscape: this.useEscape,\r\n            ignoreCase: this.ignoreCase,\r\n            hookPoint: 0\r\n        } : options;\r\n\r\n        let matchPool: Array<[any, ISlices]> = [];\r\n        let scopeStack: Array<IScope> = [[\r\n            this.scanTree,\r\n            getPosition(), getPosition(),\r\n            0, false\r\n        ]];\r\n        let resolveState: IResolveState;\r\n        let hasEscape = 0;\r\n        let isBegin = true;\r\n\r\n\r\n        let cpos: IPosition;\r\n        while (true) {\r\n\r\n            if (!hasEscape) {\r\n                // 如果启用 useEscape 模式，字符捕获焦点从可能的 \\ 号开始\r\n                cpos = getPosition();\r\n            }\r\n\r\n            let char: string;\r\n\r\n            if (!isBegin) {\r\n\r\n                if (env.offset >= env.end) {\r\n\r\n                    // 首个匹配符为 \"\" 则代表匹配每一轮的开始\r\n                    // 当前面存在匹配符，后面出现的单独的 \"\" 匹配符则代表匹配输入内容的结束\r\n                    // 如果仅匹配输入内容的结束，可以这样描述 : [\"\",\"\"]\r\n\r\n                    if (\r\n                        scopeStack[0][SCOPE.CURSOR].offset < cpos.offset\r\n                    ) {// 匹配扫描过程已结束\r\n                        if (match(\"\") || resolve()) {\r\n                            return env;\r\n                        }\r\n                        if (env.offset < env.end) {\r\n                            break;\r\n                        }\r\n                        matchPool.length = 0;\r\n                        match(\"\");\r\n                    }\r\n                    if (matchPool.length) {\r\n                        const state = resolveState;\r\n                        match(\"\", true);\r\n                        // 仅匹配 OPERATIONS.MATCH_EOF 的 [\"\",\"\"] \r\n                        // 排除 OPERATIONS.MATCH_BEGIN OPERATIONS.MATCH_END 的 \"\"\r\n                        if (state !== resolveState && resolve()) {\r\n                            return env;\r\n                        }\r\n                    }\r\n                    if (scopeStack[0][SCOPE.CURSOR].offset < cpos.offset) {\r\n                        collect(scopeStack[0][SCOPE.CURSOR], cpos, null);\r\n                    }\r\n                    break;\r\n                }\r\n\r\n                char = env.input[env.offset];\r\n                env.offset += 1;\r\n\r\n                switch (char) {\r\n                    case \"\\r\":\r\n                        if (env.input[env.offset] !== \"\\n\") {\r\n                            //env.column = 0;\r\n                            break;\r\n                        }\r\n                        // 将 \\r\\n 归类为 \\n 处理\r\n                        char = \"\\n\";\r\n                        env.offset += 1;\r\n                    case \"\\n\":\r\n                        env.line += 1;\r\n                        env.column = 0;\r\n                        break;\r\n                }\r\n                env.column += 1;\r\n                env.ignoreCase && (char = char.toLowerCase());\r\n\r\n                if (env.useEscape) {\r\n                    if (char === \"\\\\\") {\r\n                        hasEscape ^= 1;\r\n                        if (hasEscape) {\r\n                            continue;\r\n                        }\r\n                    } else if (hasEscape) {\r\n                        hasEscape = 0;\r\n                        char = \"\\\\\" + char;\r\n                    }\r\n                }\r\n            } else {\r\n                char = \"\";\r\n                isBegin = false;\r\n            }\r\n            if (match(char)) {\r\n                return env;\r\n            }\r\n        }\r\n\r\n        return env;\r\n\r\n\r\n        function getPosition(): IPosition {\r\n            return { offset: env.offset, line: env.line, column: env.column }\r\n        }\r\n\r\n        function match(key: string, noResolve?: boolean) {\r\n            const pool = matchPool;\r\n\r\n            matchPool = [];\r\n\r\n            let node: any;\r\n            let slices: ISlices;\r\n            let hasBranch: boolean;\r\n\r\n            while (true) {\r\n                if (pool.length) {\r\n                    [node, slices] = pool.shift();\r\n                } else if (!resolveState && node !== scopeStack[0][SCOPE.NODE]) {\r\n                    node = scopeStack[0][SCOPE.NODE];\r\n                    slices = null;\r\n                } else {\r\n                    break;\r\n                }\r\n                hasBranch = false;\r\n\r\n                resolveState = walk(node, slices)\r\n                    || node[MARKS.ROLL] && walk(node[MARKS.ROLL], slices)\r\n                    || resolveState;\r\n            }\r\n\r\n\r\n            if (!noResolve && matchPool.length === 0 && resolve()) {\r\n                return true;\r\n            }\r\n\r\n            function walk(parent: any, slices?: ISlices): IResolveState {\r\n                let node = parent[key];\r\n                if (!node) {\r\n                    return;\r\n                }\r\n                if (!slices) {\r\n                    slices = [[cpos, parent[MARKS.CAPTURING_HOOKS]]];\r\n                } else if (hasBranch) {\r\n                    slices = slices.slice();\r\n                }\r\n                hasBranch = true;\r\n\r\n                matchPool.push([node, slices]);\r\n                if (node[MARKS.CAPTURING_HOOKS]) {\r\n                    slices.push([getPosition(), node[MARKS.CAPTURING_HOOKS]]);\r\n                }\r\n\r\n                if (!node[MARKS.RESOLVE]) {\r\n                    return;\r\n                } else {\r\n                    node = node[MARKS.RESOLVE];\r\n                }\r\n                return [node, getPosition(), slices, scopeStack.length];\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        function resolve() {\r\n            if (!resolveState) {\r\n                return;\r\n            }\r\n\r\n            const [node, { offset, line, column }, splits, stackSize] = resolveState;\r\n            scopeStack.splice(0, scopeStack.length - stackSize);\r\n            env.offset = offset;\r\n            env.line = line;\r\n            env.column = column;\r\n\r\n            let backSteps = finallize(node, splits, true);\r\n            if (backSteps > 0) {\r\n                return true;\r\n            }\r\n\r\n            if (backSteps < 0) {\r\n                do {\r\n                    const scope = scopeStack.shift();\r\n                    let tokens = env.tokens;\r\n                    if (scope[SCOPE.USE_FOLD]) {\r\n                        (env.tokens = tokens.shift()).pop();\r\n                    } else {\r\n                        tokens.length = scope[SCOPE.BACK_POINT];\r\n                    }\r\n                } while (++backSteps < 0)\r\n            }\r\n            //rollback(res);\r\n            resolveState = null;\r\n            isBegin = true;\r\n        }\r\n\r\n        function finallize(node: any, slices: ISlices, use_collect?: boolean): number {\r\n\r\n            let type = node[MARKS.TYPE];\r\n\r\n            const scope = scopeStack[0];\r\n            const startPos = slices[0][0];\r\n            let len = env.tokens.length;\r\n\r\n            if (use_collect) {\r\n\r\n                let hooks: Array<Hook>;\r\n                let sliceHooks = node[MARKS.SLICE_HOOKS];\r\n                if (sliceHooks) {\r\n                    hooks = slices[0][1];\r\n                    hooks && (hooks = hooks.filter(item => sliceHooks.has(item)));\r\n                }\r\n                collect(scope[SCOPE.CURSOR], startPos, hooks);\r\n            }\r\n\r\n            if (type === MARKS.WRAP) {\r\n                return wrap(node, slices, use_collect);\r\n            }\r\n\r\n            const hookPoint = env.tokens.length;\r\n\r\n            if (use_collect && type !== MARKS.END_ON_LEFT) {\r\n                let res = collectSlices(slices, node[MARKS.SLICE_HOOKS]);\r\n                if (res < 0) {\r\n                    env.tokens.length = len;\r\n                    return res + 1;\r\n                }\r\n            }\r\n            env.hookPoint = hookPoint;\r\n\r\n            if (type === MARKS.UNWRAP) {\r\n                return unwrap(node, slices);\r\n            } else {\r\n                let res = useHook(node[MARKS.BUBBING_HOOKS], startPos, getPosition());\r\n                if (res < 0) {\r\n                    env.tokens.length = len;\r\n                    return res + 1;\r\n                }\r\n                if (type !== MARKS.END_ON_LEFT) {\r\n                    scope[SCOPE.CURSOR] = getPosition();\r\n                } else {\r\n                    env.offset = startPos.offset;\r\n                    env.line = startPos.line;\r\n                    env.column = startPos.column;\r\n                    scope[SCOPE.CURSOR] = startPos;\r\n                    return 1;\r\n                }\r\n                return type !== MARKS.END ? res : 1;\r\n            }\r\n\r\n        }\r\n\r\n\r\n        function wrap(node: any, slices: ISlices, use_collect?: boolean) {\r\n            const { useFold, tokens } = env;\r\n            const backPoint = tokens.length;\r\n            let startPos = slices[0][0];\r\n\r\n            scopeStack.unshift([\r\n                node,\r\n                startPos, getPosition(),\r\n                backPoint, useFold\r\n            ]);\r\n\r\n            if (useFold) {\r\n                env.tokens = [tokens];\r\n                env.hookPoint = 1;\r\n            }\r\n\r\n\r\n            let backSteps = use_collect ? collectSlices(\r\n                slices,\r\n                node[MARKS.SLICE_HOOKS]\r\n            ) : 0;\r\n\r\n            if (backSteps >= 0) {\r\n                backSteps = useHook(node[MARKS.BUBBING_HOOKS], startPos, getPosition());\r\n                if (backSteps >= 0) {\r\n                    node = node[MARKS.RESOLVE];\r\n                    return node ? finallize(node, slices, false) : backSteps;\r\n                }\r\n            }\r\n            return backSteps;\r\n        }\r\n\r\n\r\n        function unwrap(node: any, slices: ISlices) {\r\n\r\n            const scope = scopeStack.shift();\r\n\r\n            if (scope[SCOPE.USE_FOLD]) {\r\n                let tokens = env.tokens.shift()\r\n                env.hookPoint = tokens.length;\r\n                tokens.push(env.tokens);\r\n                env.tokens = tokens;\r\n            }\r\n\r\n            let backSteps = useHook(\r\n                node[MARKS.BUBBING_HOOKS],\r\n                scope[SCOPE.START],\r\n                getPosition()\r\n            );\r\n            if (backSteps >= 0) {\r\n                node = node[MARKS.RESOLVE];\r\n\r\n                scopeStack[0][SCOPE.CURSOR] = getPosition();\r\n                if (node) {\r\n                    backSteps = finallize(node, slices, false);\r\n                    if (backSteps >= 0) {\r\n                        return backSteps;\r\n                    }\r\n                } else {\r\n                    return backSteps;\r\n                }\r\n            }\r\n            scopeStack.unshift(scope);\r\n            if (scope[SCOPE.USE_FOLD]) {\r\n                let tokens = env.tokens.pop();\r\n\r\n                tokens.unshift(env.tokens);\r\n                env.tokens = tokens;\r\n            }\r\n            return backSteps + 1;\r\n        }\r\n\r\n        function useHook(hooks: Array<Hook>, start: IPosition, end: IPosition): number {\r\n            for (const hook of hooks) {\r\n                let res = hook.use(env, start, end);\r\n                if (res < 0) {\r\n                    return res;\r\n                }\r\n            }\r\n            return 0;\r\n        }\r\n\r\n        function collect(start: IPosition, end: IPosition, hooks: Array<Hook>) {\r\n            let res: any = 0;\r\n            if (start.offset < end.offset) {\r\n                let { tokens } = env;\r\n                env.hookPoint = tokens.length;\r\n                tokens.push(\r\n                    new Token(\r\n                        env.input.slice(start.offset, end.offset),\r\n                        start,\r\n                        end\r\n                    )\r\n                );\r\n                if (hooks) {\r\n                    res = useHook(hooks, start, end);\r\n                }\r\n            }\r\n            return res;\r\n        }\r\n\r\n        function collectSlices(\r\n            slices: ISlices,\r\n            sliceHooks: Set<Hook>\r\n        ) {\r\n            let cursor = slices[0][0];\r\n            if (sliceHooks) {\r\n                for (let i = 1; i < slices.length; i += 1) {\r\n                    let [next, hooks] = slices[i];\r\n                    hooks = hooks.filter(item => sliceHooks.has(item));\r\n                    if (hooks.length) {\r\n                        const res = collect(cursor, next, hooks);\r\n                        if (res < 0) {\r\n                            return res;\r\n                        }\r\n                        cursor = next;\r\n                    }\r\n                }\r\n            }\r\n            return collect(cursor, getPosition(), null);\r\n        }\r\n    }\r\n}\r\n\r\n\r\nclass Token {\r\n\r\n    loc: ISourceLocation;\r\n\r\n    constructor(public value: string, start: IPosition, end: IPosition) {\r\n        this.loc = { start, end };\r\n    }\r\n    trim() {\r\n        const found = this.value.match(/^\\s*|\\s*$/gm);\r\n        return this.slice(found[0].length, this.value.length - found[1].length);\r\n    }\r\n    concat(token: Token) {\r\n        return new Token(this.value + token.value, this.loc.start, token.loc.end);\r\n    }\r\n    slice(beginIndex: number, endIndex = this.value.length) {\r\n        let { value, loc: { start, end } } = this;\r\n        let { offset, line, column } = start;\r\n        let index = 0;\r\n\r\n        if (endIndex < 0) {\r\n            endIndex = value.length + endIndex;\r\n        }\r\n        if (beginIndex < 0) {\r\n            beginIndex = value.length + beginIndex;\r\n        }\r\n        if (beginIndex > endIndex) {\r\n            endIndex = beginIndex;\r\n        }\r\n        const range = [beginIndex, endIndex].map(\r\n            function (limit): IPosition {\r\n                if (limit === 0) {\r\n                    return start;\r\n                }\r\n                if (limit === value.length) {\r\n                    return end;\r\n                }\r\n                while (index < limit) {\r\n                    if (value[index] === \"\\n\") {\r\n                        line += 1;\r\n                        column = 1;\r\n                    } else {\r\n                        column += 1;\r\n                    }\r\n                    index += 1;\r\n                }\r\n                return { offset: offset + limit, line, column }\r\n            }\r\n        )\r\n        return new Token(value.slice(beginIndex, endIndex), range[0], range[1]);\r\n    }\r\n    toString() {\r\n        return this.value;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\ntype HookStack = Array<Hook | HookStack | RootStack>;\r\ntype HookList = Array<Hook>;\r\n\r\nclass RootStack extends Array<Hook | HookStack> { }\r\n\r\ntype BubbleTable = Array<HookStack>;\r\ntype CaptureTable = Array<HookList>;\r\ntype BuildResult = [Array<any>, BubbleTable, CaptureTable];\r\n\r\nfunction build(pattern: IPattern): Record<string, any> {\r\n    const matchTree = { [MARKS.TYPE]: MARKS.ROOT };\r\n    const [nodes, bubbling_map, capturing_map] = buildRule(\r\n        [pattern],\r\n        [matchTree],\r\n        [[new RootStack()]],\r\n        [[]],\r\n        [matchTree]\r\n    );\r\n    for (let i = 0; i < nodes.length; i += 1) {\r\n        // 被省去 MARKS.FINISH 的描述自动补全\r\n        const node = nodes[i];\r\n        if (!MARKS.RESOLVE_TYPE_SET.has(node[MARKS.TYPE])) {\r\n            buildKey(MARKS.FINISH, [node], [bubbling_map[i]], [capturing_map[i]]);\r\n        }\r\n    }\r\n    return matchTree;\r\n}\r\n\r\n\r\nfunction buildRule(\r\n    patterns: Array<IPattern>,\r\n    nodes: Array<any>,\r\n    bubbleTable: BubbleTable,\r\n    captureTable: CaptureTable,\r\n    scopeChain: Array<any>\r\n): BuildResult {\r\n\r\n    const rsRule: Array<IPattern> = [];\r\n    let index = 0;\r\n    let key: IPattern;\r\n    while (index < patterns.length) {\r\n        let ndepth = 0, begin = index;\r\n        const forkChain: Array<number | String> = [];\r\n\r\n        while (true) {\r\n            if (patterns[index] === OPERATIONS.FORK_IN_ROOT) {\r\n                if (ndepth) {\r\n                    forkChain.push(ndepth);\r\n                    ndepth = 0;\r\n                }\r\n                forkChain.push(OPERATIONS.FORK_IN_ROOT);\r\n            } else if (patterns[index] === OPERATIONS.FORK_IN_PARENT) {\r\n                ndepth += 1;\r\n            } else {\r\n                break;\r\n            }\r\n            index += 1;\r\n        }\r\n\r\n        if (index !== begin) {\r\n            ndepth && forkChain.push(ndepth);\r\n\r\n            for (let node of nodes) {\r\n                let parent: any = node;\r\n                let cursor = 0;\r\n                for (let d of forkChain) {\r\n                    if (d === OPERATIONS.FORK_IN_ROOT) {\r\n                        parent = scopeChain[cursor++];\r\n                    } else {\r\n                        do {\r\n                            parent = parent[MARKS.PARENT];\r\n                            if (parent === scopeChain[cursor]) {\r\n                                cursor += 1;\r\n                            }\r\n                        } while (--(<number>d) >= 0)\r\n                    }\r\n                }\r\n                if (node[MARKS.ROLL] !== parent) {\r\n                    if (node[MARKS.ROLL]) {\r\n                        debugger;   // 暂不支持一个匹配路径存在多个 FORK 匹配（用不到）\r\n                    }\r\n                    node[MARKS.ROLL] = parent;\r\n                }\r\n            }\r\n            continue;\r\n        }\r\n\r\n        switch (key = patterns[index]) {\r\n            case OPERATIONS.NO_CAPTURE:\r\n            case OPERATIONS.NO_COLLECT:\r\n                rsRule.push(key);\r\n            case OPERATIONS.SPLIT:\r\n                setHook(null);\r\n                break;\r\n\r\n            case OPERATIONS.OPTION:\r\n                return walk(\r\n                    [\r\n                        rsRule.concat(patterns.slice(index + 1)),\r\n                        rsRule.concat(patterns.slice(index + 2))\r\n                    ],\r\n                    function (pattern) {\r\n                        return buildRule(\r\n                            pattern,\r\n                            nodes,\r\n                            bubbleTable.map(hooks => hooks.slice()),\r\n                            captureTable.map(maps => maps.slice()),\r\n                            scopeChain\r\n                        )\r\n                    }\r\n                );\r\n\r\n            case OPERATIONS.MARK_AS_ROOT:\r\n                patterns = rsRule.concat(patterns.slice(index + 1));\r\n                return walk(nodes, function (node, index) {\r\n                    const bubbleHooks = bubbleTable[index];\r\n                    return buildRule(\r\n                        patterns,\r\n                        [node],\r\n                        [[new RootStack(...<HookStack>bubbleHooks[0])].concat(bubbleHooks.slice(1))],\r\n                        [captureTable[index]],\r\n                        [node].concat(scopeChain)\r\n                    )\r\n                });\r\n            default:\r\n                if (key instanceof Hook) {\r\n                    setHook(key);\r\n                } else {\r\n                    if (key instanceof Array) {\r\n                        [nodes, bubbleTable, captureTable] = walk(key, function (item) {\r\n                            return (item instanceof Array ? buildRule : buildKey)(\r\n                                item, nodes,\r\n                                bubbleTable.map(hooks => hooks.slice()),\r\n                                captureTable.map(maps => maps.slice()),\r\n                                scopeChain\r\n                            )\r\n                        })\r\n                    } else {\r\n                        [nodes, bubbleTable, captureTable] = buildKey(key, nodes, bubbleTable, captureTable);\r\n                    }\r\n                    while (rsRule.length) {\r\n                        setHook(\r\n                            rsRule.shift() === OPERATIONS.NO_COLLECT\r\n                                ? OPERATIONS.pipe()\r\n                                : new NoCapture()\r\n                        );\r\n                    }\r\n                }\r\n                break;\r\n        }\r\n\r\n        index += 1;\r\n    }\r\n\r\n    return [nodes, bubbleTable, captureTable];\r\n\r\n\r\n    function walk(\r\n        list: Array<any>,\r\n        next: (item: any, index: number) => BuildResult\r\n    ): BuildResult {\r\n\r\n        let newNodes: Array<any> = [];\r\n        let newBubbleTable: Array<HookStack> = [];\r\n        let newCaptureTable: Array<any[]> = [];\r\n\r\n        for (let i = 0; i < list.length; i += 1) {\r\n            const res = next(list[i], i);\r\n            newNodes = newNodes.concat(res[0]);\r\n            newBubbleTable = newBubbleTable.concat(res[1]);\r\n            newCaptureTable = newCaptureTable.concat(res[2]);\r\n        }\r\n\r\n\r\n        return [newNodes, newBubbleTable, newCaptureTable];\r\n\r\n    }\r\n    function setHook(hook: Hook) {\r\n        if (hook === window.test) {\r\n            debugger;\r\n        }\r\n        if (!hook) {\r\n            hook = new Call(function () { }, HOOK_MODE.CAPTURE);\r\n            for (let i = 0; i < nodes.length; i += 1) {\r\n                MARKS.RESOLVE_TYPE_SET.has(nodes[i][MARKS.TYPE]) || addHook(i);\r\n            }\r\n            return;\r\n        }\r\n        switch (hook.mode) {\r\n            case HOOK_MODE.RESOLVE:\r\n                bubbleTable.forEach(hooks => hooks.push(<Hook>key));\r\n                break;\r\n            case HOOK_MODE.PIPE:\r\n            case HOOK_MODE.CAPTURE:\r\n                for (let i = 0; i < nodes.length; i += 1) {\r\n                    addHook(i);\r\n                }\r\n                break;\r\n        }\r\n        function addHook(index: number) {\r\n            const node = nodes[index];\r\n            const type = node[MARKS.TYPE];\r\n            if (hook.mode !== HOOK_MODE.PIPE && MARKS.RESOLVE_TYPE_SET.has(type)) {\r\n                node[MARKS.BUBBING_HOOKS].push(hook);\r\n            } else {\r\n                (\r\n                    node[MARKS.CAPTURING_HOOKS]\r\n                    || (node[MARKS.CAPTURING_HOOKS] = [])\r\n                ).push(hook);\r\n                captureTable[index].push(hook);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\nfunction buildKey(\r\n    key: any,\r\n    nodes: Array<any>,\r\n    bubbleTable: BubbleTable,\r\n    captureTable: CaptureTable,\r\n    scopeChain?: Array<any>\r\n): BuildResult {\r\n    if (typeof key === \"string\") {\r\n        if (/^[\\s\\S]?$/.test(key)) {\r\n            key = [key];\r\n        }\r\n        for (let i = 0; i < key.length; i += 1) {\r\n            nodes = nodes.map(function (node) {\r\n                return node[key[i]] || (node[key[i]] = { [MARKS.PARENT]: node });\r\n            });\r\n        }\r\n    } else if (MARKS.RESOLVE_TYPE_SET.has(key)) {\r\n\r\n        nodes = nodes.map(function (node, i) {\r\n\r\n            let bubbleHooks: HookStack = bubbleTable[i];\r\n            let captureHooks = captureTable[i];\r\n            captureTable[i] = [];\r\n\r\n            if (key === OPERATIONS.UNWRAP_ALL) {\r\n                key = OPERATIONS.UNWRAP;\r\n                if (!(bubbleHooks[0] instanceof RootStack)) {\r\n                    if (bubbleHooks.length > 1) {\r\n                        bubbleHooks[0] = (<HookStack>bubbleHooks[0]).concat(bubbleHooks.slice(1));\r\n                    }\r\n                    do {\r\n                        bubbleTable[i] = [bubbleHooks[0][0]];\r\n                        bubbleHooks = <HookStack>bubbleHooks[0];\r\n\r\n                        node = getResolveNode(node, key, bubbleHooks, captureHooks);\r\n                    } while (!(bubbleHooks[0] instanceof RootStack))\r\n                }\r\n            } else {\r\n                if (key === OPERATIONS.UNWRAP) {\r\n                    bubbleTable[i] = [bubbleHooks[0][0]];\r\n                    bubbleHooks = (<HookStack>bubbleHooks[0]).concat(bubbleHooks.slice(1));\r\n                } else if (key === OPERATIONS.WRAP) {\r\n                    bubbleTable[i] = [bubbleHooks];\r\n                    bubbleHooks = [];\r\n                } else {\r\n                    bubbleTable[i] = [bubbleHooks[0]];\r\n                }\r\n\r\n                node = getResolveNode(node, key, bubbleHooks, captureHooks);\r\n\r\n            }\r\n            return node;\r\n        });\r\n\r\n    } else {\r\n        debugger;\r\n    }\r\n    return [nodes, bubbleTable, captureTable];\r\n\r\n    function getResolveNode(\r\n        node: any, type: string,\r\n        bubbleHooks: HookStack, sliceHooks: HookList\r\n    ) {\r\n        if (node[MARKS.RESOLVE]) {\r\n            // 如果存在重复定义的 pattern 则这里会执行\r\n            debugger;\r\n        }\r\n        return node[MARKS.RESOLVE] = {\r\n            [MARKS.PARENT]: node,\r\n            [MARKS.TYPE]: type,\r\n            [MARKS.SLICE_HOOKS]: sliceHooks.length\r\n                ? new Set(sliceHooks.splice(0))\r\n                : null,\r\n            [MARKS.BUBBING_HOOKS]: bubbleHooks.slice(1).reverse()\r\n        };\r\n    }\r\n\r\n}\r\n\r\nfunction unwrapTokens(tokens: any) {\r\n    if (tokens instanceof Token) {\r\n        return tokens.value;\r\n    }\r\n    if (tokens instanceof Array) {\r\n        return tokens.map(unwrapTokens);\r\n    }\r\n    return tokens;\r\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import {\r\n    Scanner, OPERATIONS, HOOK_MODE, IScanEnv,\r\n    IPattern, Token,\r\n    IPosition, ISourceLocation,\r\n} from \"./scanner\"\r\n\r\n\r\nconst {\r\n    FINISH,\r\n    WRAP, UNWRAP, UNWRAP_ALL,\r\n    OPTION,\r\n    SPLIT,\r\n    NO_COLLECT, NO_CAPTURE,\r\n    MARK_AS_ROOT, FORK_IN_PARENT, FORK_IN_ROOT,\r\n    END, END_ON_LEFT,\r\n    useKey,\r\n    node, key, pick, hook, pipe, prev, merge,\r\n\r\n    MATCH_BEGIN,\r\n    MATCH_END,\r\n    MATCH_EOF,\r\n    MERGE_ALL_TOKENS\r\n} = OPERATIONS;\r\n\r\nimport CSSGrammar from \"./css-grammar\";\r\n\r\n\r\nconst SELF_CLOSING_TAGS = [\r\n    \"area\",\r\n    \"base\",\r\n    \"br\",\r\n    \"col\",\r\n    \"embed\",\r\n    \"hr\",\r\n    \"img\",\r\n    \"input\",\r\n    \"link\",\r\n    \"meta\",\r\n    \"param\",\r\n    \"source\",\r\n    \"track\",\r\n    \"wbr\",\r\n    \"command\",\r\n    \"keygen\",\r\n    \"menuitem\"\r\n];\r\n\r\nconst MATCH_WHITE_SPACE_CHARACHER: IPattern = [` `, `\\n`, `\\t`];\r\nconst CLEAR_WHITE_SPACE_CHARACHER: IPattern = [\r\n    [NO_COLLECT, MATCH_WHITE_SPACE_CHARACHER]\r\n];\r\n\r\nconst MATCH_ATTRIBUTES: IPattern = [\r\n    [CLEAR_WHITE_SPACE_CHARACHER],\r\n    [\"=\"],\r\n    [`\"`, WRAP, `\"`, UNWRAP],\r\n    [`'`, WRAP, `'`, UNWRAP],\r\n];\r\n\r\n\r\n\r\n\r\nconst MATCH_TAG_END: IPattern = [\r\n    [\r\n        hook(function ({ tokens }) {\r\n            if (tokens[0][2].value !== tokens[tokens.length - 1][1].value) {\r\n                return -2;\r\n            }\r\n        }, HOOK_MODE.RESOLVE),\r\n        \"</\", WRAP,\r\n        [\r\n            [MATCH_WHITE_SPACE_CHARACHER],\r\n            [\">\", UNWRAP_ALL]\r\n        ]\r\n\r\n    ]\r\n];\r\n\r\n\r\nconst THROW_TOKEN_ERROR = hook(function (env, start, end) {\r\n    console.log(\"Invalid or unexpected token\", start, end);\r\n}, HOOK_MODE.RESOLVE);\r\n\r\nconst MATCH_SCRIPT_TEXT: IPattern = [\r\n    [\r\n        `\"`, WRAP,\r\n        [\r\n            [THROW_TOKEN_ERROR, `\\n`],\r\n            [`\"`, UNWRAP]\r\n        ]\r\n\r\n    ],\r\n    [\r\n        `'`, WRAP,\r\n        [\r\n            [THROW_TOKEN_ERROR, `\\n`],\r\n            [`'`, UNWRAP]\r\n        ]\r\n\r\n    ],\r\n    [\"//\", WRAP, [\"\\n\", [OPERATIONS.MATCH_EOF]], UNWRAP],\r\n    [\"/*\", WRAP, [\"*/\", [OPERATIONS.MATCH_EOF]], UNWRAP],\r\n    [\r\n        MARK_AS_ROOT,\r\n        `\\``, WRAP,\r\n        [\r\n            [\r\n                `$`,\r\n                `{`, WRAP,\r\n                FORK_IN_ROOT,\r\n                `}`, UNWRAP\r\n            ],\r\n            [`\\``, UNWRAP]\r\n        ]\r\n    ],\r\n];\r\n\r\nconst MATCH_SCRIPT_END: IPattern = [\r\n    [\r\n        hook(function (env) {\r\n            env.useEscape = true;\r\n            env.ignoreCase = false;\r\n        }, HOOK_MODE.CAPTURE/*HOOK_MODE.LEFT_ASSOCIATIVE*/),\r\n        MATCH_SCRIPT_TEXT\r\n    ],\r\n    [\r\n        hook(function (env) {\r\n            env.useEscape = false;\r\n            env.ignoreCase = true;\r\n        }, HOOK_MODE.RESOLVE),\r\n        MATCH_TAG_END,\r\n    ]\r\n];\r\n\r\nconst CSSScanner = new Scanner(\r\n    [\r\n        [CSSGrammar],\r\n        [\r\n            hook(function (env) {\r\n                env.end = env.offset;\r\n            }, HOOK_MODE.RESOLVE),\r\n            MATCH_TAG_END\r\n        ]\r\n    ],\r\n    { useEscape: true }\r\n);\r\n\r\nconst MATCH_STYLE_END: IPattern = [\r\n\r\n    [// 使用内联 JS 编译\r\n        hook(function (env) {\r\n            const end = env.end;\r\n            env.useEscape = true;\r\n            env.ignoreCase = false;\r\n\r\n            CSSScanner.scan(env);\r\n\r\n            env.end = end;\r\n        }, HOOK_MODE.CAPTURE),\r\n\r\n        hook(function (env) {\r\n            env.useEscape = false;\r\n            env.ignoreCase = true;\r\n        }, HOOK_MODE.RESOLVE),\r\n        \"\", UNWRAP_ALL,\r\n    ]\r\n\r\n    /*\r\n    // 内联整个 CSS Pattern 编译消耗很大\r\n    [MARK_AS_ROOT, CSSGrammar],\r\n    [\r\n        hook(function (env) {\r\n            env.useEscape = true;\r\n            env.ignoreCase = false;\r\n        }, HOOK_MODE.CAPTURE),\r\n        hook(function (env) {\r\n            env.useEscape = false;\r\n            env.ignoreCase = true;\r\n        }, HOOK_MODE.RESOLVE),\r\n        MATCH_TAG_END,\r\n    ]\r\n    */\r\n];\r\n\r\nconst TextNode = node(\"Text\").Wrapper;\r\n\r\n\r\nexport {\r\n    formatTokens,\r\n    SELF_CLOSING_TAGS\r\n};\r\nexport default <IPattern>[\r\n    [\r\n        node(\"DocumentType\"),\r\n        pick(function (tokens: Array<any>) {\r\n            tokens[1] = useKey(\"name\", tokens[1].value);\r\n            return tokens;\r\n        }),\r\n        \"<!doctype\", WRAP,\r\n        [\r\n            [CLEAR_WHITE_SPACE_CHARACHER],\r\n            [\">\", UNWRAP]\r\n        ],\r\n    ],\r\n    [\r\n        node(\"Comment\"),\r\n        key(\"data\", function (tokens) {\r\n            return tokens[1].value;\r\n        }),\r\n        \"<!--\", WRAP, \"-->\", UNWRAP\r\n    ],\r\n    [\r\n        MARK_AS_ROOT,\r\n        node(\"HTMLElement\"),\r\n        pick(collectChildNodes),\r\n        pick(collectAttrs),\r\n        pick(collectTagName),\r\n        \"<\", WRAP,\r\n        [\r\n            [MATCH_ATTRIBUTES],\r\n            [\"/>\", UNWRAP],\r\n            [\r\n                \">\", WRAP,\r\n                [\r\n                    [FORK_IN_ROOT],\r\n                    [MATCH_TAG_END]\r\n                ]\r\n            ]\r\n        ],\r\n    ],\r\n    matchCustomTag(\"script\", MATCH_SCRIPT_END),\r\n    matchCustomTag(\"style\", MATCH_STYLE_END),\r\n    matchCustomTag(\"textarea\", MATCH_TAG_END),\r\n    matchSelfClosingTag(SELF_CLOSING_TAGS),\r\n]\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction matchSelfClosingTag(tagName: IPattern) {\r\n    return [\r\n        node(\"HTMLElement\"),\r\n        pick(collectChildNodes),\r\n        pick(collectAttrs),\r\n        pick(collectTagName),\r\n        \"<\", SPLIT,\r\n        tagName,\r\n        SPLIT,\r\n        [\r\n            [\r\n                [\"/>\", \">\"],\r\n                hook(function (env) {//使折叠次数一致\r\n                    const { tokens, hookPoint } = env;\r\n                    tokens.push(tokens.splice(hookPoint));\r\n                }, HOOK_MODE.RESOLVE),\r\n                FINISH,\r\n            ],\r\n            [\r\n                NO_COLLECT, [\" \", \"\\n\"],\r\n                WRAP,\r\n                [\r\n                    [MATCH_ATTRIBUTES],\r\n                    [\r\n                        [\"/>\", \">\"],\r\n                        UNWRAP\r\n                    ]\r\n                ]\r\n            ]\r\n        ]\r\n    ];\r\n\r\n}\r\nfunction matchCustomTag(tagName: IPattern, tagEnd: IPattern) {\r\n    return [\r\n        node(\"HTMLElement\"),\r\n        pick(collectChildNodes),\r\n        pick(collectAttrs),\r\n        pick(collectTagName),\r\n        \"<\", SPLIT,\r\n        tagName,\r\n        SPLIT,\r\n        [\r\n            [\r\n                \"/>\",\r\n                hook(function (env) {//使折叠次数一致\r\n                    const { tokens, hookPoint } = env;\r\n                    tokens.push(tokens.splice(hookPoint));\r\n                }, HOOK_MODE.RESOLVE),\r\n                FINISH\r\n            ],\r\n            [\r\n                WRAP, \">\",\r\n                WRAP, //保持折叠次数，统一使用同一个 hook 逻辑处理\r\n                tagEnd\r\n            ],\r\n            [\r\n                NO_COLLECT, [\" \", \"\\n\"],\r\n                WRAP,\r\n                [\r\n                    [\"/>\", UNWRAP_ALL],\r\n                    [MATCH_ATTRIBUTES],\r\n                    [\">\", WRAP, tagEnd]\r\n                ]\r\n            ]\r\n        ],\r\n    ]\r\n}\r\n\r\n\r\nfunction collectAttrs(tokens: Array<any>) {\r\n    const attrs = [];\r\n\r\n    for (let i = 1; i < tokens.length - 1; i += 1) {\r\n        let key = getValue(tokens[i]);\r\n        let value = \"\";\r\n        if (getValue(tokens[i + 1]) === \"=\") {\r\n            value = getValue(tokens[i += 2]);\r\n        }\r\n        attrs.push({ key, value });\r\n    }\r\n    tokens.splice(1, tokens.length - 2, useKey(\"attrs\", attrs));\r\n    return tokens;\r\n\r\n    function getValue(token: any) {\r\n        if (token instanceof Token) {\r\n            return token.value;\r\n        } else if (token instanceof Array) {\r\n            return token.map(getValue);\r\n        }\r\n        return token;\r\n    }\r\n}\r\n\r\nfunction formatTokens(tokens: Array<any>) {\r\n    const result = [];\r\n\r\n    let textNode: any, textToken: Token;\r\n    walk(tokens);\r\n\r\n    return result;\r\n\r\n    function walk(token: any) {\r\n        if (token instanceof Array) {\r\n            token.forEach(walk);\r\n        } else {\r\n            if (token instanceof Token) {\r\n                if (textToken) {\r\n                    textToken = textToken.concat(token);\r\n                } else {\r\n                    textToken = token;\r\n                    textNode = new TextNode();\r\n                    result.push(textNode);\r\n                }\r\n                textNode.data = textToken.value;\r\n                textNode.loc = textToken.loc;\r\n                return;\r\n            }\r\n            textNode = textToken = null;\r\n            result.push(token);\r\n        }\r\n    }\r\n}\r\n\r\nfunction collectChildNodes(tokens: Array<any>) {\r\n    const nodes = tokens.pop();\r\n    tokens.push(\r\n        useKey(\r\n            \"childNodes\",\r\n            nodes instanceof Array\r\n                ? formatTokens(nodes.slice(1, -1))\r\n                : []\r\n        )\r\n    );\r\n    return tokens;\r\n}\r\n\r\nfunction collectTagName(tokens: Array<any>) {\r\n    tokens.splice(0, 2, useKey(\"tagName\", tokens[1].value.toUpperCase()))\r\n    return tokens;\r\n}\r\n"],"names":["FINISH","WRAP","UNWRAP","UNWRAP_ALL","OPTION","SPLIT","NO_COLLECT","NO_CAPTURE","MARK_AS_ROOT","FORK_IN_PARENT","FORK_IN_ROOT","END","END_ON_LEFT","useKey","node","key","pick","hook","pipe","prev","merge","MATCH_BEGIN","MATCH_END","MATCH_EOF","MERGE_ALL_TOKENS","UNFOLD","OPERATIONS","MATCH_WHITE_SPACE_CHARACHER","CLEAR_COMMENT","CLEAR_WHITE_SPACE_CHARACHER","TEST_KEYWORD_BOUNDARY","NODE_LIST","tokens","filter","token","Token","THROW_TOKEN_ERROR","Wrapper","env","start","end","console","log","MATCH_STRING","MATCH_CSS_ATTRIBUTE_VALUE","MATCH_CSS_ATTRIBUTE","value","CSSStyleRule","trim","undefined","CSSMediaRule","length","match","index","CSSKeyframesRule","CSSFontFaceRule","CSSSupportsRule","Hook","mode","Node","constructor","type","map","useContent","super","this","NODE_MAP","eval","use","hookPoint","loc","addItem","item","content","push","splice","walk","Array","forEach","UseKey","Key","Merge","Prev","onlyToken","res","slice","Pipe","Pick","Call","NoCapture","offset","line","column","MARKS","SCOPE","String","toString","val","fn","reduce","concat","ROOT","RESOLVE","TYPE","ROLL","PARENT","COLLECT","BUBBING_HOOKS","CAPTURING_HOOKS","SLICE_HOOKS","IGNORE_TESTS","RESOLVE_TYPE_SET","Set","Scanner","pattern","configure","useEscape","useFold","ignoreCase","scanTree","build","Object","assign","scan","options","resolveState","cpos","input","begin","matchPool","scopeStack","getPosition","hasEscape","isBegin","char","CURSOR","resolve","state","collect","toLowerCase","noResolve","pool","slices","hasBranch","shift","NODE","parent","splits","stackSize","backSteps","finallize","scope","USE_FOLD","pop","BACK_POINT","use_collect","startPos","len","hooks","sliceHooks","has","backPoint","unshift","collectSlices","useHook","wrap","START","unwrap","cursor","i","next","found","beginIndex","endIndex","range","limit","RootStack","matchTree","nodes","bubbling_map","capturing_map","buildRule","buildKey","patterns","bubbleTable","captureTable","scopeChain","rsRule","ndepth","forkChain","setHook","maps","bubbleHooks","d","list","newNodes","newBubbleTable","newCaptureTable","window","test","addHook","captureHooks","getResolveNode","reverse","unwrapTokens","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","SELF_CLOSING_TAGS","MATCH_ATTRIBUTES","MATCH_TAG_END","MATCH_SCRIPT_TEXT","MATCH_SCRIPT_END","CSSScanner","MATCH_STYLE_END","TextNode","tagName","matchCustomTag","tagEnd","collectChildNodes","collectAttrs","collectTagName","attrs","getValue","formatTokens","result","textNode","textToken","data","toUpperCase"],"sourceRoot":""}