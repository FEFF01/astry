{"version":3,"file":"js/../js/html-grammar.js","mappings":"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","sources":["webpack://astry/./js/css-grammar.ts","webpack://astry/./js/scanner.ts","webpack://astry/webpack/bootstrap","webpack://astry/./js/html-grammar.ts"],"sourcesContent":["import {\r\n    Scanner, OPERATIONS, HOOK_MODE, IScanEnv,\r\n    IPattern, Token,\r\n    IPosition, ISourceLocation,\r\n} from \"./scanner\"\r\n\r\n\r\nconst {\r\n    FINISH,\r\n    WRAP, UNWRAP, UNWRAP_ALL,\r\n    OPTION,\r\n    SPLIT,\r\n    NO_COLLECT, NO_CAPTURE,\r\n    MARK_AS_ROOT, FORK_IN_PARENT, FORK_IN_ROOT,\r\n    END, END_ON_LEFT,\r\n    useKey,\r\n    node, key, pick, hook, pipe, prev, merge,\r\n\r\n    MATCH_BEGIN,\r\n    MATCH_END,\r\n    MATCH_EOF,\r\n    MERGE_ALL_TOKENS,\r\n    UNFOLD\r\n} = OPERATIONS;\r\n\r\n\r\n\r\nconst MATCH_WHITE_SPACE_CHARACHER: IPattern = [` `, `\\n`, `\\t`];\r\nconst CLEAR_COMMENT: IPattern = [\r\n    [\r\n        NO_COLLECT,\r\n        [\r\n            [\"//\", WRAP, [\"\\n\", [MATCH_EOF]], UNWRAP],\r\n            [\"/*\", WRAP, [\"*/\", [MATCH_EOF]], UNWRAP],\r\n        ],\r\n    ]\r\n]\r\n\r\nconst CLEAR_WHITE_SPACE_CHARACHER: IPattern = [\r\n    [NO_COLLECT, MATCH_WHITE_SPACE_CHARACHER]\r\n];\r\n\r\n\r\nconst TEST_KEYWORD_BOUNDARY: IPattern = [\r\n    [NO_CAPTURE, [\" \", \"\\n\", `\\t`, \"(\", \")\", \"{\", \"}\", \":\"]]\r\n];\r\n\r\nconst NODE_LIST = function (tokens: Array<any>) {\r\n    return tokens.filter(token => !(token instanceof Token));\r\n}\r\nconst Declaration = node(\"Declaration\").Wrapper;\r\n\r\nconst THROW_TOKEN_ERROR = hook(function (env, start, end) {\r\n    console.log(\"Invalid or unexpected token\", start, end);\r\n}, HOOK_MODE.RESOLVE);\r\n\r\nconst MATCH_STRING: IPattern = [\r\n    [\r\n        `\"`, WRAP,\r\n        [\r\n            [THROW_TOKEN_ERROR, `\\n`],\r\n            [`\\\\`, [`\\\\`, `\\n`, `\"`]],\r\n            [`\"`, UNWRAP]\r\n        ]\r\n\r\n    ],\r\n    [\r\n        `'`, WRAP,\r\n        [\r\n            [THROW_TOKEN_ERROR, `\\n`],\r\n            [`\\\\`, [`\\\\`, `\\n`, `'`]],\r\n            [`'`, UNWRAP]\r\n        ]\r\n    ],\r\n]\r\n\r\n// 不包含 '' \"\" 的 url 地址可能会包含断义字符 / 影响判别，这里通过单独匹配给出结果\r\nconst MATCH_URL: IPattern = [\r\n    [\r\n        MATCH_BEGIN, \"url(\", WRAP,\r\n        [\r\n            [MATCH_STRING],\r\n            [CLEAR_WHITE_SPACE_CHARACHER],\r\n            [\")\", UNWRAP]\r\n        ],\r\n    ]\r\n];\r\n\r\nconst MATCH_CSS_ATTRIBUTE_VALUE: IPattern = [\r\n    [\r\n        MARK_AS_ROOT,\r\n        [\r\n            [MATCH_STRING],\r\n            [MATCH_URL],\r\n            [\r\n                // 使能在 ( 后被断句\r\n                // 这里没做额外检验允许括号前的空格\r\n                MERGE_ALL_TOKENS,\r\n                prev(null, true), \"(\"\r\n            ],\r\n            \")\",\r\n            [CLEAR_WHITE_SPACE_CHARACHER],\r\n            [CLEAR_COMMENT],\r\n            [\r\n                MERGE_ALL_TOKENS,\r\n                prev(null, true),\r\n                \"%\"\r\n            ],\r\n            \"/\",\r\n            \",\"\r\n        ]\r\n    ]\r\n]\r\nconst MATCH_CSS_ATTRIBUTE: IPattern = [\r\n    [CLEAR_COMMENT],\r\n    [CLEAR_WHITE_SPACE_CHARACHER],\r\n    [   //通用样式匹配\r\n        merge(function ([key, value]) {\r\n            return useKey(key, value);\r\n        }),\r\n        prev(function (token: any) {\r\n            if (token instanceof Token) {\r\n                return true;\r\n            }\r\n            debugger;\r\n        }),\r\n        NO_COLLECT, \":\", WRAP,\r\n        [\r\n            [MATCH_CSS_ATTRIBUTE_VALUE],\r\n            [\"!important\", NO_CAPTURE, [MATCH_END, \" \", \"\\n\", \"}\", \";\"]],\r\n            [NO_CAPTURE, \"}\", UNWRAP],\r\n            [NO_COLLECT, \";\", UNWRAP],\r\n            [MATCH_EOF, UNWRAP]\r\n        ]\r\n    ]\r\n]\r\n\r\nconst CSSStyleRule = [\r\n    node(\"CSSStyleRule\"),\r\n    key(\"selectorText\", function (token: Token) { return token.trim() }),\r\n    prev(function (token: any) {\r\n        if (token instanceof Token) {\r\n            return true;\r\n        }\r\n        debugger;\r\n        // error\r\n    }),\r\n    key(\"style\"),\r\n    node(\r\n        \"CSSStyleDeclaration\",\r\n        /*function ([token]: [Array<any>], env: ScanEnv, start: Position, end: Position) {\r\n            token.push(\r\n                useKey(\"cssText\", env.input.slice(start.offset + 1, end.offset - 1))\r\n            )\r\n        }*/\r\n        undefined, true\r\n    ),\r\n    \"{\", WRAP,\r\n    [\r\n        [\"}\", UNWRAP],\r\n        [MATCH_CSS_ATTRIBUTE]\r\n    ],\r\n];\r\nconst CSSMediaRule = [\r\n    MARK_AS_ROOT,\r\n    node(\"CSSMediaRule\"),\r\n    \"@media\", TEST_KEYWORD_BOUNDARY, WRAP,\r\n    key(\"media\"),\r\n    prev(function (token: Token) {\r\n        const value = token.value;\r\n        return value.length - value.match(/\\S|$/).index;\r\n    }, true),\r\n    key(\"cssRules\", NODE_LIST),\r\n    \"{\", WRAP,\r\n    FORK_IN_ROOT,\r\n    \"}\", UNWRAP_ALL\r\n];\r\nconst CSSKeyframesRule = [\r\n    node(\"CSSKeyframesRule\"),\r\n    \"@keyframes\", TEST_KEYWORD_BOUNDARY, WRAP,\r\n    key(\"name\"),\r\n    prev(function (token: any) {\r\n        if (token instanceof Token) {\r\n            return true;\r\n        }\r\n        debugger;\r\n    }),\r\n    key(\"cssRules\", NODE_LIST),\r\n    \"{\", WRAP,\r\n    [\r\n        [\"}\", UNWRAP_ALL],\r\n        [\r\n            node(\"CSSKeyframeRule\"),\r\n            \"{\", WRAP,\r\n            [\r\n                [\"}\", UNWRAP],\r\n                [MATCH_CSS_ATTRIBUTE]\r\n            ]\r\n        ]\r\n    ]\r\n];\r\nconst CSSFontFaceRule = [\r\n    node(\"CSSFontFaceRule\"),\r\n    \"@font-face\", TEST_KEYWORD_BOUNDARY, WRAP,\r\n    \"{\", WRAP,\r\n    [\r\n        [\"}\", UNWRAP_ALL],\r\n        [MATCH_CSS_ATTRIBUTE]\r\n    ]\r\n];\r\nconst CSSSupportsRule = [\r\n    MARK_AS_ROOT,\r\n    node(\"CSSSupportsRule\"),\r\n    pick(function (tokens: Array<any>) {\r\n        return [\r\n            useKey(\"conditionText\", tokens[1].value.trim()),\r\n            useKey(\"cssRules\", NODE_LIST(tokens[2]))\r\n        ];\r\n    }),\r\n    \"@supports\", TEST_KEYWORD_BOUNDARY, WRAP,\r\n    \"{\", WRAP,\r\n    FORK_IN_ROOT,\r\n    \"}\", UNWRAP_ALL\r\n];\r\n\r\nexport {\r\n    MATCH_CSS_ATTRIBUTE_VALUE,\r\n    MATCH_CSS_ATTRIBUTE\r\n}\r\nexport default <IPattern>[\r\n    [CLEAR_COMMENT],\r\n    [NO_COLLECT, [[\"\", MATCH_WHITE_SPACE_CHARACHER]]],\r\n    CSSSupportsRule,\r\n    CSSStyleRule,\r\n    CSSMediaRule,\r\n    CSSKeyframesRule,\r\n    CSSFontFaceRule\r\n];\r\n","\r\n\r\n\r\nexport {\r\n    Scanner, OPERATIONS, HOOK_MODE, IScanEnv,\r\n    IPattern, Token,\r\n    IPosition, ISourceLocation,\r\n    UseKey, unwrapTokens\r\n}\r\n\r\ntype IScanEnv = {\r\n    tokens: Array<any>,\r\n    input: string,\r\n    begin: number,\r\n    offset: number,\r\n    end: number,\r\n    line: number,\r\n    column: number,\r\n    useFold: boolean,\r\n    useEscape: boolean,\r\n    ignoreCase: boolean,\r\n    hookPoint: number, // 用于指定当前钩子方法目标 token 位置\r\n}\r\n\r\n\r\nconst enum HOOK_MODE {\r\n    RESOLVE = 0b1,\r\n    CAPTURE = 0b10,\r\n    PIPE = 0b100\r\n    //LEFT_ASSOCIATIVE = 0b101\r\n}\r\n\r\ninterface IPosition {\r\n    offset: number,\r\n    line: number,\r\n    column: number\r\n}\r\ninterface ISourceLocation {\r\n    start: IPosition,\r\n    end: IPosition\r\n}\r\n\r\n\r\ntype IPattern = Hook\r\n    | string\r\n    | String    // 用于在不占用 string 描述空间的基础上，清晰的定义一些操作指令\r\n    | Array<\r\n        string  //  单段字符串不需要在数组内也能简化的声明为一个分支\r\n        | Array<IPattern>    //  其他内容需要被数组包裹\r\n    > // Array 代表 Pattern 内的分支 Pattern\r\n\r\n\r\nenum SCOPE {\r\n    NODE, START, BEGIN, CURSOR, BACK_POINT, USE_FOLD\r\n}\r\n\r\n\r\ninterface IScope {\r\n    [SCOPE.NODE]: any,\r\n    [SCOPE.START]: IPosition,\r\n    [SCOPE.BEGIN]: IPosition,\r\n    [SCOPE.CURSOR]: IPosition,\r\n    [SCOPE.BACK_POINT]: number,\r\n    [SCOPE.USE_FOLD]: boolean\r\n}\r\n\r\ntype ISlices = Array<[IPosition, Hook[]]>;\r\n\r\ntype IResolveState = [any, IPosition, ISlices, number];\r\n\r\n\r\n\r\nabstract class Hook {\r\n    mode: HOOK_MODE = HOOK_MODE.RESOLVE;\r\n    abstract use(env: IScanEnv, start: IPosition, end: IPosition, begin: IPosition): any\r\n}\r\n\r\n\r\n\r\n\r\nclass Node extends Hook {\r\n    static NODE_MAP = {};\r\n    public Wrapper: any;\r\n    constructor(\r\n        public type: string,\r\n        public map?: (tokens: Array<any>, env: IScanEnv, start: IPosition, end: IPosition) => any,\r\n        private useContent?: boolean\r\n    ) {\r\n        super();\r\n        this.Wrapper = Node.NODE_MAP[type] || (\r\n            Node.NODE_MAP[type] = eval(\r\n                `(function ${type}(){this.type=\"${type}\";})`\r\n            )\r\n        );\r\n    }\r\n    use(env: IScanEnv, start: IPosition, end: IPosition) {\r\n\r\n        let { tokens, hookPoint } = env;\r\n\r\n        const node = new this.Wrapper();\r\n        node.loc = { start, end };\r\n        let addItem = function (item: UseKey) {\r\n            node[item.key] = item.value;\r\n        }\r\n        if (this.useContent) {\r\n            const content = node.content = [];\r\n            addItem = function (item: UseKey) {\r\n                content.push(item);\r\n            }\r\n        }\r\n        tokens = tokens.splice(hookPoint);\r\n        if (this.map) {\r\n            tokens = this.map(tokens, env, start, end) || tokens;\r\n        }\r\n        walk(tokens);\r\n        env.tokens.push(node);\r\n\r\n        function walk(token: any) {\r\n            if (token instanceof Array) {\r\n                token.forEach(walk);\r\n            } else if (token instanceof UseKey) {\r\n                addItem(token);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nclass UseKey {\r\n    constructor(public key: string, public value: any) { }\r\n}\r\n\r\nclass Key extends Hook {\r\n    static Wrapper = UseKey;\r\n    constructor(public key: string, public map?: (token: any, env: IScanEnv, start: IPosition, end: IPosition) => any) {\r\n        super();\r\n    }\r\n    use(env: IScanEnv, start: IPosition, end: IPosition) {\r\n        let { tokens, hookPoint } = env;\r\n        let token = tokens[hookPoint];\r\n        this.map && (token = this.map(token, env, start, end) || token);\r\n        tokens.splice(hookPoint, 1, new UseKey(this.key, token));\r\n    }\r\n}\r\n\r\nclass Merge extends Hook {\r\n    constructor(public map: (tokens: Array<any>, env: IScanEnv, start: IPosition, end: IPosition) => any) {\r\n        super();\r\n    }\r\n    use(env: IScanEnv, start: IPosition, end: IPosition) {\r\n        let { tokens, hookPoint } = env;\r\n\r\n        tokens.push(this.map(tokens.splice(hookPoint), env, start, end));\r\n    }\r\n}\r\n\r\nclass Prev extends Hook {\r\n    constructor(\r\n        public match?: (token: Token | any, env: IScanEnv) => number | boolean,\r\n        public onlyToken?: boolean\r\n    ) {\r\n        super();\r\n    }\r\n    use(env: IScanEnv) {\r\n\r\n        let { tokens, hookPoint } = env;\r\n        hookPoint -= 1;\r\n        let prev = tokens[hookPoint];\r\n        if (!this.onlyToken || prev instanceof Token) {\r\n            if (this.match) {\r\n                let res = this.match(prev, env);\r\n                if (res) {\r\n                    if (typeof res === \"number\" && res !== prev.value.length) {\r\n                        tokens.splice(\r\n                            hookPoint, 1,\r\n                            prev.slice(0, -res), prev.slice(-res)\r\n                        );\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            env.hookPoint -= 1;\r\n        }\r\n    }\r\n}\r\nclass Pipe extends Hook {\r\n    mode = HOOK_MODE.PIPE;\r\n    constructor(public pipe: (token: any, env: IScanEnv, start: IPosition, end: IPosition) => any) {\r\n        super();\r\n    }\r\n    use(env: IScanEnv, start: IPosition, end: IPosition) {\r\n        let { tokens, hookPoint } = env;\r\n        let res = this.pipe(tokens[hookPoint], env, start, end);\r\n        if (res !== undefined) {\r\n            tokens[hookPoint] = res;\r\n        } else {\r\n            tokens.splice(hookPoint, 1);\r\n        }\r\n    }\r\n}\r\nclass Pick extends Pipe {\r\n    mode = HOOK_MODE.RESOLVE;\r\n}\r\n\r\nclass Call extends Hook {\r\n    constructor(\r\n        public use: (env: IScanEnv, start: IPosition, end: IPosition, begin: IPosition) => any,\r\n        public mode: HOOK_MODE\r\n    ) {\r\n        super();\r\n    }\r\n}\r\nclass NoCapture extends Hook {\r\n    mode = HOOK_MODE.CAPTURE;\r\n    constructor() {\r\n        super()\r\n    }\r\n    use(env: IScanEnv, start: IPosition, end: IPosition) {\r\n        let { tokens, hookPoint } = env;\r\n        tokens.splice(hookPoint, 1);\r\n        if (start.offset < env.offset/*end.offset === env.offset*/) {\r\n            env.offset = start.offset;\r\n            env.line = start.line;\r\n            env.column = start.column;\r\n        }\r\n    }\r\n}\r\n\r\nnamespace OPERATIONS {\r\n    export const\r\n        FINISH = new String(\"FINISH\"),\r\n        WRAP = new String(\"WRAP\"),\r\n        UNWRAP = new String(\"UNWRAP\"),\r\n        UNWRAP_ALL = new String(\"UNWRAP_ALL\"),\r\n        OPTION = new String(\"OPTION\"),\r\n        SPLIT = new String(\"SPLIT\"),\r\n        NO_COLLECT = new String(\"NO_COLLECT\"),\r\n        NO_CAPTURE = new String(\"NO_CAPTURE\"),\r\n        MARK_AS_ROOT = new String(\"MARK_AS_ROOT\"),\r\n        FORK_IN_PARENT = new String(\"FORK_IN_PARENT\"),\r\n        FORK_IN_ROOT = new String(\"FORK_IN_ROOT\"),\r\n        END = new String(\"END\"),\r\n        END_ON_LEFT = new String(\"END_ON_LEFT\");\r\n\r\n    export const useKey = function (key: string | Token, value: any) {\r\n        return new UseKey(key.toString(), value);\r\n    }\r\n\r\n    export const\r\n        node = function (\r\n            val: string,\r\n            map?: (tokens: Array<any>, env: IScanEnv, start: IPosition, end: IPosition) => any,\r\n            useContent = false,\r\n            mode = HOOK_MODE.RESOLVE\r\n        ) {\r\n            const node = new Node(val, map, useContent);\r\n            node.mode = mode;\r\n            return node;\r\n        },\r\n        key = function (val: string, map?: (token: any, env: IScanEnv, start: IPosition, end: IPosition) => any) {\r\n            return new Key(val, map);\r\n        },\r\n        pick = function (map?: (token: any, env: IScanEnv, start: IPosition, end: IPosition) => any) {\r\n            return new Pick(map || function () { });\r\n        },\r\n        hook = function (fn: (env: IScanEnv, start: IPosition, end: IPosition, begin: IPosition) => void, mode = HOOK_MODE.RESOLVE) {\r\n            return new Call(fn, mode);\r\n        },\r\n        pipe = function (pipe?: (token: any, env: IScanEnv, start: IPosition, end: IPosition) => any) {\r\n            return new Pipe(pipe || function () { });\r\n        },\r\n        prev = function (match?: (token: Token | any, env: IScanEnv) => number | boolean, onlyToken?: boolean) {\r\n            return new Prev(match, onlyToken);\r\n        },\r\n        merge = function (\r\n            map: (tokens: Array<any>, env: IScanEnv, start: IPosition, end: IPosition) => any\r\n                = function (tokens) { return tokens; }\r\n        ) {\r\n            return new Merge(map);\r\n        };\r\n\r\n\r\n\r\n    export const\r\n        MATCH_BEGIN = \"\",\r\n        MATCH_END = \"\",\r\n        MATCH_EOF: IPattern = [[\"\", \"\"]],\r\n        MERGE_ALL_TOKENS = merge(\r\n            function (tokens: Array<Token>) {\r\n                return tokens.reduce((res, token) => res.concat(token));\r\n            }\r\n        ),\r\n        UNFOLD = hook(function (env) {\r\n            const { tokens, hookPoint } = env;\r\n            for (const item of tokens.splice(hookPoint)) {\r\n                if (item instanceof Array) {\r\n                    tokens.push(...item);\r\n                } else {\r\n                    tokens.push(item);\r\n                }\r\n            }\r\n        }, HOOK_MODE.RESOLVE);\r\n}\r\n\r\n\r\nnamespace MARKS {\r\n    export const\r\n        FINISH = OPERATIONS.FINISH,\r\n        END = OPERATIONS.END,\r\n        END_ON_LEFT = OPERATIONS.END_ON_LEFT,\r\n        UNWRAP = OPERATIONS.UNWRAP,\r\n        WRAP = OPERATIONS.WRAP,\r\n        ROOT = new String(\"ROOT\");\r\n\r\n\r\n    export const\r\n        RESOLVE = \"_RESOLVE_\",\r\n        TYPE = \"_TYPE_\",\r\n        ROLL = \"_ROLL_\",\r\n        PARENT = \"_PARENT_\",\r\n        COLLECT = \"_COLLECT_\",\r\n        BUBBING_HOOKS = \"_BUBBING_HOOKS_\",\r\n        CAPTURING_HOOKS = \"_CAPTURING_HOOKS_\",\r\n        SLICE_HOOKS = \"_SLICE_HOOKS_\",\r\n        IGNORE_TESTS = \"_IGNORE_TESTS_\";\r\n\r\n\r\n\r\n    export const RESOLVE_TYPE_SET: Set<String> = new Set([\r\n        OPERATIONS.FINISH,\r\n        OPERATIONS.END,\r\n        OPERATIONS.END_ON_LEFT,\r\n        OPERATIONS.UNWRAP,\r\n        OPERATIONS.UNWRAP_ALL,\r\n        OPERATIONS.WRAP,\r\n        ROOT    // 只是个占位\r\n    ]);\r\n}\r\n\r\nclass Scanner {\r\n\r\n    private scanTree: Record<string, any>;\r\n    public useEscape = false;\r\n    public useFold = true;\r\n    public ignoreCase = false;\r\n    constructor(\r\n        pattern: IPattern,\r\n        configure?: { useEscape?: boolean, useFold?: boolean, ignoreCase?: boolean }\r\n    ) {\r\n        this.scanTree = build(pattern);\r\n        configure && Object.assign(this, configure);\r\n    }\r\n\r\n    scan(options: IScanEnv | string) {\r\n        let env = typeof options === \"string\" ? {\r\n            tokens: [],\r\n            input: options,\r\n            begin: 0,\r\n            offset: 0,\r\n            end: options.length,\r\n            line: 1,\r\n            column: 1,\r\n            useFold: this.useFold,\r\n            useEscape: this.useEscape,\r\n            ignoreCase: this.ignoreCase,\r\n            hookPoint: 0\r\n        } : options;\r\n\r\n        let matchPool: Array<[any, ISlices]> = [];\r\n        let scopeStack: Array<IScope> = [[\r\n            this.scanTree,\r\n            getPosition(), getPosition(), getPosition(),\r\n            0, false\r\n        ]];\r\n        let resolveState: IResolveState;\r\n        let hasEscape = 0;\r\n        let isBegin = true;\r\n\r\n\r\n        let cpos: IPosition;\r\n        while (true) {\r\n\r\n            if (!hasEscape) {\r\n                // 如果启用 useEscape 模式，字符捕获焦点从可能的 \\ 号开始\r\n                cpos = getPosition();\r\n            }\r\n\r\n            let char: string;\r\n\r\n            if (!isBegin) {\r\n\r\n                if (env.offset >= env.end) {\r\n\r\n                    // 首个匹配符为 \"\" 则代表匹配每一轮的开始\r\n                    // 当前面存在匹配符，后面出现的单独的 \"\" 匹配符则代表匹配输入内容的结束\r\n                    // 如果仅匹配输入内容的结束，可以这样描述 : [\"\",\"\"]\r\n\r\n                    if (\r\n                        scopeStack[0][SCOPE.CURSOR].offset < cpos.offset\r\n                    ) {// 匹配扫描过程已结束\r\n                        if (match(\"\") || resolve()) {\r\n                            return env;\r\n                        }\r\n                        if (env.offset < env.end) {\r\n                            break;\r\n                        }\r\n                        matchPool.length = 0;\r\n                        match(\"\");\r\n                    }\r\n                    if (matchPool.length) {\r\n                        const state = resolveState;\r\n                        match(\"\", true);\r\n                        // 仅匹配 OPERATIONS.MATCH_EOF 的 [\"\",\"\"] \r\n                        // 排除 OPERATIONS.MATCH_BEGIN OPERATIONS.MATCH_END 的 \"\"\r\n                        if (state !== resolveState && resolve()) {\r\n                            return env;\r\n                        }\r\n                    }\r\n                    if (scopeStack[0][SCOPE.CURSOR].offset < cpos.offset) {\r\n                        collect(scopeStack[0][SCOPE.CURSOR], cpos, null);\r\n                    }\r\n                    break;\r\n                }\r\n\r\n                char = env.input[env.offset];\r\n                env.offset += 1;\r\n\r\n                switch (char) {\r\n                    case \"\\r\":\r\n                        if (env.input[env.offset] !== \"\\n\") {\r\n                            //env.column = 0;\r\n                            break;\r\n                        }\r\n                        // 将 \\r\\n 归类为 \\n 处理\r\n                        char = \"\\n\";\r\n                        env.offset += 1;\r\n                    case \"\\n\":\r\n                        env.line += 1;\r\n                        env.column = 0;\r\n                        break;\r\n                }\r\n                env.column += 1;\r\n                env.ignoreCase && (char = char.toLowerCase());\r\n\r\n                if (env.useEscape) {\r\n                    if (char === \"\\\\\") {\r\n                        hasEscape ^= 1;\r\n                        if (hasEscape) {\r\n                            continue;\r\n                        }\r\n                    } else if (hasEscape) {\r\n                        hasEscape = 0;\r\n                        char = \"\\\\\" + char;\r\n                    }\r\n                }\r\n            } else {\r\n                char = \"\";\r\n                isBegin = false;\r\n            }\r\n            \r\n            if (match(char)) {\r\n                return env;\r\n            }\r\n        }\r\n\r\n        return env;\r\n\r\n\r\n        function getPosition(): IPosition {\r\n            return { offset: env.offset, line: env.line, column: env.column }\r\n        }\r\n\r\n        function match(key: string, noResolve?: boolean) {\r\n            const pool = matchPool;\r\n            const scopeNode = scopeStack[0][SCOPE.NODE];\r\n\r\n            matchPool = [];\r\n\r\n            let node: any;\r\n            let slices: ISlices;\r\n            let hasBranch: boolean;\r\n            let hasScopeNode = false;\r\n\r\n            while (true) {\r\n                if (pool.length) {\r\n                    [node, slices] = pool.shift();\r\n                } else if (!resolveState && !hasScopeNode) {\r\n                    node = scopeNode;\r\n                    slices = null;\r\n                } else {\r\n                    break;\r\n                }\r\n                hasScopeNode = hasScopeNode || (node === scopeNode);\r\n                hasBranch = false;\r\n\r\n                resolveState = walk(node, slices)\r\n                    || node[MARKS.ROLL] && walk(node[MARKS.ROLL], slices)\r\n                    || resolveState;\r\n            }\r\n\r\n\r\n            if (!noResolve && matchPool.length === 0 && resolve()) {\r\n                return true;\r\n            }\r\n\r\n            function walk(parent: any, slices?: ISlices): IResolveState {\r\n                let node = parent[key];\r\n                if (!node) {\r\n                    return;\r\n                }\r\n                if (!slices) {\r\n                    slices = [[cpos, parent[MARKS.CAPTURING_HOOKS]]];\r\n                } else if (hasBranch) {\r\n                    slices = slices.slice();\r\n                }\r\n                hasBranch = true;\r\n\r\n                matchPool.push([node, slices]);\r\n                if (node[MARKS.CAPTURING_HOOKS]) {\r\n                    slices.push([getPosition(), node[MARKS.CAPTURING_HOOKS]]);\r\n                }\r\n\r\n                if (!node[MARKS.RESOLVE]) {\r\n                    return;\r\n                } else {\r\n                    node = node[MARKS.RESOLVE];\r\n                }\r\n                return [node, getPosition(), slices, scopeStack.length];\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        function resolve() {\r\n            if (!resolveState) {\r\n                return;\r\n            }\r\n\r\n            const [node, { offset, line, column }, splits, stackSize] = resolveState;\r\n            scopeStack.splice(0, scopeStack.length - stackSize);\r\n            env.offset = offset;\r\n            env.line = line;\r\n            env.column = column;\r\n\r\n            let backSteps = finallize(node, splits, true);\r\n            if (backSteps > 0) {\r\n                return true;\r\n            }\r\n\r\n            if (backSteps < 0) {\r\n                do {\r\n                    const scope = scopeStack.shift();\r\n                    let tokens = env.tokens;\r\n                    if (scope[SCOPE.USE_FOLD]) {\r\n                        (env.tokens = tokens.shift()).pop();\r\n                    } else {\r\n                        tokens.length = scope[SCOPE.BACK_POINT];\r\n                    }\r\n                } while (++backSteps < 0)\r\n            }\r\n            //rollback(res);\r\n            resolveState = null;\r\n            isBegin = true;\r\n        }\r\n\r\n        function finallize(node: any, slices: ISlices, use_collect?: boolean): number {\r\n\r\n            let type = node[MARKS.TYPE];\r\n\r\n            const scope = scopeStack[0];\r\n            const startPos = slices[0][0];\r\n            let len = env.tokens.length;\r\n\r\n            if (use_collect) {\r\n\r\n                let hooks: Array<Hook>;\r\n                let sliceHooks = node[MARKS.SLICE_HOOKS];\r\n                if (sliceHooks) {\r\n                    hooks = slices[0][1];\r\n                    hooks && (hooks = hooks.filter(item => sliceHooks.has(item)));\r\n                }\r\n                collect(scope[SCOPE.CURSOR], startPos, hooks);\r\n            }\r\n\r\n            if (type === MARKS.WRAP) {\r\n                return wrap(node, slices, use_collect);\r\n            }\r\n\r\n            const hookPoint = env.tokens.length;\r\n\r\n            if (use_collect && type !== MARKS.END_ON_LEFT) {\r\n                let res = collectSlices(slices, node[MARKS.SLICE_HOOKS]);\r\n                if (res < 0) {\r\n                    env.tokens.length = len;\r\n                    return res + 1;\r\n                }\r\n            }\r\n            env.hookPoint = hookPoint;\r\n\r\n            if (type === MARKS.UNWRAP) {\r\n                return unwrap(node, slices);\r\n            } else {\r\n                const cursorPos = getPosition();\r\n                const res = useHook(node[MARKS.BUBBING_HOOKS], startPos, cursorPos);\r\n                if (res < 0) {\r\n                    env.tokens.length = len;\r\n                    return res + 1;\r\n                }\r\n                if (type !== MARKS.END_ON_LEFT) {\r\n                    scope[SCOPE.CURSOR] = cursorPos;\r\n                } else {\r\n                    env.offset = startPos.offset;\r\n                    env.line = startPos.line;\r\n                    env.column = startPos.column;\r\n                    scope[SCOPE.CURSOR] = startPos;\r\n                    return 1;\r\n                }\r\n                return type !== MARKS.END ? res : 1;\r\n            }\r\n\r\n        }\r\n\r\n\r\n        function wrap(node: any, slices: ISlices, use_collect?: boolean) {\r\n            const { useFold, tokens } = env;\r\n            const backPoint = tokens.length;\r\n            const startPos = slices[0][0];\r\n            const beginPos = getPosition();\r\n            const cursorPos = getPosition();\r\n            scopeStack.unshift([\r\n                node,\r\n                startPos, beginPos, cursorPos,\r\n                backPoint, useFold\r\n            ]);\r\n\r\n            if (useFold) {\r\n                env.tokens = [tokens];\r\n                env.hookPoint = 1;\r\n            }\r\n\r\n\r\n            let backSteps = use_collect ? collectSlices(\r\n                slices,\r\n                node[MARKS.SLICE_HOOKS]\r\n            ) : 0;\r\n\r\n            if (backSteps >= 0) {\r\n                backSteps = useHook(node[MARKS.BUBBING_HOOKS], startPos, cursorPos, beginPos);\r\n                if (backSteps >= 0) {\r\n                    node = node[MARKS.RESOLVE];\r\n                    return node ? finallize(node, slices, false) : backSteps;\r\n                }\r\n            }\r\n            return backSteps;\r\n        }\r\n\r\n\r\n        function unwrap(node: any, slices: ISlices) {\r\n\r\n            const scope = scopeStack.shift();\r\n\r\n            if (scope[SCOPE.USE_FOLD]) {\r\n                let tokens = env.tokens.shift()\r\n                env.hookPoint = tokens.length;\r\n                tokens.push(env.tokens);\r\n                env.tokens = tokens;\r\n            }\r\n\r\n            let backSteps = useHook(\r\n                node[MARKS.BUBBING_HOOKS],\r\n                scope[SCOPE.START],\r\n                getPosition(),\r\n                scope[SCOPE.BEGIN],\r\n            );\r\n            if (backSteps >= 0) {\r\n                node = node[MARKS.RESOLVE];\r\n\r\n                scopeStack[0][SCOPE.CURSOR] = getPosition();\r\n                if (node) {\r\n                    backSteps = finallize(node, slices, false);\r\n                    if (backSteps >= 0) {\r\n                        return backSteps;\r\n                    }\r\n                } else {\r\n                    return backSteps;\r\n                }\r\n            }\r\n            scopeStack.unshift(scope);\r\n            if (scope[SCOPE.USE_FOLD]) {\r\n                let tokens = env.tokens.pop();\r\n\r\n                tokens.unshift(env.tokens);\r\n                env.tokens = tokens;\r\n            }\r\n            return backSteps + 1;\r\n        }\r\n\r\n        function useHook(hooks: Array<Hook>, start: IPosition, end: IPosition, begin?: IPosition): number {\r\n            for (const hook of hooks) {\r\n                let res = hook.use(env, start, end, begin);\r\n                if (res < 0) {\r\n                    return res;\r\n                }\r\n            }\r\n            return 0;\r\n        }\r\n\r\n        function collect(start: IPosition, end: IPosition, hooks: Array<Hook>) {\r\n            let res: any = 0;\r\n            if (start.offset < end.offset) {\r\n                let { tokens } = env;\r\n                env.hookPoint = tokens.length;\r\n                tokens.push(\r\n                    new Token(\r\n                        env.input.slice(start.offset, end.offset),\r\n                        start,\r\n                        end\r\n                    )\r\n                );\r\n                if (hooks) {\r\n                    res = useHook(hooks, start, end);\r\n                }\r\n            }\r\n            return res;\r\n        }\r\n\r\n        function collectSlices(\r\n            slices: ISlices,\r\n            sliceHooks: Set<Hook>\r\n        ) {\r\n            let cursor = slices[0][0];\r\n            if (sliceHooks) {\r\n                for (let i = 1; i < slices.length; i += 1) {\r\n                    let [next, hooks] = slices[i];\r\n                    hooks = hooks.filter(item => sliceHooks.has(item));\r\n                    if (hooks.length) {\r\n                        const res = collect(cursor, next, hooks);\r\n                        if (res < 0) {\r\n                            return res;\r\n                        }\r\n                        cursor = next;\r\n                    }\r\n                }\r\n            }\r\n            return collect(cursor, getPosition(), null);\r\n        }\r\n    }\r\n}\r\n\r\n\r\nclass Token {\r\n\r\n    loc: ISourceLocation;\r\n\r\n    constructor(public value: string, start: IPosition, end: IPosition) {\r\n        this.loc = { start, end };\r\n    }\r\n    trim() {\r\n        const found = this.value.match(/^\\s*|\\s*$/gm);\r\n        return this.slice(found[0].length, this.value.length - found[1].length);\r\n    }\r\n    concat(token: Token) {\r\n        return new Token(this.value + token.value, this.loc.start, token.loc.end);\r\n    }\r\n    slice(beginIndex: number, endIndex = this.value.length) {\r\n        let { value, loc: { start, end } } = this;\r\n        let { offset, line, column } = start;\r\n        let index = 0;\r\n\r\n        if (endIndex < 0) {\r\n            endIndex = value.length + endIndex;\r\n        }\r\n        if (beginIndex < 0) {\r\n            beginIndex = value.length + beginIndex;\r\n        }\r\n        if (beginIndex > endIndex) {\r\n            endIndex = beginIndex;\r\n        }\r\n        const range = [beginIndex, endIndex].map(\r\n            function (limit): IPosition {\r\n                if (limit === 0) {\r\n                    return start;\r\n                }\r\n                if (limit === value.length) {\r\n                    return end;\r\n                }\r\n                while (index < limit) {\r\n                    if (value[index] === \"\\n\") {\r\n                        line += 1;\r\n                        column = 1;\r\n                    } else {\r\n                        column += 1;\r\n                    }\r\n                    index += 1;\r\n                }\r\n                return { offset: offset + limit, line, column }\r\n            }\r\n        )\r\n        return new Token(value.slice(beginIndex, endIndex), range[0], range[1]);\r\n    }\r\n    toString() {\r\n        return this.value;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\ntype HookStack = Array<Hook | HookStack | RootStack>;\r\ntype HookList = Array<Hook>;\r\n\r\nclass RootStack extends Array<Hook | HookStack> { }\r\n\r\ntype BubbleTable = Array<HookStack>;\r\ntype CaptureTable = Array<HookList>;\r\ntype BuildResult = [Array<any>, BubbleTable, CaptureTable];\r\n\r\nfunction build(pattern: IPattern): Record<string, any> {\r\n    const matchTree = { [MARKS.TYPE]: MARKS.ROOT };\r\n    const [nodes, bubbling_map, capturing_map] = buildRule(\r\n        [pattern],\r\n        [matchTree],\r\n        [[new RootStack()]],\r\n        [[]],\r\n        [matchTree]\r\n    );\r\n    for (let i = 0; i < nodes.length; i += 1) {\r\n        // 被省去 MARKS.FINISH 的描述自动补全\r\n        const node = nodes[i];\r\n        if (!MARKS.RESOLVE_TYPE_SET.has(node[MARKS.TYPE])) {\r\n            buildKey(MARKS.FINISH, [node], [bubbling_map[i]], [capturing_map[i]]);\r\n        }\r\n    }\r\n    return matchTree;\r\n}\r\n\r\n\r\nfunction buildRule(\r\n    patterns: Array<IPattern>,\r\n    nodes: Array<any>,\r\n    bubbleTable: BubbleTable,\r\n    captureTable: CaptureTable,\r\n    scopeChain: Array<any>\r\n): BuildResult {\r\n\r\n    const rsRule: Array<IPattern> = [];\r\n    let index = 0;\r\n    let key: IPattern;\r\n    while (index < patterns.length) {\r\n        let ndepth = 0, begin = index;\r\n        const forkChain: Array<number | String> = [];\r\n\r\n        while (true) {\r\n            if (patterns[index] === OPERATIONS.FORK_IN_ROOT) {\r\n                if (ndepth) {\r\n                    forkChain.push(ndepth);\r\n                    ndepth = 0;\r\n                }\r\n                forkChain.push(OPERATIONS.FORK_IN_ROOT);\r\n            } else if (patterns[index] === OPERATIONS.FORK_IN_PARENT) {\r\n                ndepth += 1;\r\n            } else {\r\n                break;\r\n            }\r\n            index += 1;\r\n        }\r\n\r\n        if (index !== begin) {\r\n            ndepth && forkChain.push(ndepth);\r\n\r\n            for (let node of nodes) {\r\n                let parent: any = node;\r\n                let cursor = 0;\r\n                for (let d of forkChain) {\r\n                    if (d === OPERATIONS.FORK_IN_ROOT) {\r\n                        parent = scopeChain[cursor++];\r\n                    } else {\r\n                        do {\r\n                            parent = parent[MARKS.PARENT];\r\n                            if (parent === scopeChain[cursor]) {\r\n                                cursor += 1;\r\n                            }\r\n                        } while (--(<number>d) > 0)\r\n                    }\r\n                }\r\n                if (node[MARKS.ROLL] !== parent) {\r\n                    if (node[MARKS.ROLL]) {\r\n                        debugger;   // 暂不支持一个匹配路径存在多个 FORK 匹配（用不到）\r\n                    }\r\n                    node[MARKS.ROLL] = parent;\r\n                }\r\n            }\r\n            continue;\r\n        }\r\n\r\n        switch (key = patterns[index]) {\r\n            case OPERATIONS.NO_CAPTURE:\r\n            case OPERATIONS.NO_COLLECT:\r\n                rsRule.push(key);\r\n            case OPERATIONS.SPLIT:\r\n                setHook(null);\r\n                break;\r\n\r\n            case OPERATIONS.OPTION:\r\n                return walk(\r\n                    [\r\n                        rsRule.concat(patterns.slice(index + 1)),\r\n                        rsRule.concat(patterns.slice(index + 2))\r\n                    ],\r\n                    function (pattern) {\r\n                        return buildRule(\r\n                            pattern,\r\n                            nodes,\r\n                            bubbleTable.map(hooks => hooks.slice()),\r\n                            captureTable.map(maps => maps.slice()),\r\n                            scopeChain\r\n                        )\r\n                    }\r\n                );\r\n\r\n            case OPERATIONS.MARK_AS_ROOT:\r\n                patterns = rsRule.concat(patterns.slice(index + 1));\r\n                return walk(nodes, function (node, index) {\r\n                    const bubbleHooks = bubbleTable[index];\r\n                    return buildRule(\r\n                        patterns,\r\n                        [node],\r\n                        [[new RootStack(...<HookStack>bubbleHooks[0])].concat(bubbleHooks.slice(1))],\r\n                        [captureTable[index]],\r\n                        [node].concat(scopeChain)\r\n                    )\r\n                });\r\n            default:\r\n                if (key instanceof Hook) {\r\n                    setHook(key);\r\n                } else {\r\n                    if (key instanceof Array) {\r\n                        [nodes, bubbleTable, captureTable] = walk(key, function (item) {\r\n                            return (item instanceof Array ? buildRule : buildKey)(\r\n                                item, nodes,\r\n                                bubbleTable.map(hooks => hooks.slice()),\r\n                                captureTable.map(maps => maps.slice()),\r\n                                scopeChain\r\n                            )\r\n                        })\r\n                    } else {\r\n                        [nodes, bubbleTable, captureTable] = buildKey(key, nodes, bubbleTable, captureTable);\r\n                    }\r\n                    while (rsRule.length) {\r\n                        setHook(\r\n                            rsRule.shift() === OPERATIONS.NO_COLLECT\r\n                                ? OPERATIONS.pipe()\r\n                                : new NoCapture()\r\n                        );\r\n                    }\r\n                }\r\n                break;\r\n        }\r\n\r\n        index += 1;\r\n    }\r\n\r\n    return [nodes, bubbleTable, captureTable];\r\n\r\n\r\n    function walk(\r\n        list: Array<any>,\r\n        next: (item: any, index: number) => BuildResult\r\n    ): BuildResult {\r\n\r\n        let newNodes: Array<any> = [];\r\n        let newBubbleTable: Array<HookStack> = [];\r\n        let newCaptureTable: Array<any[]> = [];\r\n\r\n        for (let i = 0; i < list.length; i += 1) {\r\n            const res = next(list[i], i);\r\n            newNodes = newNodes.concat(res[0]);\r\n            newBubbleTable = newBubbleTable.concat(res[1]);\r\n            newCaptureTable = newCaptureTable.concat(res[2]);\r\n        }\r\n\r\n\r\n        return [newNodes, newBubbleTable, newCaptureTable];\r\n\r\n    }\r\n    function setHook(hook: Hook) {\r\n\r\n        if (!hook) {\r\n            hook = new Call(function () { }, HOOK_MODE.CAPTURE);\r\n            for (let i = 0; i < nodes.length; i += 1) {\r\n                MARKS.RESOLVE_TYPE_SET.has(nodes[i][MARKS.TYPE]) || addHook(i);\r\n            }\r\n            return;\r\n        }\r\n        switch (hook.mode) {\r\n            case HOOK_MODE.RESOLVE:\r\n                bubbleTable.forEach(hooks => hooks.push(<Hook>key));\r\n                break;\r\n            case HOOK_MODE.PIPE:\r\n            case HOOK_MODE.CAPTURE:\r\n                for (let i = 0; i < nodes.length; i += 1) {\r\n                    addHook(i);\r\n                }\r\n                break;\r\n        }\r\n        function addHook(index: number) {\r\n            const node = nodes[index];\r\n            const type = node[MARKS.TYPE];\r\n            // 实际使用中不会刻意用到共用钩子的情况，统一使之不共用可降低声明成本和更符合声明直觉\r\n            const h = Object.create(hook);\r\n            if (hook.mode !== HOOK_MODE.PIPE && MARKS.RESOLVE_TYPE_SET.has(type)) {\r\n                node[MARKS.BUBBING_HOOKS].push(h);\r\n            } else {\r\n                (\r\n                    node[MARKS.CAPTURING_HOOKS]\r\n                    || (node[MARKS.CAPTURING_HOOKS] = [])\r\n                ).push(h);\r\n                captureTable[index].push(h);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\nfunction buildKey(\r\n    key: any,\r\n    nodes: Array<any>,\r\n    bubbleTable: BubbleTable,\r\n    captureTable: CaptureTable,\r\n    scopeChain?: Array<any>\r\n): BuildResult {\r\n    if (typeof key === \"string\") {\r\n        if (/^[\\s\\S]?$/.test(key)) {\r\n            key = [key];\r\n        }\r\n        for (let i = 0; i < key.length; i += 1) {\r\n            nodes = nodes.map(function (node) {\r\n                return node[key[i]] || (node[key[i]] = { [MARKS.PARENT]: node });\r\n            });\r\n        }\r\n    } else if (MARKS.RESOLVE_TYPE_SET.has(key)) {\r\n\r\n        nodes = nodes.map(function (node, i) {\r\n\r\n            let bubbleHooks: HookStack = bubbleTable[i];\r\n            let captureHooks = captureTable[i];\r\n            captureTable[i] = [];\r\n\r\n            if (key === OPERATIONS.UNWRAP_ALL) {\r\n                key = OPERATIONS.UNWRAP;\r\n                if (!(bubbleHooks[0] instanceof RootStack)) {\r\n                    if (bubbleHooks.length > 1) {\r\n                        bubbleHooks[0] = (<HookStack>bubbleHooks[0]).concat(bubbleHooks.slice(1));\r\n                    }\r\n                    do {\r\n                        bubbleTable[i] = [bubbleHooks[0][0]];\r\n                        bubbleHooks = <HookStack>bubbleHooks[0];\r\n\r\n                        node = getResolveNode(node, key, bubbleHooks, captureHooks);\r\n                    } while (!(bubbleHooks[0] instanceof RootStack))\r\n                }\r\n            } else {\r\n                if (key === OPERATIONS.UNWRAP) {\r\n                    bubbleTable[i] = [bubbleHooks[0][0]];\r\n                    bubbleHooks = (<HookStack>bubbleHooks[0]).concat(bubbleHooks.slice(1));\r\n                } else if (key === OPERATIONS.WRAP) {\r\n                    bubbleTable[i] = [bubbleHooks];\r\n                    bubbleHooks = [];\r\n                } else {\r\n                    bubbleTable[i] = [bubbleHooks[0]];\r\n                }\r\n\r\n                node = getResolveNode(node, key, bubbleHooks, captureHooks);\r\n\r\n            }\r\n            return node;\r\n        });\r\n\r\n    } else {\r\n        debugger;\r\n    }\r\n    return [nodes, bubbleTable, captureTable];\r\n\r\n    function getResolveNode(\r\n        node: any, type: string,\r\n        bubbleHooks: HookStack, sliceHooks: HookList\r\n    ) {\r\n        if (node[MARKS.RESOLVE]) {\r\n            // 如果存在重复定义的 pattern 则这里会执行\r\n            debugger;\r\n        }\r\n        return node[MARKS.RESOLVE] = {\r\n            [MARKS.PARENT]: node,\r\n            [MARKS.TYPE]: type,\r\n            [MARKS.SLICE_HOOKS]: sliceHooks.length\r\n                ? new Set(sliceHooks.splice(0))\r\n                : null,\r\n            [MARKS.BUBBING_HOOKS]: bubbleHooks.slice(1).reverse()\r\n        };\r\n    }\r\n\r\n}\r\n\r\nfunction unwrapTokens(tokens: any) {\r\n    if (tokens instanceof Token) {\r\n        return tokens.value;\r\n    }\r\n    if (tokens instanceof Array) {\r\n        return tokens.map(unwrapTokens);\r\n    }\r\n    return tokens;\r\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import {\r\n    Scanner, OPERATIONS, HOOK_MODE, IScanEnv,\r\n    IPattern, Token,\r\n    IPosition, ISourceLocation,\r\n} from \"./scanner\"\r\n\r\n\r\nconst {\r\n    FINISH,\r\n    WRAP, UNWRAP, UNWRAP_ALL,\r\n    OPTION,\r\n    SPLIT,\r\n    NO_COLLECT, NO_CAPTURE,\r\n    MARK_AS_ROOT, FORK_IN_PARENT, FORK_IN_ROOT,\r\n    END, END_ON_LEFT,\r\n    useKey,\r\n    node, key, pick, hook, pipe, prev, merge,\r\n\r\n    MATCH_BEGIN,\r\n    MATCH_END,\r\n    MATCH_EOF,\r\n    MERGE_ALL_TOKENS\r\n} = OPERATIONS;\r\n\r\nimport CSSGrammar from \"./css-grammar\";\r\n\r\n\r\nconst SELF_CLOSING_TAGS = [\r\n    \"area\",\r\n    \"base\",\r\n    \"br\",\r\n    \"col\",\r\n    \"embed\",\r\n    \"hr\",\r\n    \"img\",\r\n    \"input\",\r\n    \"link\",\r\n    \"meta\",\r\n    \"param\",\r\n    \"source\",\r\n    \"track\",\r\n    \"wbr\",\r\n    \"command\",\r\n    \"keygen\",\r\n    \"menuitem\"\r\n];\r\n\r\nconst MATCH_WHITE_SPACE_CHARACHER: IPattern = [` `, `\\n`, `\\t`];\r\nconst CLEAR_WHITE_SPACE_CHARACHER: IPattern = [\r\n    [NO_COLLECT, MATCH_WHITE_SPACE_CHARACHER]\r\n];\r\n\r\nconst MATCH_ATTRIBUTES: IPattern = [\r\n    [CLEAR_WHITE_SPACE_CHARACHER],\r\n    [\"=\"],\r\n    [`\"`, WRAP, `\"`, UNWRAP],\r\n    [`'`, WRAP, `'`, UNWRAP],\r\n];\r\n\r\n\r\n\r\n\r\nconst MATCH_TAG_END: IPattern = [\r\n    [\r\n        hook(function ({ tokens }) {\r\n            if (tokens[0][2].value !== tokens[tokens.length - 1][1].value) {\r\n                return -2;\r\n            }\r\n        }, HOOK_MODE.RESOLVE),\r\n        \"</\", WRAP,\r\n        [\r\n            [MATCH_WHITE_SPACE_CHARACHER],\r\n            [\">\", UNWRAP_ALL]\r\n        ]\r\n\r\n    ]\r\n];\r\n\r\n\r\nconst THROW_TOKEN_ERROR = hook(function (env, start, end) {\r\n    console.log(\"Invalid or unexpected token\", start, end);\r\n}, HOOK_MODE.RESOLVE);\r\n\r\nconst MATCH_SCRIPT_TEXT: IPattern = [\r\n    [\r\n        `\"`, WRAP,\r\n        [\r\n            [THROW_TOKEN_ERROR, `\\n`],\r\n            [`\"`, UNWRAP]\r\n        ]\r\n\r\n    ],\r\n    [\r\n        `'`, WRAP,\r\n        [\r\n            [THROW_TOKEN_ERROR, `\\n`],\r\n            [`'`, UNWRAP]\r\n        ]\r\n\r\n    ],\r\n    [\"//\", WRAP, [\"\\n\", [OPERATIONS.MATCH_EOF]], UNWRAP],\r\n    [\"/*\", WRAP, [\"*/\", [OPERATIONS.MATCH_EOF]], UNWRAP],\r\n    [\r\n        MARK_AS_ROOT,\r\n        `\\``, WRAP,\r\n        [\r\n            [\r\n                `$`,\r\n                `{`, WRAP,\r\n                FORK_IN_ROOT,\r\n                `}`, UNWRAP\r\n            ],\r\n            [`\\``, UNWRAP]\r\n        ]\r\n    ],\r\n];\r\n\r\nconst MATCH_SCRIPT_END: IPattern = [\r\n    [\r\n        hook(function (env) {\r\n            env.useEscape = true;\r\n            env.ignoreCase = false;\r\n        }, HOOK_MODE.CAPTURE/*HOOK_MODE.LEFT_ASSOCIATIVE*/),\r\n        MATCH_SCRIPT_TEXT\r\n    ],\r\n    [\r\n        hook(function (env) {\r\n            env.useEscape = false;\r\n            env.ignoreCase = true;\r\n        }, HOOK_MODE.RESOLVE),\r\n        MATCH_TAG_END,\r\n    ]\r\n];\r\n\r\nconst CSSScanner = new Scanner(\r\n    [\r\n        [CSSGrammar],\r\n        [\r\n            hook(function (env) {\r\n                env.end = env.offset;\r\n            }, HOOK_MODE.RESOLVE),\r\n            MATCH_TAG_END\r\n        ]\r\n    ],\r\n    { useEscape: true }\r\n);\r\n\r\nconst MATCH_STYLE_END: IPattern = [\r\n\r\n    [// 使用内联 JS 编译\r\n        hook(function (env) {\r\n            const end = env.end;\r\n            env.useEscape = true;\r\n            env.ignoreCase = false;\r\n\r\n            CSSScanner.scan(env);\r\n\r\n            env.end = end;\r\n        }, HOOK_MODE.CAPTURE),\r\n\r\n        hook(function (env) {\r\n            env.useEscape = false;\r\n            env.ignoreCase = true;\r\n        }, HOOK_MODE.RESOLVE),\r\n        \"\", UNWRAP_ALL,\r\n    ]\r\n\r\n    /*\r\n    // 内联整个 CSS Pattern 编译消耗很大\r\n    [MARK_AS_ROOT, CSSGrammar],\r\n    [\r\n        hook(function (env) {\r\n            env.useEscape = true;\r\n            env.ignoreCase = false;\r\n        }, HOOK_MODE.CAPTURE),\r\n        hook(function (env) {\r\n            env.useEscape = false;\r\n            env.ignoreCase = true;\r\n        }, HOOK_MODE.RESOLVE),\r\n        MATCH_TAG_END,\r\n    ]\r\n    */\r\n];\r\n\r\nconst TextNode = node(\"Text\").Wrapper;\r\n\r\n\r\nexport {\r\n    formatTokens,\r\n    SELF_CLOSING_TAGS\r\n};\r\nexport default <IPattern>[\r\n    [\r\n        node(\"DocumentType\"),\r\n        pick(function (tokens: Array<any>) {\r\n            tokens[1] = useKey(\"name\", tokens[1].value);\r\n            return tokens;\r\n        }),\r\n        \"<!doctype\", WRAP,\r\n        [\r\n            [CLEAR_WHITE_SPACE_CHARACHER],\r\n            [\">\", UNWRAP]\r\n        ],\r\n    ],\r\n    [\r\n        node(\"Comment\"),\r\n        key(\"data\", function (tokens) {\r\n            return tokens[1].value;\r\n        }),\r\n        \"<!--\", WRAP, \"-->\", UNWRAP\r\n    ],\r\n    [\r\n        MARK_AS_ROOT,\r\n        node(\"HTMLElement\"),\r\n        pick(collectChildNodes),\r\n        pick(collectAttrs),\r\n        pick(collectTagName),\r\n        \"<\", WRAP,\r\n        [\r\n            [MATCH_ATTRIBUTES],\r\n            [\"/>\", UNWRAP],\r\n            [\r\n                \">\", WRAP,\r\n                [\r\n                    [FORK_IN_ROOT],\r\n                    [MATCH_TAG_END]\r\n                ]\r\n            ]\r\n        ],\r\n    ],\r\n    matchCustomTag(\"script\", MATCH_SCRIPT_END),\r\n    matchCustomTag(\"style\", MATCH_STYLE_END),\r\n    matchCustomTag(\"textarea\", MATCH_TAG_END),\r\n    matchSelfClosingTag(SELF_CLOSING_TAGS),\r\n]\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction matchSelfClosingTag(tagName: IPattern) {\r\n    return [\r\n        node(\"HTMLElement\"),\r\n        pick(collectChildNodes),\r\n        pick(collectAttrs),\r\n        pick(collectTagName),\r\n        \"<\", SPLIT,\r\n        tagName,\r\n        SPLIT,\r\n        [\r\n            [\r\n                [\"/>\", \">\"],\r\n                hook(function (env) {//使折叠次数一致\r\n                    const { tokens, hookPoint } = env;\r\n                    tokens.push(tokens.splice(hookPoint));\r\n                }, HOOK_MODE.RESOLVE),\r\n                FINISH,\r\n            ],\r\n            [\r\n                NO_COLLECT, [\" \", \"\\n\"],\r\n                WRAP,\r\n                [\r\n                    [MATCH_ATTRIBUTES],\r\n                    [\r\n                        [\"/>\", \">\"],\r\n                        UNWRAP\r\n                    ]\r\n                ]\r\n            ]\r\n        ]\r\n    ];\r\n\r\n}\r\nfunction matchCustomTag(tagName: IPattern, tagEnd: IPattern) {\r\n    return [\r\n        node(\"HTMLElement\"),\r\n        pick(collectChildNodes),\r\n        pick(collectAttrs),\r\n        pick(collectTagName),\r\n        \"<\", SPLIT,\r\n        tagName,\r\n        SPLIT,\r\n        [\r\n            [\r\n                \"/>\",\r\n                hook(function (env) {//使折叠次数一致\r\n                    const { tokens, hookPoint } = env;\r\n                    tokens.push(tokens.splice(hookPoint));\r\n                }, HOOK_MODE.RESOLVE),\r\n                FINISH\r\n            ],\r\n            [\r\n                WRAP, \">\",\r\n                WRAP, //保持折叠次数，统一使用同一个 hook 逻辑处理\r\n                tagEnd\r\n            ],\r\n            [\r\n                NO_COLLECT, [\" \", \"\\n\"],\r\n                WRAP,\r\n                [\r\n                    [\"/>\", UNWRAP_ALL],\r\n                    [MATCH_ATTRIBUTES],\r\n                    [\">\", WRAP, tagEnd]\r\n                ]\r\n            ]\r\n        ],\r\n    ]\r\n}\r\n\r\n\r\nfunction collectAttrs(tokens: Array<any>) {\r\n    const attrs = [];\r\n\r\n    for (let i = 1; i < tokens.length - 1; i += 1) {\r\n        let key = getValue(tokens[i]);\r\n        let value = \"\";\r\n        if (getValue(tokens[i + 1]) === \"=\") {\r\n            value = getValue(tokens[i += 2]);\r\n        }\r\n        attrs.push({ key, value });\r\n    }\r\n    tokens.splice(1, tokens.length - 2, useKey(\"attrs\", attrs));\r\n    return tokens;\r\n\r\n    function getValue(token: any) {\r\n        if (token instanceof Token) {\r\n            return token.value;\r\n        } else if (token instanceof Array) {\r\n            return token.map(getValue);\r\n        }\r\n        return token;\r\n    }\r\n}\r\n\r\nfunction formatTokens(tokens: Array<any>) {\r\n    const result = [];\r\n\r\n    let textNode: any, textToken: Token;\r\n    walk(tokens);\r\n\r\n    return result;\r\n\r\n    function walk(token: any) {\r\n        if (token instanceof Array) {\r\n            token.forEach(walk);\r\n        } else {\r\n            if (token instanceof Token) {\r\n                if (textToken) {\r\n                    textToken = textToken.concat(token);\r\n                } else {\r\n                    textToken = token;\r\n                    textNode = new TextNode();\r\n                    result.push(textNode);\r\n                }\r\n                textNode.data = textToken.value;\r\n                textNode.loc = textToken.loc;\r\n                return;\r\n            }\r\n            textNode = textToken = null;\r\n            result.push(token);\r\n        }\r\n    }\r\n}\r\n\r\nfunction collectChildNodes(tokens: Array<any>) {\r\n    const nodes = tokens.pop();\r\n    tokens.push(\r\n        useKey(\r\n            \"childNodes\",\r\n            nodes instanceof Array\r\n                ? formatTokens(nodes.slice(1, -1))\r\n                : []\r\n        )\r\n    );\r\n    return tokens;\r\n}\r\n\r\nfunction collectTagName(tokens: Array<any>) {\r\n    tokens.splice(0, 2, useKey(\"tagName\", tokens[1].value.toUpperCase()))\r\n    return tokens;\r\n}\r\n"],"names":["FINISH","WRAP","UNWRAP","UNWRAP_ALL","OPTION","SPLIT","NO_COLLECT","NO_CAPTURE","MARK_AS_ROOT","FORK_IN_PARENT","FORK_IN_ROOT","END","END_ON_LEFT","useKey","node","key","pick","hook","pipe","prev","merge","MATCH_BEGIN","MATCH_END","MATCH_EOF","MERGE_ALL_TOKENS","UNFOLD","OPERATIONS","MATCH_WHITE_SPACE_CHARACHER","CLEAR_COMMENT","CLEAR_WHITE_SPACE_CHARACHER","TEST_KEYWORD_BOUNDARY","NODE_LIST","tokens","filter","token","Token","THROW_TOKEN_ERROR","Wrapper","env","start","end","console","log","MATCH_STRING","MATCH_CSS_ATTRIBUTE_VALUE","MATCH_CSS_ATTRIBUTE","value","CSSStyleRule","trim","undefined","CSSMediaRule","length","match","index","CSSKeyframesRule","CSSFontFaceRule","CSSSupportsRule","SCOPE","MARKS","Hook","mode","Node","constructor","type","map","useContent","super","this","NODE_MAP","eval","use","hookPoint","loc","addItem","item","content","push","splice","walk","Array","forEach","UseKey","Key","Merge","Prev","onlyToken","res","slice","Pipe","Pick","Call","NoCapture","offset","line","column","String","toString","val","fn","reduce","concat","ROOT","RESOLVE","TYPE","ROLL","PARENT","COLLECT","BUBBING_HOOKS","CAPTURING_HOOKS","SLICE_HOOKS","IGNORE_TESTS","RESOLVE_TYPE_SET","Set","Scanner","pattern","configure","useEscape","useFold","ignoreCase","scanTree","build","Object","assign","scan","options","resolveState","cpos","input","begin","matchPool","scopeStack","getPosition","hasEscape","isBegin","char","CURSOR","resolve","state","collect","toLowerCase","noResolve","pool","scopeNode","NODE","slices","hasBranch","hasScopeNode","shift","parent","splits","stackSize","backSteps","finallize","scope","USE_FOLD","pop","BACK_POINT","use_collect","startPos","len","hooks","sliceHooks","has","backPoint","beginPos","cursorPos","unshift","collectSlices","useHook","wrap","START","BEGIN","unwrap","cursor","i","next","found","beginIndex","endIndex","range","limit","RootStack","matchTree","nodes","bubbling_map","capturing_map","buildRule","buildKey","patterns","bubbleTable","captureTable","scopeChain","rsRule","ndepth","forkChain","setHook","maps","bubbleHooks","d","list","newNodes","newBubbleTable","newCaptureTable","addHook","h","create","test","captureHooks","getResolveNode","reverse","unwrapTokens","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","SELF_CLOSING_TAGS","MATCH_ATTRIBUTES","MATCH_TAG_END","MATCH_SCRIPT_TEXT","MATCH_SCRIPT_END","CSSScanner","MATCH_STYLE_END","TextNode","tagName","matchCustomTag","tagEnd","collectChildNodes","collectAttrs","collectTagName","attrs","getValue","formatTokens","result","textNode","textToken","data","toUpperCase"],"sourceRoot":""}