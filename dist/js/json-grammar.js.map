{"version":3,"file":"js/../js/json-grammar.js","mappings":"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","sources":["webpack://astry/./js/scanner.ts","webpack://astry/webpack/bootstrap","webpack://astry/./js/json-grammar.ts"],"sourcesContent":["\r\n\r\n\r\nexport {\r\n    Scanner, OPERATIONS, HOOK_MODE, IScanEnv,\r\n    IPattern, Token,\r\n    IPosition, ISourceLocation,\r\n    UseKey, unwrapTokens\r\n}\r\n\r\ntype IScanEnv = {\r\n    tokens: Array<any>,\r\n    input: string,\r\n    begin: number,\r\n    offset: number,\r\n    end: number,\r\n    line: number,\r\n    column: number,\r\n    useFold: boolean,\r\n    useEscape: boolean,\r\n    ignoreCase: boolean,\r\n    hookPoint: number, // 用于指定当前钩子方法目标 token 位置\r\n}\r\n\r\n\r\nconst enum HOOK_MODE {\r\n    RESOLVE = 0b1,\r\n    CAPTURE = 0b10,\r\n    PIPE = 0b100\r\n    //LEFT_ASSOCIATIVE = 0b101\r\n}\r\n\r\ninterface IPosition {\r\n    offset: number,\r\n    line: number,\r\n    column: number\r\n}\r\ninterface ISourceLocation {\r\n    start: IPosition,\r\n    end: IPosition\r\n}\r\n\r\n\r\ntype IPattern = Hook\r\n    | string\r\n    | String    // 用于在不占用 string 描述空间的基础上，清晰的定义一些操作指令\r\n    | Array<\r\n        string  //  单段字符串不需要在数组内也能简化的声明为一个分支\r\n        | Array<IPattern>    //  其他内容需要被数组包裹\r\n    > // Array 代表 Pattern 内的分支 Pattern\r\n\r\nabstract class Hook {\r\n    mode: HOOK_MODE = HOOK_MODE.RESOLVE;\r\n    abstract use(env: IScanEnv, start: IPosition, end: IPosition): any\r\n}\r\n\r\nclass Node extends Hook {\r\n    static NODE_MAP = {};\r\n    public Wrapper: any;\r\n    constructor(\r\n        public type: string,\r\n        public map?: (tokens: Array<any>, env: IScanEnv, start: IPosition, end: IPosition) => any,\r\n        private useContent?: boolean\r\n    ) {\r\n        super();\r\n        this.Wrapper = Node.NODE_MAP[type] || (\r\n            Node.NODE_MAP[type] = eval(\r\n                `(function ${type}(){this.type=\"${type}\";})`\r\n            )\r\n        );\r\n    }\r\n    use(env: IScanEnv, start: IPosition, end: IPosition) {\r\n\r\n        let { tokens, hookPoint } = env;\r\n\r\n        const node = new this.Wrapper();\r\n        node.loc = { start, end };\r\n        let addItem = function (item: UseKey) {\r\n            node[item.key] = item.value;\r\n        }\r\n        if (this.useContent) {\r\n            const content = node.content = [];\r\n            addItem = function (item: UseKey) {\r\n                content.push(item);\r\n            }\r\n        }\r\n        tokens = tokens.splice(hookPoint);\r\n        if (this.map) {\r\n            tokens = this.map(tokens, env, start, end) || tokens;\r\n        }\r\n        walk(tokens);\r\n        env.tokens.push(node);\r\n\r\n        function walk(token: any) {\r\n            if (token instanceof Array) {\r\n                token.forEach(walk);\r\n            } else if (token instanceof UseKey) {\r\n                addItem(token);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nclass UseKey {\r\n    constructor(public key: string, public value: any) { }\r\n}\r\n\r\nclass Key extends Hook {\r\n    static Wrapper = UseKey;\r\n    constructor(public key: string, public map?: (token: any, env: IScanEnv, start: IPosition, end: IPosition) => any) {\r\n        super();\r\n    }\r\n    use(env: IScanEnv, start: IPosition, end: IPosition) {\r\n        let { tokens, hookPoint } = env;\r\n        let token = tokens[hookPoint];\r\n        this.map && (token = this.map(token, env, start, end) || token);\r\n        tokens.splice(hookPoint, 1, new UseKey(this.key, token));\r\n    }\r\n}\r\n\r\nclass Merge extends Hook {\r\n    constructor(public map: (tokens: Array<any>, env: IScanEnv, start: IPosition, end: IPosition) => any) {\r\n        super();\r\n    }\r\n    use(env: IScanEnv, start: IPosition, end: IPosition) {\r\n        let { tokens, hookPoint } = env;\r\n\r\n        tokens.push(this.map(tokens.splice(hookPoint), env, start, end));\r\n    }\r\n}\r\n\r\nclass Prev extends Hook {\r\n    constructor(\r\n        public match?: (token: Token | any, env: IScanEnv) => number | boolean,\r\n        public onlyToken?: boolean\r\n    ) {\r\n        super();\r\n    }\r\n    use(env: IScanEnv) {\r\n\r\n        let { tokens, hookPoint } = env;\r\n        hookPoint -= 1;\r\n        let prev = tokens[hookPoint];\r\n        if (!this.onlyToken || prev instanceof Token) {\r\n            if (this.match) {\r\n                let res = this.match(prev, env);\r\n                if (res) {\r\n                    if (typeof res === \"number\" && res !== prev.value.length) {\r\n                        tokens.splice(\r\n                            hookPoint, 1,\r\n                            prev.slice(0, -res), prev.slice(-res)\r\n                        );\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            env.hookPoint -= 1;\r\n        }\r\n    }\r\n}\r\nclass Pipe extends Hook {\r\n    mode = HOOK_MODE.PIPE;\r\n    constructor(public pipe: (token: any, env: IScanEnv, start: IPosition, end: IPosition) => any) {\r\n        super();\r\n    }\r\n    use(env: IScanEnv, start: IPosition, end: IPosition) {\r\n        let { tokens, hookPoint } = env;\r\n        let res = this.pipe(tokens[hookPoint], env, start, end);\r\n        if (res !== undefined) {\r\n            tokens[hookPoint] = res;\r\n        } else {\r\n            tokens.splice(hookPoint, 1);\r\n        }\r\n    }\r\n}\r\nclass Pick extends Pipe {\r\n    mode = HOOK_MODE.RESOLVE;\r\n}\r\n\r\nclass Call extends Hook {\r\n    constructor(\r\n        public use: (env: IScanEnv, start: IPosition, end: IPosition) => any,\r\n        public mode: HOOK_MODE\r\n    ) {\r\n        super();\r\n    }\r\n}\r\nclass NoCapture extends Hook {\r\n    mode = HOOK_MODE.CAPTURE;\r\n    constructor() {\r\n        super()\r\n    }\r\n    use(env: IScanEnv, start: IPosition, end: IPosition) {\r\n        let { tokens, hookPoint } = env;\r\n        tokens.splice(hookPoint, 1);\r\n        if (start.offset < env.offset/*end.offset === env.offset*/) {\r\n            env.offset = start.offset;\r\n            env.line = start.line;\r\n            env.column = start.column;\r\n        }\r\n    }\r\n}\r\n\r\nnamespace OPERATIONS {\r\n    export const\r\n        FINISH = new String(\"FINISH\"),\r\n        WRAP = new String(\"WRAP\"),\r\n        UNWRAP = new String(\"UNWRAP\"),\r\n        UNWRAP_ALL = new String(\"UNWRAP_ALL\"),\r\n        OPTION = new String(\"OPTION\"),\r\n        SPLIT = new String(\"SPLIT\"),\r\n        NO_COLLECT = new String(\"NO_COLLECT\"),\r\n        NO_CAPTURE = new String(\"NO_CAPTURE\"),\r\n        MARK_AS_ROOT = new String(\"MARK_AS_ROOT\"),\r\n        FORK_IN_PARENT = new String(\"FORK_IN_PARENT\"),\r\n        FORK_IN_ROOT = new String(\"FORK_IN_ROOT\"),\r\n        END = new String(\"END\"),\r\n        END_ON_LEFT = new String(\"END_ON_LEFT\");\r\n\r\n    export const useKey = function (key: string | Token, value: any) {\r\n        return new UseKey(key.toString(), value);\r\n    }\r\n\r\n    export const\r\n        node = function (\r\n            val: string,\r\n            map?: (tokens: Array<any>, env: IScanEnv, start: IPosition, end: IPosition) => any,\r\n            useContent = false,\r\n            mode = HOOK_MODE.RESOLVE\r\n        ) {\r\n            const node = new Node(val, map, useContent);\r\n            node.mode = mode;\r\n            return node;\r\n        },\r\n        key = function (val: string, map?: (token: any, env: IScanEnv, start: IPosition, end: IPosition) => any) {\r\n            return new Key(val, map);\r\n        },\r\n        pick = function (map?: (token: any, env: IScanEnv, start: IPosition, end: IPosition) => any) {\r\n            return new Pick(map || function () { });\r\n        },\r\n        hook = function (fn: (env: IScanEnv, start: IPosition, end: IPosition) => void, mode = HOOK_MODE.RESOLVE) {\r\n            return new Call(fn, mode);\r\n        },\r\n        pipe = function (pipe?: (token: any, env: IScanEnv, start: IPosition, end: IPosition) => any) {\r\n            return new Pipe(pipe || function () { });\r\n        },\r\n        prev = function (match?: (token: Token | any, env: IScanEnv) => number | boolean, onlyToken?: boolean) {\r\n            return new Prev(match, onlyToken);\r\n        },\r\n        merge = function (\r\n            map: (tokens: Array<any>, env: IScanEnv, start: IPosition, end: IPosition) => any\r\n                = function (tokens) { return tokens; }\r\n        ) {\r\n            return new Merge(map);\r\n        };\r\n\r\n\r\n\r\n    export const\r\n        MATCH_BEGIN = \"\",\r\n        MATCH_END = \"\",\r\n        MATCH_EOF: IPattern = [[\"\", \"\"]],\r\n        MERGE_ALL_TOKENS = merge(\r\n            function (tokens: Array<Token>) {\r\n                return tokens.reduce((res, token) => res.concat(token));\r\n            }\r\n        ),\r\n        UNFOLD = hook(function (env) {\r\n            const { tokens, hookPoint } = env;\r\n            for (const item of tokens.splice(hookPoint)) {\r\n                if (item instanceof Array) {\r\n                    tokens.push(...item);\r\n                } else {\r\n                    tokens.push(item);\r\n                }\r\n            }\r\n        }, HOOK_MODE.RESOLVE);\r\n}\r\n\r\n\r\nnamespace MARKS {\r\n    export const\r\n        FINISH = OPERATIONS.FINISH,\r\n        END = OPERATIONS.END,\r\n        END_ON_LEFT = OPERATIONS.END_ON_LEFT,\r\n        UNWRAP = OPERATIONS.UNWRAP,\r\n        WRAP = OPERATIONS.WRAP,\r\n        ROOT = new String(\"ROOT\");\r\n\r\n\r\n    export const\r\n        RESOLVE = \"_RESOLVE_\",\r\n        TYPE = \"_TYPE_\",\r\n        ROLL = \"_ROLL_\",\r\n        PARENT = \"_PARENT_\",\r\n        COLLECT = \"_COLLECT_\",\r\n        BUBBING_HOOKS = \"_BUBBING_HOOKS_\",\r\n        CAPTURING_HOOKS = \"_CAPTURING_HOOKS_\",\r\n        SLICE_HOOKS = \"_SLICE_HOOKS_\",\r\n        IGNORE_TESTS = \"_IGNORE_TESTS_\";\r\n\r\n\r\n\r\n    export const RESOLVE_TYPE_SET: Set<String> = new Set([\r\n        OPERATIONS.FINISH,\r\n        OPERATIONS.END,\r\n        OPERATIONS.END_ON_LEFT,\r\n        OPERATIONS.UNWRAP,\r\n        OPERATIONS.UNWRAP_ALL,\r\n        OPERATIONS.WRAP,\r\n        ROOT    // 只是个占位\r\n    ]);\r\n}\r\n\r\nenum SCOPE {\r\n    NODE, START, CURSOR, BACK_POINT, USE_FOLD\r\n}\r\n\r\ninterface IScope {\r\n    [SCOPE.NODE]: any,\r\n    [SCOPE.START]: IPosition,\r\n    [SCOPE.CURSOR]: IPosition,\r\n    [SCOPE.BACK_POINT]: number,\r\n    [SCOPE.USE_FOLD]: boolean\r\n}\r\n\r\ntype ISlices = Array<[IPosition, Hook[]]>;\r\n\r\ntype IResolveState = [any, IPosition, ISlices, number];\r\n\r\n\r\nclass Scanner {\r\n\r\n    private scanTree: Record<string, any>;\r\n    public useEscape = false;\r\n    public useFold = true;\r\n    public ignoreCase = false;\r\n    constructor(\r\n        pattern: IPattern,\r\n        configure?: { useEscape?: boolean, useFold?: boolean, ignoreCase?: boolean }\r\n    ) {\r\n        this.scanTree = build(pattern);\r\n        configure && Object.assign(this, configure);\r\n    }\r\n\r\n    scan(options: IScanEnv | string) {\r\n        let env = typeof options === \"string\" ? {\r\n            tokens: [],\r\n            input: options,\r\n            begin: 0,\r\n            offset: 0,\r\n            end: options.length,\r\n            line: 1,\r\n            column: 1,\r\n            useFold: this.useFold,\r\n            useEscape: this.useEscape,\r\n            ignoreCase: this.ignoreCase,\r\n            hookPoint: 0\r\n        } : options;\r\n\r\n        let matchPool: Array<[any, ISlices]> = [];\r\n        let scopeStack: Array<IScope> = [[\r\n            this.scanTree,\r\n            getPosition(), getPosition(),\r\n            0, false\r\n        ]];\r\n        let resolveState: IResolveState;\r\n        let hasEscape = 0;\r\n        let isBegin = true;\r\n\r\n\r\n        let cpos: IPosition;\r\n        while (true) {\r\n\r\n            if (!hasEscape) {\r\n                // 如果启用 useEscape 模式，字符捕获焦点从可能的 \\ 号开始\r\n                cpos = getPosition();\r\n            }\r\n\r\n            let char: string;\r\n\r\n            if (!isBegin) {\r\n\r\n                if (env.offset >= env.end) {\r\n\r\n                    // 首个匹配符为 \"\" 则代表匹配每一轮的开始\r\n                    // 当前面存在匹配符，后面出现的单独的 \"\" 匹配符则代表匹配输入内容的结束\r\n                    // 如果仅匹配输入内容的结束，可以这样描述 : [\"\",\"\"]\r\n\r\n                    if (\r\n                        scopeStack[0][SCOPE.CURSOR].offset < cpos.offset\r\n                    ) {// 匹配扫描过程已结束\r\n                        if (match(\"\") || resolve()) {\r\n                            return env;\r\n                        }\r\n                        if (env.offset < env.end) {\r\n                            break;\r\n                        }\r\n                        matchPool.length = 0;\r\n                        match(\"\");\r\n                    }\r\n                    if (matchPool.length) {\r\n                        const state = resolveState;\r\n                        match(\"\", true);\r\n                        // 仅匹配 OPERATIONS.MATCH_EOF 的 [\"\",\"\"] \r\n                        // 排除 OPERATIONS.MATCH_BEGIN OPERATIONS.MATCH_END 的 \"\"\r\n                        if (state !== resolveState && resolve()) {\r\n                            return env;\r\n                        }\r\n                    }\r\n                    if (scopeStack[0][SCOPE.CURSOR].offset < cpos.offset) {\r\n                        collect(scopeStack[0][SCOPE.CURSOR], cpos, null);\r\n                    }\r\n                    break;\r\n                }\r\n\r\n                char = env.input[env.offset];\r\n                env.offset += 1;\r\n\r\n                switch (char) {\r\n                    case \"\\r\":\r\n                        if (env.input[env.offset] !== \"\\n\") {\r\n                            //env.column = 0;\r\n                            break;\r\n                        }\r\n                        // 将 \\r\\n 归类为 \\n 处理\r\n                        char = \"\\n\";\r\n                        env.offset += 1;\r\n                    case \"\\n\":\r\n                        env.line += 1;\r\n                        env.column = 0;\r\n                        break;\r\n                }\r\n                env.column += 1;\r\n                env.ignoreCase && (char = char.toLowerCase());\r\n\r\n                if (env.useEscape) {\r\n                    if (char === \"\\\\\") {\r\n                        hasEscape ^= 1;\r\n                        if (hasEscape) {\r\n                            continue;\r\n                        }\r\n                    } else if (hasEscape) {\r\n                        hasEscape = 0;\r\n                        char = \"\\\\\" + char;\r\n                    }\r\n                }\r\n            } else {\r\n                char = \"\";\r\n                isBegin = false;\r\n            }\r\n            if (match(char)) {\r\n                return env;\r\n            }\r\n        }\r\n\r\n        return env;\r\n\r\n\r\n        function getPosition(): IPosition {\r\n            return { offset: env.offset, line: env.line, column: env.column }\r\n        }\r\n\r\n        function match(key: string, noResolve?: boolean) {\r\n            const pool = matchPool;\r\n\r\n            matchPool = [];\r\n\r\n            let node: any;\r\n            let slices: ISlices;\r\n            let hasBranch: boolean;\r\n\r\n            while (true) {\r\n                if (pool.length) {\r\n                    [node, slices] = pool.shift();\r\n                } else if (!resolveState && node !== scopeStack[0][SCOPE.NODE]) {\r\n                    node = scopeStack[0][SCOPE.NODE];\r\n                    slices = null;\r\n                } else {\r\n                    break;\r\n                }\r\n                hasBranch = false;\r\n\r\n                resolveState = walk(node, slices)\r\n                    || node[MARKS.ROLL] && walk(node[MARKS.ROLL], slices)\r\n                    || resolveState;\r\n            }\r\n\r\n\r\n            if (!noResolve && matchPool.length === 0 && resolve()) {\r\n                return true;\r\n            }\r\n\r\n            function walk(parent: any, slices?: ISlices): IResolveState {\r\n                let node = parent[key];\r\n                if (!node) {\r\n                    return;\r\n                }\r\n                if (!slices) {\r\n                    slices = [[cpos, parent[MARKS.CAPTURING_HOOKS]]];\r\n                } else if (hasBranch) {\r\n                    slices = slices.slice();\r\n                }\r\n                hasBranch = true;\r\n\r\n                matchPool.push([node, slices]);\r\n                if (node[MARKS.CAPTURING_HOOKS]) {\r\n                    slices.push([getPosition(), node[MARKS.CAPTURING_HOOKS]]);\r\n                }\r\n\r\n                if (!node[MARKS.RESOLVE]) {\r\n                    return;\r\n                } else {\r\n                    node = node[MARKS.RESOLVE];\r\n                }\r\n                return [node, getPosition(), slices, scopeStack.length];\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        function resolve() {\r\n            if (!resolveState) {\r\n                return;\r\n            }\r\n\r\n            const [node, { offset, line, column }, splits, stackSize] = resolveState;\r\n            scopeStack.splice(0, scopeStack.length - stackSize);\r\n            env.offset = offset;\r\n            env.line = line;\r\n            env.column = column;\r\n\r\n            let backSteps = finallize(node, splits, true);\r\n            if (backSteps > 0) {\r\n                return true;\r\n            }\r\n\r\n            if (backSteps < 0) {\r\n                do {\r\n                    const scope = scopeStack.shift();\r\n                    let tokens = env.tokens;\r\n                    if (scope[SCOPE.USE_FOLD]) {\r\n                        (env.tokens = tokens.shift()).pop();\r\n                    } else {\r\n                        tokens.length = scope[SCOPE.BACK_POINT];\r\n                    }\r\n                } while (++backSteps < 0)\r\n            }\r\n            //rollback(res);\r\n            resolveState = null;\r\n            isBegin = true;\r\n        }\r\n\r\n        function finallize(node: any, slices: ISlices, use_collect?: boolean): number {\r\n\r\n            let type = node[MARKS.TYPE];\r\n\r\n            const scope = scopeStack[0];\r\n            const startPos = slices[0][0];\r\n            let len = env.tokens.length;\r\n\r\n            if (use_collect) {\r\n\r\n                let hooks: Array<Hook>;\r\n                let sliceHooks = node[MARKS.SLICE_HOOKS];\r\n                if (sliceHooks) {\r\n                    hooks = slices[0][1];\r\n                    hooks && (hooks = hooks.filter(item => sliceHooks.has(item)));\r\n                }\r\n                collect(scope[SCOPE.CURSOR], startPos, hooks);\r\n            }\r\n\r\n            if (type === MARKS.WRAP) {\r\n                return wrap(node, slices, use_collect);\r\n            }\r\n\r\n            const hookPoint = env.tokens.length;\r\n\r\n            if (use_collect && type !== MARKS.END_ON_LEFT) {\r\n                let res = collectSlices(slices, node[MARKS.SLICE_HOOKS]);\r\n                if (res < 0) {\r\n                    env.tokens.length = len;\r\n                    return res + 1;\r\n                }\r\n            }\r\n            env.hookPoint = hookPoint;\r\n\r\n            if (type === MARKS.UNWRAP) {\r\n                return unwrap(node, slices);\r\n            } else {\r\n                let res = useHook(node[MARKS.BUBBING_HOOKS], startPos, getPosition());\r\n                if (res < 0) {\r\n                    env.tokens.length = len;\r\n                    return res + 1;\r\n                }\r\n                if (type !== MARKS.END_ON_LEFT) {\r\n                    scope[SCOPE.CURSOR] = getPosition();\r\n                } else {\r\n                    env.offset = startPos.offset;\r\n                    env.line = startPos.line;\r\n                    env.column = startPos.column;\r\n                    scope[SCOPE.CURSOR] = startPos;\r\n                    return 1;\r\n                }\r\n                return type !== MARKS.END ? res : 1;\r\n            }\r\n\r\n        }\r\n\r\n\r\n        function wrap(node: any, slices: ISlices, use_collect?: boolean) {\r\n            const { useFold, tokens } = env;\r\n            const backPoint = tokens.length;\r\n            let startPos = slices[0][0];\r\n\r\n            scopeStack.unshift([\r\n                node,\r\n                startPos, getPosition(),\r\n                backPoint, useFold\r\n            ]);\r\n\r\n            if (useFold) {\r\n                env.tokens = [tokens];\r\n                env.hookPoint = 1;\r\n            }\r\n\r\n\r\n            let backSteps = use_collect ? collectSlices(\r\n                slices,\r\n                node[MARKS.SLICE_HOOKS]\r\n            ) : 0;\r\n\r\n            if (backSteps >= 0) {\r\n                backSteps = useHook(node[MARKS.BUBBING_HOOKS], startPos, getPosition());\r\n                if (backSteps >= 0) {\r\n                    node = node[MARKS.RESOLVE];\r\n                    return node ? finallize(node, slices, false) : backSteps;\r\n                }\r\n            }\r\n            return backSteps;\r\n        }\r\n\r\n\r\n        function unwrap(node: any, slices: ISlices) {\r\n\r\n            const scope = scopeStack.shift();\r\n\r\n            if (scope[SCOPE.USE_FOLD]) {\r\n                let tokens = env.tokens.shift()\r\n                env.hookPoint = tokens.length;\r\n                tokens.push(env.tokens);\r\n                env.tokens = tokens;\r\n            }\r\n\r\n            let backSteps = useHook(\r\n                node[MARKS.BUBBING_HOOKS],\r\n                scope[SCOPE.START],\r\n                getPosition()\r\n            );\r\n            if (backSteps >= 0) {\r\n                node = node[MARKS.RESOLVE];\r\n\r\n                scopeStack[0][SCOPE.CURSOR] = getPosition();\r\n                if (node) {\r\n                    backSteps = finallize(node, slices, false);\r\n                    if (backSteps >= 0) {\r\n                        return backSteps;\r\n                    }\r\n                } else {\r\n                    return backSteps;\r\n                }\r\n            }\r\n            scopeStack.unshift(scope);\r\n            if (scope[SCOPE.USE_FOLD]) {\r\n                let tokens = env.tokens.pop();\r\n\r\n                tokens.unshift(env.tokens);\r\n                env.tokens = tokens;\r\n            }\r\n            return backSteps + 1;\r\n        }\r\n\r\n        function useHook(hooks: Array<Hook>, start: IPosition, end: IPosition): number {\r\n            for (const hook of hooks) {\r\n                let res = hook.use(env, start, end);\r\n                if (res < 0) {\r\n                    return res;\r\n                }\r\n            }\r\n            return 0;\r\n        }\r\n\r\n        function collect(start: IPosition, end: IPosition, hooks: Array<Hook>) {\r\n            let res: any = 0;\r\n            if (start.offset < end.offset) {\r\n                let { tokens } = env;\r\n                env.hookPoint = tokens.length;\r\n                tokens.push(\r\n                    new Token(\r\n                        env.input.slice(start.offset, end.offset),\r\n                        start,\r\n                        end\r\n                    )\r\n                );\r\n                if (hooks) {\r\n                    res = useHook(hooks, start, end);\r\n                }\r\n            }\r\n            return res;\r\n        }\r\n\r\n        function collectSlices(\r\n            slices: ISlices,\r\n            sliceHooks: Set<Hook>\r\n        ) {\r\n            let cursor = slices[0][0];\r\n            if (sliceHooks) {\r\n                for (let i = 1; i < slices.length; i += 1) {\r\n                    let [next, hooks] = slices[i];\r\n                    hooks = hooks.filter(item => sliceHooks.has(item));\r\n                    if (hooks.length) {\r\n                        const res = collect(cursor, next, hooks);\r\n                        if (res < 0) {\r\n                            return res;\r\n                        }\r\n                        cursor = next;\r\n                    }\r\n                }\r\n            }\r\n            return collect(cursor, getPosition(), null);\r\n        }\r\n    }\r\n}\r\n\r\n\r\nclass Token {\r\n\r\n    loc: ISourceLocation;\r\n\r\n    constructor(public value: string, start: IPosition, end: IPosition) {\r\n        this.loc = { start, end };\r\n    }\r\n    trim() {\r\n        const found = this.value.match(/^\\s*|\\s*$/gm);\r\n        return this.slice(found[0].length, this.value.length - found[1].length);\r\n    }\r\n    concat(token: Token) {\r\n        return new Token(this.value + token.value, this.loc.start, token.loc.end);\r\n    }\r\n    slice(beginIndex: number, endIndex = this.value.length) {\r\n        let { value, loc: { start, end } } = this;\r\n        let { offset, line, column } = start;\r\n        let index = 0;\r\n\r\n        if (endIndex < 0) {\r\n            endIndex = value.length + endIndex;\r\n        }\r\n        if (beginIndex < 0) {\r\n            beginIndex = value.length + beginIndex;\r\n        }\r\n        if (beginIndex > endIndex) {\r\n            endIndex = beginIndex;\r\n        }\r\n        const range = [beginIndex, endIndex].map(\r\n            function (limit): IPosition {\r\n                if (limit === 0) {\r\n                    return start;\r\n                }\r\n                if (limit === value.length) {\r\n                    return end;\r\n                }\r\n                while (index < limit) {\r\n                    if (value[index] === \"\\n\") {\r\n                        line += 1;\r\n                        column = 1;\r\n                    } else {\r\n                        column += 1;\r\n                    }\r\n                    index += 1;\r\n                }\r\n                return { offset: offset + limit, line, column }\r\n            }\r\n        )\r\n        return new Token(value.slice(beginIndex, endIndex), range[0], range[1]);\r\n    }\r\n    toString() {\r\n        return this.value;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\ntype HookStack = Array<Hook | HookStack | RootStack>;\r\ntype HookList = Array<Hook>;\r\n\r\nclass RootStack extends Array<Hook | HookStack> { }\r\n\r\ntype BubbleTable = Array<HookStack>;\r\ntype CaptureTable = Array<HookList>;\r\ntype BuildResult = [Array<any>, BubbleTable, CaptureTable];\r\n\r\nfunction build(pattern: IPattern): Record<string, any> {\r\n    const matchTree = { [MARKS.TYPE]: MARKS.ROOT };\r\n    const [nodes, bubbling_map, capturing_map] = buildRule(\r\n        [pattern],\r\n        [matchTree],\r\n        [[new RootStack()]],\r\n        [[]],\r\n        [matchTree]\r\n    );\r\n    for (let i = 0; i < nodes.length; i += 1) {\r\n        // 被省去 MARKS.FINISH 的描述自动补全\r\n        const node = nodes[i];\r\n        if (!MARKS.RESOLVE_TYPE_SET.has(node[MARKS.TYPE])) {\r\n            buildKey(MARKS.FINISH, [node], [bubbling_map[i]], [capturing_map[i]]);\r\n        }\r\n    }\r\n    return matchTree;\r\n}\r\n\r\n\r\nfunction buildRule(\r\n    patterns: Array<IPattern>,\r\n    nodes: Array<any>,\r\n    bubbleTable: BubbleTable,\r\n    captureTable: CaptureTable,\r\n    scopeChain: Array<any>\r\n): BuildResult {\r\n\r\n    const rsRule: Array<IPattern> = [];\r\n    let index = 0;\r\n    let key: IPattern;\r\n    while (index < patterns.length) {\r\n        let ndepth = 0, begin = index;\r\n        const forkChain: Array<number | String> = [];\r\n\r\n        while (true) {\r\n            if (patterns[index] === OPERATIONS.FORK_IN_ROOT) {\r\n                if (ndepth) {\r\n                    forkChain.push(ndepth);\r\n                    ndepth = 0;\r\n                }\r\n                forkChain.push(OPERATIONS.FORK_IN_ROOT);\r\n            } else if (patterns[index] === OPERATIONS.FORK_IN_PARENT) {\r\n                ndepth += 1;\r\n            } else {\r\n                break;\r\n            }\r\n            index += 1;\r\n        }\r\n\r\n        if (index !== begin) {\r\n            ndepth && forkChain.push(ndepth);\r\n\r\n            for (let node of nodes) {\r\n                let parent: any = node;\r\n                let cursor = 0;\r\n                for (let d of forkChain) {\r\n                    if (d === OPERATIONS.FORK_IN_ROOT) {\r\n                        parent = scopeChain[cursor++];\r\n                    } else {\r\n                        do {\r\n                            parent = parent[MARKS.PARENT];\r\n                            if (parent === scopeChain[cursor]) {\r\n                                cursor += 1;\r\n                            }\r\n                        } while (--(<number>d) >= 0)\r\n                    }\r\n                }\r\n                if (node[MARKS.ROLL] !== parent) {\r\n                    if (node[MARKS.ROLL]) {\r\n                        debugger;   // 暂不支持一个匹配路径存在多个 FORK 匹配（用不到）\r\n                    }\r\n                    node[MARKS.ROLL] = parent;\r\n                }\r\n            }\r\n            continue;\r\n        }\r\n\r\n        switch (key = patterns[index]) {\r\n            case OPERATIONS.NO_CAPTURE:\r\n            case OPERATIONS.NO_COLLECT:\r\n                rsRule.push(key);\r\n            case OPERATIONS.SPLIT:\r\n                setHook(null);\r\n                break;\r\n\r\n            case OPERATIONS.OPTION:\r\n                return walk(\r\n                    [\r\n                        rsRule.concat(patterns.slice(index + 1)),\r\n                        rsRule.concat(patterns.slice(index + 2))\r\n                    ],\r\n                    function (pattern) {\r\n                        return buildRule(\r\n                            pattern,\r\n                            nodes,\r\n                            bubbleTable.map(hooks => hooks.slice()),\r\n                            captureTable.map(maps => maps.slice()),\r\n                            scopeChain\r\n                        )\r\n                    }\r\n                );\r\n\r\n            case OPERATIONS.MARK_AS_ROOT:\r\n                patterns = rsRule.concat(patterns.slice(index + 1));\r\n                return walk(nodes, function (node, index) {\r\n                    const bubbleHooks = bubbleTable[index];\r\n                    return buildRule(\r\n                        patterns,\r\n                        [node],\r\n                        [[new RootStack(...<HookStack>bubbleHooks[0])].concat(bubbleHooks.slice(1))],\r\n                        [captureTable[index]],\r\n                        [node].concat(scopeChain)\r\n                    )\r\n                });\r\n            default:\r\n                if (key instanceof Hook) {\r\n                    setHook(key);\r\n                } else {\r\n                    if (key instanceof Array) {\r\n                        [nodes, bubbleTable, captureTable] = walk(key, function (item) {\r\n                            return (item instanceof Array ? buildRule : buildKey)(\r\n                                item, nodes,\r\n                                bubbleTable.map(hooks => hooks.slice()),\r\n                                captureTable.map(maps => maps.slice()),\r\n                                scopeChain\r\n                            )\r\n                        })\r\n                    } else {\r\n                        [nodes, bubbleTable, captureTable] = buildKey(key, nodes, bubbleTable, captureTable);\r\n                    }\r\n                    while (rsRule.length) {\r\n                        setHook(\r\n                            rsRule.shift() === OPERATIONS.NO_COLLECT\r\n                                ? OPERATIONS.pipe()\r\n                                : new NoCapture()\r\n                        );\r\n                    }\r\n                }\r\n                break;\r\n        }\r\n\r\n        index += 1;\r\n    }\r\n\r\n    return [nodes, bubbleTable, captureTable];\r\n\r\n\r\n    function walk(\r\n        list: Array<any>,\r\n        next: (item: any, index: number) => BuildResult\r\n    ): BuildResult {\r\n\r\n        let newNodes: Array<any> = [];\r\n        let newBubbleTable: Array<HookStack> = [];\r\n        let newCaptureTable: Array<any[]> = [];\r\n\r\n        for (let i = 0; i < list.length; i += 1) {\r\n            const res = next(list[i], i);\r\n            newNodes = newNodes.concat(res[0]);\r\n            newBubbleTable = newBubbleTable.concat(res[1]);\r\n            newCaptureTable = newCaptureTable.concat(res[2]);\r\n        }\r\n\r\n\r\n        return [newNodes, newBubbleTable, newCaptureTable];\r\n\r\n    }\r\n    function setHook(hook: Hook) {\r\n        if (hook === window.test) {\r\n            debugger;\r\n        }\r\n        if (!hook) {\r\n            hook = new Call(function () { }, HOOK_MODE.CAPTURE);\r\n            for (let i = 0; i < nodes.length; i += 1) {\r\n                MARKS.RESOLVE_TYPE_SET.has(nodes[i][MARKS.TYPE]) || addHook(i);\r\n            }\r\n            return;\r\n        }\r\n        switch (hook.mode) {\r\n            case HOOK_MODE.RESOLVE:\r\n                bubbleTable.forEach(hooks => hooks.push(<Hook>key));\r\n                break;\r\n            case HOOK_MODE.PIPE:\r\n            case HOOK_MODE.CAPTURE:\r\n                for (let i = 0; i < nodes.length; i += 1) {\r\n                    addHook(i);\r\n                }\r\n                break;\r\n        }\r\n        function addHook(index: number) {\r\n            const node = nodes[index];\r\n            const type = node[MARKS.TYPE];\r\n            if (hook.mode !== HOOK_MODE.PIPE && MARKS.RESOLVE_TYPE_SET.has(type)) {\r\n                node[MARKS.BUBBING_HOOKS].push(hook);\r\n            } else {\r\n                (\r\n                    node[MARKS.CAPTURING_HOOKS]\r\n                    || (node[MARKS.CAPTURING_HOOKS] = [])\r\n                ).push(hook);\r\n                captureTable[index].push(hook);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\nfunction buildKey(\r\n    key: any,\r\n    nodes: Array<any>,\r\n    bubbleTable: BubbleTable,\r\n    captureTable: CaptureTable,\r\n    scopeChain?: Array<any>\r\n): BuildResult {\r\n    if (typeof key === \"string\") {\r\n        if (/^[\\s\\S]?$/.test(key)) {\r\n            key = [key];\r\n        }\r\n        for (let i = 0; i < key.length; i += 1) {\r\n            nodes = nodes.map(function (node) {\r\n                return node[key[i]] || (node[key[i]] = { [MARKS.PARENT]: node });\r\n            });\r\n        }\r\n    } else if (MARKS.RESOLVE_TYPE_SET.has(key)) {\r\n\r\n        nodes = nodes.map(function (node, i) {\r\n\r\n            let bubbleHooks: HookStack = bubbleTable[i];\r\n            let captureHooks = captureTable[i];\r\n            captureTable[i] = [];\r\n\r\n            if (key === OPERATIONS.UNWRAP_ALL) {\r\n                key = OPERATIONS.UNWRAP;\r\n                if (!(bubbleHooks[0] instanceof RootStack)) {\r\n                    if (bubbleHooks.length > 1) {\r\n                        bubbleHooks[0] = (<HookStack>bubbleHooks[0]).concat(bubbleHooks.slice(1));\r\n                    }\r\n                    do {\r\n                        bubbleTable[i] = [bubbleHooks[0][0]];\r\n                        bubbleHooks = <HookStack>bubbleHooks[0];\r\n\r\n                        node = getResolveNode(node, key, bubbleHooks, captureHooks);\r\n                    } while (!(bubbleHooks[0] instanceof RootStack))\r\n                }\r\n            } else {\r\n                if (key === OPERATIONS.UNWRAP) {\r\n                    bubbleTable[i] = [bubbleHooks[0][0]];\r\n                    bubbleHooks = (<HookStack>bubbleHooks[0]).concat(bubbleHooks.slice(1));\r\n                } else if (key === OPERATIONS.WRAP) {\r\n                    bubbleTable[i] = [bubbleHooks];\r\n                    bubbleHooks = [];\r\n                } else {\r\n                    bubbleTable[i] = [bubbleHooks[0]];\r\n                }\r\n\r\n                node = getResolveNode(node, key, bubbleHooks, captureHooks);\r\n\r\n            }\r\n            return node;\r\n        });\r\n\r\n    } else {\r\n        debugger;\r\n    }\r\n    return [nodes, bubbleTable, captureTable];\r\n\r\n    function getResolveNode(\r\n        node: any, type: string,\r\n        bubbleHooks: HookStack, sliceHooks: HookList\r\n    ) {\r\n        if (node[MARKS.RESOLVE]) {\r\n            // 如果存在重复定义的 pattern 则这里会执行\r\n            debugger;\r\n        }\r\n        return node[MARKS.RESOLVE] = {\r\n            [MARKS.PARENT]: node,\r\n            [MARKS.TYPE]: type,\r\n            [MARKS.SLICE_HOOKS]: sliceHooks.length\r\n                ? new Set(sliceHooks.splice(0))\r\n                : null,\r\n            [MARKS.BUBBING_HOOKS]: bubbleHooks.slice(1).reverse()\r\n        };\r\n    }\r\n\r\n}\r\n\r\nfunction unwrapTokens(tokens: any) {\r\n    if (tokens instanceof Token) {\r\n        return tokens.value;\r\n    }\r\n    if (tokens instanceof Array) {\r\n        return tokens.map(unwrapTokens);\r\n    }\r\n    return tokens;\r\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\r\nimport {\r\n    Scanner, OPERATIONS, HOOK_MODE, IScanEnv,\r\n    IPattern, Token,\r\n    IPosition, ISourceLocation,\r\n} from \"./scanner\"\r\n\r\n\r\nconst {\r\n    FINISH,\r\n    WRAP, UNWRAP, UNWRAP_ALL,\r\n    OPTION,\r\n    SPLIT,\r\n    NO_COLLECT, NO_CAPTURE,\r\n    MARK_AS_ROOT, FORK_IN_PARENT, FORK_IN_ROOT,\r\n    END, END_ON_LEFT,\r\n    useKey,\r\n    node, key, pick, hook, pipe, prev, merge,\r\n\r\n    MATCH_BEGIN,\r\n    MATCH_END,\r\n    MATCH_EOF,\r\n    MERGE_ALL_TOKENS\r\n} = OPERATIONS;\r\n\r\nconst TEST_KEYWORD_BOUNDARY = [\r\n    [NO_CAPTURE, [\"\", \" \", \"\\n\", `\\t`, \",\", \"(\", \")\", \"{\", \"}\", \":\", \"[\", \"]\"]]\r\n];\r\nconst THROW_TOKEN_ERROR = hook(function (env, start, end) {\r\n    console.log(\"Invalid or unexpected token\", start, end);\r\n}, HOOK_MODE.RESOLVE);\r\n\r\nconst LITERAL_VALUE_MAP = { true: true, false: false, null: null };\r\nconst COLLECT_STRING = [\r\n    [\r\n        pick(function (tokens, env, start, end) {\r\n            return [env.input.slice(start.offset, end.offset), tokens[1].value];\r\n        }),\r\n        `\"`,\r\n        hook(function (env) {\r\n            env.useEscape = true;\r\n        }, HOOK_MODE.CAPTURE),\r\n        WRAP,\r\n        [\r\n            [THROW_TOKEN_ERROR, \"\\n\"],\r\n            [\r\n                `\"`,\r\n                hook(function (env) {\r\n                    env.useEscape = false;\r\n                }, HOOK_MODE.CAPTURE),\r\n                UNWRAP,\r\n            ]\r\n        ]\r\n    ]\r\n];\r\n\r\n\r\nconst MATCH_WHITE_SPACE_CHARACHER = [` `, `\\n`, `\\t`];\r\n\r\nconst CLEAR_WHITE_SPACE_CHARACHER = [\r\n    [NO_COLLECT, MATCH_WHITE_SPACE_CHARACHER]\r\n];\r\n\r\nconst Literal = node(\"Literal\").Wrapper;\r\n\r\nconst PARSE_NUMBER_LITERAL = pipe(\r\n    function (token: Token, env, start, end) {\r\n        let value: any = token.value;\r\n        const result: any = /^(-?[1-9][0-9]*|0)(.[0-9]+)?([eE][-+]?[0-9]+)?$/g.exec(value);\r\n        if (result) {\r\n            const [, int, frac, exp] = result;\r\n            value = int | 0;\r\n            frac && (value += frac % 1);\r\n            exp && (value *= Math.pow(10, exp.slice(1) | 0));\r\n        } else {\r\n            debugger;\r\n        }\r\n        return Object.assign(   //  Number(value)\r\n            new Literal(),\r\n            { raw: token.value, value: value, loc: { start, end } }\r\n        );\r\n    } ,\r\n);\r\n\r\n\r\nexport default <IPattern>[\r\n    [PARSE_NUMBER_LITERAL, CLEAR_WHITE_SPACE_CHARACHER],\r\n    [\r\n        node(\"Literal\", function ([[raw, value]]: any) {\r\n            return [\r\n                useKey(\"raw\", raw),\r\n                useKey(\"value\", value)\r\n            ];\r\n        }),\r\n        [\r\n            [COLLECT_STRING],\r\n            [\r\n                pick(function ({ value }: Token) {\r\n                    return [value, LITERAL_VALUE_MAP[value]]\r\n                }),\r\n                \"\",\r\n                [\"true\", \"false\", \"null\"]\r\n                , TEST_KEYWORD_BOUNDARY\r\n            ]\r\n        ]\r\n    ],\r\n    [\r\n        node(\"Object\", function ([tokens]: [Array<any>]) {\r\n            return useKey(\"children\", tokens.filter(\r\n                function (token) {\r\n                    if (token instanceof Token) {\r\n                        debugger;\r\n                        return false;\r\n                    }\r\n                    return true;\r\n                }\r\n            ));\r\n        }),\r\n        NO_COLLECT, \"{\", WRAP,\r\n        [\r\n            [NO_COLLECT, \"}\", UNWRAP],\r\n            [CLEAR_WHITE_SPACE_CHARACHER],\r\n            [\r\n                node(\"Identifier\", function ([[raw, value]]: any) {\r\n                    return [\r\n                        useKey(\"value\", value),\r\n                        useKey(\"raw\", raw)\r\n                    ]\r\n                }),\r\n                COLLECT_STRING,\r\n                node(\"Property\", function ([key, [value]]) {\r\n                    const props = [useKey(\"key\", key)];\r\n                    if (value.length === 1 && !(value[0] instanceof Token)) {\r\n                        props.push(useKey(\"value\", value[0]));\r\n                    } else {\r\n                        debugger;\r\n                    }\r\n                    return props;\r\n                }),\r\n                prev(),\r\n                WRAP,\r\n                [\r\n                    [CLEAR_WHITE_SPACE_CHARACHER],\r\n                    [\r\n                        NO_COLLECT, \":\", WRAP,\r\n                        FORK_IN_ROOT,\r\n                        PARSE_NUMBER_LITERAL,\r\n                        [\r\n                            [NO_CAPTURE, \"}\", UNWRAP, UNWRAP],\r\n                            [NO_COLLECT, \",\", UNWRAP, UNWRAP],\r\n                        ]\r\n                    ]\r\n                ]\r\n            ]\r\n        ]\r\n    ],\r\n    [\r\n        node(\"Array\", function ([tokens]: [Array<any>]) {\r\n            const children = [];\r\n            for (let i = 0, len = tokens.length; i < len; i += 2) {\r\n                let value = tokens[i];\r\n                let spearator = tokens[i + 1];\r\n                if (!spearator || (spearator.value === \",\" && i < len - 2)) {\r\n                    if (!(value instanceof Token)) {\r\n                        children.push(value);\r\n                        continue;\r\n                    }\r\n                }\r\n                debugger;\r\n                break;\r\n            }\r\n            return useKey(\"children\", children);\r\n        }),\r\n        NO_COLLECT, \"[\", WRAP,\r\n        FORK_IN_ROOT,\r\n        PARSE_NUMBER_LITERAL,\r\n        [\r\n            [NO_COLLECT, \"]\", UNWRAP],\r\n            [\",\"]\r\n        ]\r\n    ]\r\n];\r\n\r\n\r\n"],"names":["Hook","mode","Node","constructor","type","map","useContent","super","this","Wrapper","NODE_MAP","eval","use","env","start","end","tokens","hookPoint","node","loc","addItem","item","key","value","content","push","splice","walk","token","Array","forEach","UseKey","Key","Merge","Prev","match","onlyToken","prev","Token","res","length","slice","Pipe","pipe","undefined","Pick","Call","NoCapture","offset","line","column","OPERATIONS","MARKS","SCOPE","FINISH","String","WRAP","UNWRAP","UNWRAP_ALL","OPTION","SPLIT","NO_COLLECT","NO_CAPTURE","MARK_AS_ROOT","FORK_IN_PARENT","FORK_IN_ROOT","END","END_ON_LEFT","useKey","toString","val","pick","hook","fn","merge","MATCH_BEGIN","MATCH_END","MATCH_EOF","MERGE_ALL_TOKENS","reduce","concat","UNFOLD","ROOT","RESOLVE","TYPE","ROLL","PARENT","COLLECT","BUBBING_HOOKS","CAPTURING_HOOKS","SLICE_HOOKS","IGNORE_TESTS","RESOLVE_TYPE_SET","Set","Scanner","pattern","configure","useEscape","useFold","ignoreCase","scanTree","build","Object","assign","scan","options","resolveState","cpos","input","begin","matchPool","scopeStack","getPosition","hasEscape","isBegin","char","CURSOR","resolve","state","collect","toLowerCase","noResolve","pool","slices","hasBranch","shift","NODE","parent","splits","stackSize","backSteps","finallize","scope","USE_FOLD","pop","BACK_POINT","use_collect","startPos","len","hooks","sliceHooks","filter","has","backPoint","unshift","collectSlices","useHook","wrap","START","unwrap","cursor","i","next","trim","found","beginIndex","endIndex","index","range","limit","RootStack","matchTree","nodes","bubbling_map","capturing_map","buildRule","buildKey","patterns","bubbleTable","captureTable","scopeChain","rsRule","ndepth","forkChain","setHook","maps","bubbleHooks","d","list","newNodes","newBubbleTable","newCaptureTable","window","test","addHook","captureHooks","getResolveNode","reverse","unwrapTokens","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","TEST_KEYWORD_BOUNDARY","THROW_TOKEN_ERROR","console","log","LITERAL_VALUE_MAP","true","false","null","COLLECT_STRING","CLEAR_WHITE_SPACE_CHARACHER","Literal","PARSE_NUMBER_LITERAL","result","exec","int","frac","exp","Math","pow","raw","props","children","spearator"],"sourceRoot":""}