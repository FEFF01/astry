{"version":3,"file":"js/../js/json-grammar.js","mappings":"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","sources":["webpack://astry/./js/scanner.ts","webpack://astry/webpack/bootstrap","webpack://astry/./js/json-grammar.ts"],"sourcesContent":["\r\n\r\n\r\nexport {\r\n    Scanner, OPERATIONS, HOOK_MODE, IScanEnv,\r\n    IPattern, Token,\r\n    IPosition, ISourceLocation,\r\n    UseKey, unwrapTokens\r\n}\r\n\r\ntype IScanEnv = {\r\n    tokens: Array<any>,\r\n    input: string,\r\n    begin: number,\r\n    offset: number,\r\n    end: number,\r\n    line: number,\r\n    column: number,\r\n    useFold: boolean,\r\n    useEscape: boolean,\r\n    ignoreCase: boolean,\r\n    hookPoint: number, // 用于指定当前钩子方法目标 token 位置\r\n}\r\n\r\n\r\nconst enum HOOK_MODE {\r\n    RESOLVE = 0b1,\r\n    CAPTURE = 0b10,\r\n    PIPE = 0b100\r\n    //LEFT_ASSOCIATIVE = 0b101\r\n}\r\n\r\ninterface IPosition {\r\n    offset: number,\r\n    line: number,\r\n    column: number\r\n}\r\ninterface ISourceLocation {\r\n    start: IPosition,\r\n    end: IPosition\r\n}\r\n\r\n\r\ntype IPattern = Hook\r\n    | string\r\n    | String    // 用于在不占用 string 描述空间的基础上，清晰的定义一些操作指令\r\n    | Array<\r\n        string  //  单段字符串不需要在数组内也能简化的声明为一个分支\r\n        | Array<IPattern>    //  其他内容需要被数组包裹\r\n    > // Array 代表 Pattern 内的分支 Pattern\r\n\r\n\r\nenum SCOPE {\r\n    NODE, START, BEGIN, CURSOR, BACK_POINT, USE_FOLD\r\n}\r\n\r\n\r\ninterface IScope {\r\n    [SCOPE.NODE]: any,\r\n    [SCOPE.START]: IPosition,\r\n    [SCOPE.BEGIN]: IPosition,\r\n    [SCOPE.CURSOR]: IPosition,\r\n    [SCOPE.BACK_POINT]: number,\r\n    [SCOPE.USE_FOLD]: boolean\r\n}\r\n\r\ntype ISlices = Array<[IPosition, Hook[]]>;\r\n\r\ntype IResolveState = [any, IPosition, ISlices, number];\r\n\r\n\r\n\r\nabstract class Hook {\r\n    mode: HOOK_MODE = HOOK_MODE.RESOLVE;\r\n    abstract use(env: IScanEnv, start: IPosition, end: IPosition, begin: IPosition): any\r\n}\r\n\r\n\r\n\r\n\r\nclass Node extends Hook {\r\n    static NODE_MAP = {};\r\n    public Wrapper: any;\r\n    constructor(\r\n        public type: string,\r\n        public map?: (tokens: Array<any>, env: IScanEnv, start: IPosition, end: IPosition) => any,\r\n        private useContent?: boolean\r\n    ) {\r\n        super();\r\n        this.Wrapper = Node.NODE_MAP[type] || (\r\n            Node.NODE_MAP[type] = eval(\r\n                `(function ${type}(){this.type=\"${type}\";})`\r\n            )\r\n        );\r\n    }\r\n    use(env: IScanEnv, start: IPosition, end: IPosition) {\r\n\r\n        let { tokens, hookPoint } = env;\r\n\r\n        const node = new this.Wrapper();\r\n        node.loc = { start, end };\r\n        let addItem = function (item: UseKey) {\r\n            node[item.key] = item.value;\r\n        }\r\n        if (this.useContent) {\r\n            const content = node.content = [];\r\n            addItem = function (item: UseKey) {\r\n                content.push(item);\r\n            }\r\n        }\r\n        tokens = tokens.splice(hookPoint);\r\n        if (this.map) {\r\n            tokens = this.map(tokens, env, start, end) || tokens;\r\n        }\r\n        walk(tokens);\r\n        env.tokens.push(node);\r\n\r\n        function walk(token: any) {\r\n            if (token instanceof Array) {\r\n                token.forEach(walk);\r\n            } else if (token instanceof UseKey) {\r\n                addItem(token);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nclass UseKey {\r\n    constructor(public key: string, public value: any) { }\r\n}\r\n\r\nclass Key extends Hook {\r\n    static Wrapper = UseKey;\r\n    constructor(public key: string, public map?: (token: any, env: IScanEnv, start: IPosition, end: IPosition) => any) {\r\n        super();\r\n    }\r\n    use(env: IScanEnv, start: IPosition, end: IPosition) {\r\n        let { tokens, hookPoint } = env;\r\n        let token = tokens[hookPoint];\r\n        this.map && (token = this.map(token, env, start, end) || token);\r\n        tokens.splice(hookPoint, 1, new UseKey(this.key, token));\r\n    }\r\n}\r\n\r\nclass Merge extends Hook {\r\n    constructor(public map: (tokens: Array<any>, env: IScanEnv, start: IPosition, end: IPosition) => any) {\r\n        super();\r\n    }\r\n    use(env: IScanEnv, start: IPosition, end: IPosition) {\r\n        let { tokens, hookPoint } = env;\r\n\r\n        tokens.push(this.map(tokens.splice(hookPoint), env, start, end));\r\n    }\r\n}\r\n\r\nclass Prev extends Hook {\r\n    constructor(\r\n        public match?: (token: Token | any, env: IScanEnv) => number | boolean,\r\n        public onlyToken?: boolean\r\n    ) {\r\n        super();\r\n    }\r\n    use(env: IScanEnv) {\r\n\r\n        let { tokens, hookPoint } = env;\r\n        hookPoint -= 1;\r\n        let prev = tokens[hookPoint];\r\n        if (!this.onlyToken || prev instanceof Token) {\r\n            if (this.match) {\r\n                let res = this.match(prev, env);\r\n                if (res) {\r\n                    if (typeof res === \"number\" && res !== prev.value.length) {\r\n                        tokens.splice(\r\n                            hookPoint, 1,\r\n                            prev.slice(0, -res), prev.slice(-res)\r\n                        );\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            env.hookPoint -= 1;\r\n        }\r\n    }\r\n}\r\nclass Pipe extends Hook {\r\n    mode = HOOK_MODE.PIPE;\r\n    constructor(public pipe: (token: any, env: IScanEnv, start: IPosition, end: IPosition) => any) {\r\n        super();\r\n    }\r\n    use(env: IScanEnv, start: IPosition, end: IPosition) {\r\n        let { tokens, hookPoint } = env;\r\n        let res = this.pipe(tokens[hookPoint], env, start, end);\r\n        if (res !== undefined) {\r\n            tokens[hookPoint] = res;\r\n        } else {\r\n            tokens.splice(hookPoint, 1);\r\n        }\r\n    }\r\n}\r\nclass Pick extends Pipe {\r\n    mode = HOOK_MODE.RESOLVE;\r\n}\r\n\r\nclass Call extends Hook {\r\n    constructor(\r\n        public use: (env: IScanEnv, start: IPosition, end: IPosition, begin: IPosition) => any,\r\n        public mode: HOOK_MODE\r\n    ) {\r\n        super();\r\n    }\r\n}\r\nclass NoCapture extends Hook {\r\n    mode = HOOK_MODE.CAPTURE;\r\n    constructor() {\r\n        super()\r\n    }\r\n    use(env: IScanEnv, start: IPosition, end: IPosition) {\r\n        let { tokens, hookPoint } = env;\r\n        tokens.splice(hookPoint, 1);\r\n        if (start.offset < env.offset/*end.offset === env.offset*/) {\r\n            env.offset = start.offset;\r\n            env.line = start.line;\r\n            env.column = start.column;\r\n        }\r\n    }\r\n}\r\n\r\nnamespace OPERATIONS {\r\n    export const\r\n        FINISH = new String(\"FINISH\"),\r\n        WRAP = new String(\"WRAP\"),\r\n        UNWRAP = new String(\"UNWRAP\"),\r\n        UNWRAP_ALL = new String(\"UNWRAP_ALL\"),\r\n        OPTION = new String(\"OPTION\"),\r\n        SPLIT = new String(\"SPLIT\"),\r\n        NO_COLLECT = new String(\"NO_COLLECT\"),\r\n        NO_CAPTURE = new String(\"NO_CAPTURE\"),\r\n        MARK_AS_ROOT = new String(\"MARK_AS_ROOT\"),\r\n        FORK_IN_PARENT = new String(\"FORK_IN_PARENT\"),\r\n        FORK_IN_ROOT = new String(\"FORK_IN_ROOT\"),\r\n        END = new String(\"END\"),\r\n        END_ON_LEFT = new String(\"END_ON_LEFT\");\r\n\r\n    export const useKey = function (key: string | Token, value: any) {\r\n        return new UseKey(key.toString(), value);\r\n    }\r\n\r\n    export const\r\n        node = function (\r\n            val: string,\r\n            map?: (tokens: Array<any>, env: IScanEnv, start: IPosition, end: IPosition) => any,\r\n            useContent = false,\r\n            mode = HOOK_MODE.RESOLVE\r\n        ) {\r\n            const node = new Node(val, map, useContent);\r\n            node.mode = mode;\r\n            return node;\r\n        },\r\n        key = function (val: string, map?: (token: any, env: IScanEnv, start: IPosition, end: IPosition) => any) {\r\n            return new Key(val, map);\r\n        },\r\n        pick = function (map?: (token: any, env: IScanEnv, start: IPosition, end: IPosition) => any) {\r\n            return new Pick(map || function () { });\r\n        },\r\n        hook = function (fn: (env: IScanEnv, start: IPosition, end: IPosition, begin: IPosition) => void, mode = HOOK_MODE.RESOLVE) {\r\n            return new Call(fn, mode);\r\n        },\r\n        pipe = function (pipe?: (token: any, env: IScanEnv, start: IPosition, end: IPosition) => any) {\r\n            return new Pipe(pipe || function () { });\r\n        },\r\n        prev = function (match?: (token: Token | any, env: IScanEnv) => number | boolean, onlyToken?: boolean) {\r\n            return new Prev(match, onlyToken);\r\n        },\r\n        merge = function (\r\n            map: (tokens: Array<any>, env: IScanEnv, start: IPosition, end: IPosition) => any\r\n                = function (tokens) { return tokens; }\r\n        ) {\r\n            return new Merge(map);\r\n        };\r\n\r\n\r\n\r\n    export const\r\n        MATCH_BEGIN = \"\",\r\n        MATCH_END = \"\",\r\n        MATCH_EOF: IPattern = [[\"\", \"\"]],\r\n        MERGE_ALL_TOKENS = merge(\r\n            function (tokens: Array<Token>) {\r\n                return tokens.reduce((res, token) => res.concat(token));\r\n            }\r\n        ),\r\n        UNFOLD = hook(function (env) {\r\n            const { tokens, hookPoint } = env;\r\n            for (const item of tokens.splice(hookPoint)) {\r\n                if (item instanceof Array) {\r\n                    tokens.push(...item);\r\n                } else {\r\n                    tokens.push(item);\r\n                }\r\n            }\r\n        }, HOOK_MODE.RESOLVE);\r\n}\r\n\r\n\r\nnamespace MARKS {\r\n    export const\r\n        FINISH = OPERATIONS.FINISH,\r\n        END = OPERATIONS.END,\r\n        END_ON_LEFT = OPERATIONS.END_ON_LEFT,\r\n        UNWRAP = OPERATIONS.UNWRAP,\r\n        WRAP = OPERATIONS.WRAP,\r\n        ROOT = new String(\"ROOT\");\r\n\r\n\r\n    export const\r\n        RESOLVE = \"_RESOLVE_\",\r\n        TYPE = \"_TYPE_\",\r\n        ROLL = \"_ROLL_\",\r\n        PARENT = \"_PARENT_\",\r\n        COLLECT = \"_COLLECT_\",\r\n        BUBBING_HOOKS = \"_BUBBING_HOOKS_\",\r\n        CAPTURING_HOOKS = \"_CAPTURING_HOOKS_\",\r\n        SLICE_HOOKS = \"_SLICE_HOOKS_\",\r\n        IGNORE_TESTS = \"_IGNORE_TESTS_\";\r\n\r\n\r\n\r\n    export const RESOLVE_TYPE_SET: Set<String> = new Set([\r\n        OPERATIONS.FINISH,\r\n        OPERATIONS.END,\r\n        OPERATIONS.END_ON_LEFT,\r\n        OPERATIONS.UNWRAP,\r\n        OPERATIONS.UNWRAP_ALL,\r\n        OPERATIONS.WRAP,\r\n        ROOT    // 只是个占位\r\n    ]);\r\n}\r\n\r\nclass Scanner {\r\n\r\n    private scanTree: Record<string, any>;\r\n    public useEscape = false;\r\n    public useFold = true;\r\n    public ignoreCase = false;\r\n    constructor(\r\n        pattern: IPattern,\r\n        configure?: { useEscape?: boolean, useFold?: boolean, ignoreCase?: boolean }\r\n    ) {\r\n        this.scanTree = build(pattern);\r\n        configure && Object.assign(this, configure);\r\n    }\r\n\r\n    scan(options: IScanEnv | string) {\r\n        let env = typeof options === \"string\" ? {\r\n            tokens: [],\r\n            input: options,\r\n            begin: 0,\r\n            offset: 0,\r\n            end: options.length,\r\n            line: 1,\r\n            column: 1,\r\n            useFold: this.useFold,\r\n            useEscape: this.useEscape,\r\n            ignoreCase: this.ignoreCase,\r\n            hookPoint: 0\r\n        } : options;\r\n\r\n        let matchPool: Array<[any, ISlices]> = [];\r\n        let scopeStack: Array<IScope> = [[\r\n            this.scanTree,\r\n            getPosition(), getPosition(), getPosition(),\r\n            0, false\r\n        ]];\r\n        let resolveState: IResolveState;\r\n        let hasEscape = 0;\r\n        let isBegin = true;\r\n\r\n\r\n        let cpos: IPosition;\r\n        while (true) {\r\n\r\n            if (!hasEscape) {\r\n                // 如果启用 useEscape 模式，字符捕获焦点从可能的 \\ 号开始\r\n                cpos = getPosition();\r\n            }\r\n\r\n            let char: string;\r\n\r\n            if (!isBegin) {\r\n\r\n                if (env.offset >= env.end) {\r\n\r\n                    // 首个匹配符为 \"\" 则代表匹配每一轮的开始\r\n                    // 当前面存在匹配符，后面出现的单独的 \"\" 匹配符则代表匹配输入内容的结束\r\n                    // 如果仅匹配输入内容的结束，可以这样描述 : [\"\",\"\"]\r\n\r\n                    if (\r\n                        scopeStack[0][SCOPE.CURSOR].offset < cpos.offset\r\n                    ) {// 匹配扫描过程已结束\r\n                        if (match(\"\") || resolve()) {\r\n                            return env;\r\n                        }\r\n                        if (env.offset < env.end) {\r\n                            break;\r\n                        }\r\n                        matchPool.length = 0;\r\n                        match(\"\");\r\n                    }\r\n                    if (matchPool.length) {\r\n                        const state = resolveState;\r\n                        match(\"\", true);\r\n                        // 仅匹配 OPERATIONS.MATCH_EOF 的 [\"\",\"\"] \r\n                        // 排除 OPERATIONS.MATCH_BEGIN OPERATIONS.MATCH_END 的 \"\"\r\n                        if (state !== resolveState && resolve()) {\r\n                            return env;\r\n                        }\r\n                    }\r\n                    if (scopeStack[0][SCOPE.CURSOR].offset < cpos.offset) {\r\n                        collect(scopeStack[0][SCOPE.CURSOR], cpos, null);\r\n                    }\r\n                    break;\r\n                }\r\n\r\n                char = env.input[env.offset];\r\n                env.offset += 1;\r\n\r\n                switch (char) {\r\n                    case \"\\r\":\r\n                        if (env.input[env.offset] !== \"\\n\") {\r\n                            //env.column = 0;\r\n                            break;\r\n                        }\r\n                        // 将 \\r\\n 归类为 \\n 处理\r\n                        char = \"\\n\";\r\n                        env.offset += 1;\r\n                    case \"\\n\":\r\n                        env.line += 1;\r\n                        env.column = 0;\r\n                        break;\r\n                }\r\n                env.column += 1;\r\n                env.ignoreCase && (char = char.toLowerCase());\r\n\r\n                if (env.useEscape) {\r\n                    if (char === \"\\\\\") {\r\n                        hasEscape ^= 1;\r\n                        if (hasEscape) {\r\n                            continue;\r\n                        }\r\n                    } else if (hasEscape) {\r\n                        hasEscape = 0;\r\n                        char = \"\\\\\" + char;\r\n                    }\r\n                }\r\n            } else {\r\n                char = \"\";\r\n                isBegin = false;\r\n            }\r\n            \r\n            if (match(char)) {\r\n                return env;\r\n            }\r\n        }\r\n\r\n        return env;\r\n\r\n\r\n        function getPosition(): IPosition {\r\n            return { offset: env.offset, line: env.line, column: env.column }\r\n        }\r\n\r\n        function match(key: string, noResolve?: boolean) {\r\n            const pool = matchPool;\r\n            const scopeNode = scopeStack[0][SCOPE.NODE];\r\n\r\n            matchPool = [];\r\n\r\n            let node: any;\r\n            let slices: ISlices;\r\n            let hasBranch: boolean;\r\n            let hasScopeNode = false;\r\n\r\n            while (true) {\r\n                if (pool.length) {\r\n                    [node, slices] = pool.shift();\r\n                } else if (!resolveState && !hasScopeNode) {\r\n                    node = scopeNode;\r\n                    slices = null;\r\n                } else {\r\n                    break;\r\n                }\r\n                hasScopeNode = hasScopeNode || (node === scopeNode);\r\n                hasBranch = false;\r\n\r\n                resolveState = walk(node, slices)\r\n                    || node[MARKS.ROLL] && walk(node[MARKS.ROLL], slices)\r\n                    || resolveState;\r\n            }\r\n\r\n\r\n            if (!noResolve && matchPool.length === 0 && resolve()) {\r\n                return true;\r\n            }\r\n\r\n            function walk(parent: any, slices?: ISlices): IResolveState {\r\n                let node = parent[key];\r\n                if (!node) {\r\n                    return;\r\n                }\r\n                if (!slices) {\r\n                    slices = [[cpos, parent[MARKS.CAPTURING_HOOKS]]];\r\n                } else if (hasBranch) {\r\n                    slices = slices.slice();\r\n                }\r\n                hasBranch = true;\r\n\r\n                matchPool.push([node, slices]);\r\n                if (node[MARKS.CAPTURING_HOOKS]) {\r\n                    slices.push([getPosition(), node[MARKS.CAPTURING_HOOKS]]);\r\n                }\r\n\r\n                if (!node[MARKS.RESOLVE]) {\r\n                    return;\r\n                } else {\r\n                    node = node[MARKS.RESOLVE];\r\n                }\r\n                return [node, getPosition(), slices, scopeStack.length];\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        function resolve() {\r\n            if (!resolveState) {\r\n                return;\r\n            }\r\n\r\n            const [node, { offset, line, column }, splits, stackSize] = resolveState;\r\n            scopeStack.splice(0, scopeStack.length - stackSize);\r\n            env.offset = offset;\r\n            env.line = line;\r\n            env.column = column;\r\n\r\n            let backSteps = finallize(node, splits, true);\r\n            if (backSteps > 0) {\r\n                return true;\r\n            }\r\n\r\n            if (backSteps < 0) {\r\n                do {\r\n                    const scope = scopeStack.shift();\r\n                    let tokens = env.tokens;\r\n                    if (scope[SCOPE.USE_FOLD]) {\r\n                        (env.tokens = tokens.shift()).pop();\r\n                    } else {\r\n                        tokens.length = scope[SCOPE.BACK_POINT];\r\n                    }\r\n                } while (++backSteps < 0)\r\n            }\r\n            //rollback(res);\r\n            resolveState = null;\r\n            isBegin = true;\r\n        }\r\n\r\n        function finallize(node: any, slices: ISlices, use_collect?: boolean): number {\r\n\r\n            let type = node[MARKS.TYPE];\r\n\r\n            const scope = scopeStack[0];\r\n            const startPos = slices[0][0];\r\n            let len = env.tokens.length;\r\n\r\n            if (use_collect) {\r\n\r\n                let hooks: Array<Hook>;\r\n                let sliceHooks = node[MARKS.SLICE_HOOKS];\r\n                if (sliceHooks) {\r\n                    hooks = slices[0][1];\r\n                    hooks && (hooks = hooks.filter(item => sliceHooks.has(item)));\r\n                }\r\n                collect(scope[SCOPE.CURSOR], startPos, hooks);\r\n            }\r\n\r\n            if (type === MARKS.WRAP) {\r\n                return wrap(node, slices, use_collect);\r\n            }\r\n\r\n            const hookPoint = env.tokens.length;\r\n\r\n            if (use_collect && type !== MARKS.END_ON_LEFT) {\r\n                let res = collectSlices(slices, node[MARKS.SLICE_HOOKS]);\r\n                if (res < 0) {\r\n                    env.tokens.length = len;\r\n                    return res + 1;\r\n                }\r\n            }\r\n            env.hookPoint = hookPoint;\r\n\r\n            if (type === MARKS.UNWRAP) {\r\n                return unwrap(node, slices);\r\n            } else {\r\n                const cursorPos = getPosition();\r\n                const res = useHook(node[MARKS.BUBBING_HOOKS], startPos, cursorPos);\r\n                if (res < 0) {\r\n                    env.tokens.length = len;\r\n                    return res + 1;\r\n                }\r\n                if (type !== MARKS.END_ON_LEFT) {\r\n                    scope[SCOPE.CURSOR] = cursorPos;\r\n                } else {\r\n                    env.offset = startPos.offset;\r\n                    env.line = startPos.line;\r\n                    env.column = startPos.column;\r\n                    scope[SCOPE.CURSOR] = startPos;\r\n                    return 1;\r\n                }\r\n                return type !== MARKS.END ? res : 1;\r\n            }\r\n\r\n        }\r\n\r\n\r\n        function wrap(node: any, slices: ISlices, use_collect?: boolean) {\r\n            const { useFold, tokens } = env;\r\n            const backPoint = tokens.length;\r\n            const startPos = slices[0][0];\r\n            const beginPos = getPosition();\r\n            const cursorPos = getPosition();\r\n            scopeStack.unshift([\r\n                node,\r\n                startPos, beginPos, cursorPos,\r\n                backPoint, useFold\r\n            ]);\r\n\r\n            if (useFold) {\r\n                env.tokens = [tokens];\r\n                env.hookPoint = 1;\r\n            }\r\n\r\n\r\n            let backSteps = use_collect ? collectSlices(\r\n                slices,\r\n                node[MARKS.SLICE_HOOKS]\r\n            ) : 0;\r\n\r\n            if (backSteps >= 0) {\r\n                backSteps = useHook(node[MARKS.BUBBING_HOOKS], startPos, cursorPos, beginPos);\r\n                if (backSteps >= 0) {\r\n                    node = node[MARKS.RESOLVE];\r\n                    return node ? finallize(node, slices, false) : backSteps;\r\n                }\r\n            }\r\n            return backSteps;\r\n        }\r\n\r\n\r\n        function unwrap(node: any, slices: ISlices) {\r\n\r\n            const scope = scopeStack.shift();\r\n\r\n            if (scope[SCOPE.USE_FOLD]) {\r\n                let tokens = env.tokens.shift()\r\n                env.hookPoint = tokens.length;\r\n                tokens.push(env.tokens);\r\n                env.tokens = tokens;\r\n            }\r\n\r\n            let backSteps = useHook(\r\n                node[MARKS.BUBBING_HOOKS],\r\n                scope[SCOPE.START],\r\n                getPosition(),\r\n                scope[SCOPE.BEGIN],\r\n            );\r\n            if (backSteps >= 0) {\r\n                node = node[MARKS.RESOLVE];\r\n\r\n                scopeStack[0][SCOPE.CURSOR] = getPosition();\r\n                if (node) {\r\n                    backSteps = finallize(node, slices, false);\r\n                    if (backSteps >= 0) {\r\n                        return backSteps;\r\n                    }\r\n                } else {\r\n                    return backSteps;\r\n                }\r\n            }\r\n            scopeStack.unshift(scope);\r\n            if (scope[SCOPE.USE_FOLD]) {\r\n                let tokens = env.tokens.pop();\r\n\r\n                tokens.unshift(env.tokens);\r\n                env.tokens = tokens;\r\n            }\r\n            return backSteps + 1;\r\n        }\r\n\r\n        function useHook(hooks: Array<Hook>, start: IPosition, end: IPosition, begin?: IPosition): number {\r\n            for (const hook of hooks) {\r\n                let res = hook.use(env, start, end, begin);\r\n                if (res < 0) {\r\n                    return res;\r\n                }\r\n            }\r\n            return 0;\r\n        }\r\n\r\n        function collect(start: IPosition, end: IPosition, hooks: Array<Hook>) {\r\n            let res: any = 0;\r\n            if (start.offset < end.offset) {\r\n                let { tokens } = env;\r\n                env.hookPoint = tokens.length;\r\n                tokens.push(\r\n                    new Token(\r\n                        env.input.slice(start.offset, end.offset),\r\n                        start,\r\n                        end\r\n                    )\r\n                );\r\n                if (hooks) {\r\n                    res = useHook(hooks, start, end);\r\n                }\r\n            }\r\n            return res;\r\n        }\r\n\r\n        function collectSlices(\r\n            slices: ISlices,\r\n            sliceHooks: Set<Hook>\r\n        ) {\r\n            let cursor = slices[0][0];\r\n            if (sliceHooks) {\r\n                for (let i = 1; i < slices.length; i += 1) {\r\n                    let [next, hooks] = slices[i];\r\n                    hooks = hooks.filter(item => sliceHooks.has(item));\r\n                    if (hooks.length) {\r\n                        const res = collect(cursor, next, hooks);\r\n                        if (res < 0) {\r\n                            return res;\r\n                        }\r\n                        cursor = next;\r\n                    }\r\n                }\r\n            }\r\n            return collect(cursor, getPosition(), null);\r\n        }\r\n    }\r\n}\r\n\r\n\r\nclass Token {\r\n\r\n    loc: ISourceLocation;\r\n\r\n    constructor(public value: string, start: IPosition, end: IPosition) {\r\n        this.loc = { start, end };\r\n    }\r\n    trim() {\r\n        const found = this.value.match(/^\\s*|\\s*$/gm);\r\n        return this.slice(found[0].length, this.value.length - found[1].length);\r\n    }\r\n    concat(token: Token) {\r\n        return new Token(this.value + token.value, this.loc.start, token.loc.end);\r\n    }\r\n    slice(beginIndex: number, endIndex = this.value.length) {\r\n        let { value, loc: { start, end } } = this;\r\n        let { offset, line, column } = start;\r\n        let index = 0;\r\n\r\n        if (endIndex < 0) {\r\n            endIndex = value.length + endIndex;\r\n        }\r\n        if (beginIndex < 0) {\r\n            beginIndex = value.length + beginIndex;\r\n        }\r\n        if (beginIndex > endIndex) {\r\n            endIndex = beginIndex;\r\n        }\r\n        const range = [beginIndex, endIndex].map(\r\n            function (limit): IPosition {\r\n                if (limit === 0) {\r\n                    return start;\r\n                }\r\n                if (limit === value.length) {\r\n                    return end;\r\n                }\r\n                while (index < limit) {\r\n                    if (value[index] === \"\\n\") {\r\n                        line += 1;\r\n                        column = 1;\r\n                    } else {\r\n                        column += 1;\r\n                    }\r\n                    index += 1;\r\n                }\r\n                return { offset: offset + limit, line, column }\r\n            }\r\n        )\r\n        return new Token(value.slice(beginIndex, endIndex), range[0], range[1]);\r\n    }\r\n    toString() {\r\n        return this.value;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\ntype HookStack = Array<Hook | HookStack | RootStack>;\r\ntype HookList = Array<Hook>;\r\n\r\nclass RootStack extends Array<Hook | HookStack> { }\r\n\r\ntype BubbleTable = Array<HookStack>;\r\ntype CaptureTable = Array<HookList>;\r\ntype BuildResult = [Array<any>, BubbleTable, CaptureTable];\r\n\r\nfunction build(pattern: IPattern): Record<string, any> {\r\n    const matchTree = { [MARKS.TYPE]: MARKS.ROOT };\r\n    const [nodes, bubbling_map, capturing_map] = buildRule(\r\n        [pattern],\r\n        [matchTree],\r\n        [[new RootStack()]],\r\n        [[]],\r\n        [matchTree]\r\n    );\r\n    for (let i = 0; i < nodes.length; i += 1) {\r\n        // 被省去 MARKS.FINISH 的描述自动补全\r\n        const node = nodes[i];\r\n        if (!MARKS.RESOLVE_TYPE_SET.has(node[MARKS.TYPE])) {\r\n            buildKey(MARKS.FINISH, [node], [bubbling_map[i]], [capturing_map[i]]);\r\n        }\r\n    }\r\n    return matchTree;\r\n}\r\n\r\n\r\nfunction buildRule(\r\n    patterns: Array<IPattern>,\r\n    nodes: Array<any>,\r\n    bubbleTable: BubbleTable,\r\n    captureTable: CaptureTable,\r\n    scopeChain: Array<any>\r\n): BuildResult {\r\n\r\n    const rsRule: Array<IPattern> = [];\r\n    let index = 0;\r\n    let key: IPattern;\r\n    while (index < patterns.length) {\r\n        let ndepth = 0, begin = index;\r\n        const forkChain: Array<number | String> = [];\r\n\r\n        while (true) {\r\n            if (patterns[index] === OPERATIONS.FORK_IN_ROOT) {\r\n                if (ndepth) {\r\n                    forkChain.push(ndepth);\r\n                    ndepth = 0;\r\n                }\r\n                forkChain.push(OPERATIONS.FORK_IN_ROOT);\r\n            } else if (patterns[index] === OPERATIONS.FORK_IN_PARENT) {\r\n                ndepth += 1;\r\n            } else {\r\n                break;\r\n            }\r\n            index += 1;\r\n        }\r\n\r\n        if (index !== begin) {\r\n            ndepth && forkChain.push(ndepth);\r\n\r\n            for (let node of nodes) {\r\n                let parent: any = node;\r\n                let cursor = 0;\r\n                for (let d of forkChain) {\r\n                    if (d === OPERATIONS.FORK_IN_ROOT) {\r\n                        parent = scopeChain[cursor++];\r\n                    } else {\r\n                        do {\r\n                            parent = parent[MARKS.PARENT];\r\n                            if (parent === scopeChain[cursor]) {\r\n                                cursor += 1;\r\n                            }\r\n                        } while (--(<number>d) > 0)\r\n                    }\r\n                }\r\n                if (node[MARKS.ROLL] !== parent) {\r\n                    if (node[MARKS.ROLL]) {\r\n                        debugger;   // 暂不支持一个匹配路径存在多个 FORK 匹配（用不到）\r\n                    }\r\n                    node[MARKS.ROLL] = parent;\r\n                }\r\n            }\r\n            continue;\r\n        }\r\n\r\n        switch (key = patterns[index]) {\r\n            case OPERATIONS.NO_CAPTURE:\r\n            case OPERATIONS.NO_COLLECT:\r\n                rsRule.push(key);\r\n            case OPERATIONS.SPLIT:\r\n                setHook(null);\r\n                break;\r\n\r\n            case OPERATIONS.OPTION:\r\n                return walk(\r\n                    [\r\n                        rsRule.concat(patterns.slice(index + 1)),\r\n                        rsRule.concat(patterns.slice(index + 2))\r\n                    ],\r\n                    function (pattern) {\r\n                        return buildRule(\r\n                            pattern,\r\n                            nodes,\r\n                            bubbleTable.map(hooks => hooks.slice()),\r\n                            captureTable.map(maps => maps.slice()),\r\n                            scopeChain\r\n                        )\r\n                    }\r\n                );\r\n\r\n            case OPERATIONS.MARK_AS_ROOT:\r\n                patterns = rsRule.concat(patterns.slice(index + 1));\r\n                return walk(nodes, function (node, index) {\r\n                    const bubbleHooks = bubbleTable[index];\r\n                    return buildRule(\r\n                        patterns,\r\n                        [node],\r\n                        [[new RootStack(...<HookStack>bubbleHooks[0])].concat(bubbleHooks.slice(1))],\r\n                        [captureTable[index]],\r\n                        [node].concat(scopeChain)\r\n                    )\r\n                });\r\n            default:\r\n                if (key instanceof Hook) {\r\n                    setHook(key);\r\n                } else {\r\n                    if (key instanceof Array) {\r\n                        [nodes, bubbleTable, captureTable] = walk(key, function (item) {\r\n                            return (item instanceof Array ? buildRule : buildKey)(\r\n                                item, nodes,\r\n                                bubbleTable.map(hooks => hooks.slice()),\r\n                                captureTable.map(maps => maps.slice()),\r\n                                scopeChain\r\n                            )\r\n                        })\r\n                    } else {\r\n                        [nodes, bubbleTable, captureTable] = buildKey(key, nodes, bubbleTable, captureTable);\r\n                    }\r\n                    while (rsRule.length) {\r\n                        setHook(\r\n                            rsRule.shift() === OPERATIONS.NO_COLLECT\r\n                                ? OPERATIONS.pipe()\r\n                                : new NoCapture()\r\n                        );\r\n                    }\r\n                }\r\n                break;\r\n        }\r\n\r\n        index += 1;\r\n    }\r\n\r\n    return [nodes, bubbleTable, captureTable];\r\n\r\n\r\n    function walk(\r\n        list: Array<any>,\r\n        next: (item: any, index: number) => BuildResult\r\n    ): BuildResult {\r\n\r\n        let newNodes: Array<any> = [];\r\n        let newBubbleTable: Array<HookStack> = [];\r\n        let newCaptureTable: Array<any[]> = [];\r\n\r\n        for (let i = 0; i < list.length; i += 1) {\r\n            const res = next(list[i], i);\r\n            newNodes = newNodes.concat(res[0]);\r\n            newBubbleTable = newBubbleTable.concat(res[1]);\r\n            newCaptureTable = newCaptureTable.concat(res[2]);\r\n        }\r\n\r\n\r\n        return [newNodes, newBubbleTable, newCaptureTable];\r\n\r\n    }\r\n    function setHook(hook: Hook) {\r\n\r\n        if (!hook) {\r\n            hook = new Call(function () { }, HOOK_MODE.CAPTURE);\r\n            for (let i = 0; i < nodes.length; i += 1) {\r\n                MARKS.RESOLVE_TYPE_SET.has(nodes[i][MARKS.TYPE]) || addHook(i);\r\n            }\r\n            return;\r\n        }\r\n        switch (hook.mode) {\r\n            case HOOK_MODE.RESOLVE:\r\n                bubbleTable.forEach(hooks => hooks.push(<Hook>key));\r\n                break;\r\n            case HOOK_MODE.PIPE:\r\n            case HOOK_MODE.CAPTURE:\r\n                for (let i = 0; i < nodes.length; i += 1) {\r\n                    addHook(i);\r\n                }\r\n                break;\r\n        }\r\n        function addHook(index: number) {\r\n            const node = nodes[index];\r\n            const type = node[MARKS.TYPE];\r\n            // 实际使用中不会刻意用到共用钩子的情况，统一使之不共用可降低声明成本和更符合声明直觉\r\n            const h = Object.create(hook);\r\n            if (hook.mode !== HOOK_MODE.PIPE && MARKS.RESOLVE_TYPE_SET.has(type)) {\r\n                node[MARKS.BUBBING_HOOKS].push(h);\r\n            } else {\r\n                (\r\n                    node[MARKS.CAPTURING_HOOKS]\r\n                    || (node[MARKS.CAPTURING_HOOKS] = [])\r\n                ).push(h);\r\n                captureTable[index].push(h);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\nfunction buildKey(\r\n    key: any,\r\n    nodes: Array<any>,\r\n    bubbleTable: BubbleTable,\r\n    captureTable: CaptureTable,\r\n    scopeChain?: Array<any>\r\n): BuildResult {\r\n    if (typeof key === \"string\") {\r\n        if (/^[\\s\\S]?$/.test(key)) {\r\n            key = [key];\r\n        }\r\n        for (let i = 0; i < key.length; i += 1) {\r\n            nodes = nodes.map(function (node) {\r\n                return node[key[i]] || (node[key[i]] = { [MARKS.PARENT]: node });\r\n            });\r\n        }\r\n    } else if (MARKS.RESOLVE_TYPE_SET.has(key)) {\r\n\r\n        nodes = nodes.map(function (node, i) {\r\n\r\n            let bubbleHooks: HookStack = bubbleTable[i];\r\n            let captureHooks = captureTable[i];\r\n            captureTable[i] = [];\r\n\r\n            if (key === OPERATIONS.UNWRAP_ALL) {\r\n                key = OPERATIONS.UNWRAP;\r\n                if (!(bubbleHooks[0] instanceof RootStack)) {\r\n                    if (bubbleHooks.length > 1) {\r\n                        bubbleHooks[0] = (<HookStack>bubbleHooks[0]).concat(bubbleHooks.slice(1));\r\n                    }\r\n                    do {\r\n                        bubbleTable[i] = [bubbleHooks[0][0]];\r\n                        bubbleHooks = <HookStack>bubbleHooks[0];\r\n\r\n                        node = getResolveNode(node, key, bubbleHooks, captureHooks);\r\n                    } while (!(bubbleHooks[0] instanceof RootStack))\r\n                }\r\n            } else {\r\n                if (key === OPERATIONS.UNWRAP) {\r\n                    bubbleTable[i] = [bubbleHooks[0][0]];\r\n                    bubbleHooks = (<HookStack>bubbleHooks[0]).concat(bubbleHooks.slice(1));\r\n                } else if (key === OPERATIONS.WRAP) {\r\n                    bubbleTable[i] = [bubbleHooks];\r\n                    bubbleHooks = [];\r\n                } else {\r\n                    bubbleTable[i] = [bubbleHooks[0]];\r\n                }\r\n\r\n                node = getResolveNode(node, key, bubbleHooks, captureHooks);\r\n\r\n            }\r\n            return node;\r\n        });\r\n\r\n    } else {\r\n        debugger;\r\n    }\r\n    return [nodes, bubbleTable, captureTable];\r\n\r\n    function getResolveNode(\r\n        node: any, type: string,\r\n        bubbleHooks: HookStack, sliceHooks: HookList\r\n    ) {\r\n        if (node[MARKS.RESOLVE]) {\r\n            // 如果存在重复定义的 pattern 则这里会执行\r\n            debugger;\r\n        }\r\n        return node[MARKS.RESOLVE] = {\r\n            [MARKS.PARENT]: node,\r\n            [MARKS.TYPE]: type,\r\n            [MARKS.SLICE_HOOKS]: sliceHooks.length\r\n                ? new Set(sliceHooks.splice(0))\r\n                : null,\r\n            [MARKS.BUBBING_HOOKS]: bubbleHooks.slice(1).reverse()\r\n        };\r\n    }\r\n\r\n}\r\n\r\nfunction unwrapTokens(tokens: any) {\r\n    if (tokens instanceof Token) {\r\n        return tokens.value;\r\n    }\r\n    if (tokens instanceof Array) {\r\n        return tokens.map(unwrapTokens);\r\n    }\r\n    return tokens;\r\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\r\nimport {\r\n    Scanner, OPERATIONS, HOOK_MODE, IScanEnv,\r\n    IPattern, Token,\r\n    IPosition, ISourceLocation,\r\n} from \"./scanner\"\r\n\r\n\r\nconst {\r\n    FINISH,\r\n    WRAP, UNWRAP, UNWRAP_ALL,\r\n    OPTION,\r\n    SPLIT,\r\n    NO_COLLECT, NO_CAPTURE,\r\n    MARK_AS_ROOT, FORK_IN_PARENT, FORK_IN_ROOT,\r\n    END, END_ON_LEFT,\r\n    useKey,\r\n    node, key, pick, hook, pipe, prev, merge,\r\n\r\n    MATCH_BEGIN,\r\n    MATCH_END,\r\n    MATCH_EOF,\r\n    MERGE_ALL_TOKENS\r\n} = OPERATIONS;\r\n\r\nconst TEST_KEYWORD_BOUNDARY = [\r\n    [NO_CAPTURE, [\"\", \" \", \"\\n\", `\\t`, \",\", \"(\", \")\", \"{\", \"}\", \":\", \"[\", \"]\"]]\r\n];\r\nconst THROW_TOKEN_ERROR = hook(function (env, start, end) {\r\n    console.log(\"Invalid or unexpected token\", start, end);\r\n}, HOOK_MODE.RESOLVE);\r\n\r\nconst LITERAL_VALUE_MAP = { true: true, false: false, null: null };\r\nconst COLLECT_STRING = [\r\n    [\r\n        pick(function (tokens, env, start, end) {\r\n            return [env.input.slice(start.offset, end.offset), tokens[1].value];\r\n        }),\r\n        `\"`,\r\n        hook(function (env) {\r\n            env.useEscape = true;\r\n        }, HOOK_MODE.CAPTURE),\r\n        WRAP,\r\n        [\r\n            [THROW_TOKEN_ERROR, \"\\n\"],\r\n            [\r\n                `\"`,\r\n                hook(function (env) {\r\n                    env.useEscape = false;\r\n                }, HOOK_MODE.CAPTURE),\r\n                UNWRAP,\r\n            ]\r\n        ]\r\n    ]\r\n];\r\n\r\n\r\nconst MATCH_WHITE_SPACE_CHARACHER = [` `, `\\n`, `\\t`];\r\n\r\nconst CLEAR_WHITE_SPACE_CHARACHER = [\r\n    [NO_COLLECT, MATCH_WHITE_SPACE_CHARACHER]\r\n];\r\n\r\nconst Literal = node(\"Literal\").Wrapper;\r\n\r\nconst PARSE_NUMBER_LITERAL = pipe(\r\n    function (token: Token, env, start, end) {\r\n        let value: any = token.value;\r\n        const result: any = /^(-?[1-9][0-9]*|0)(.[0-9]+)?([eE][-+]?[0-9]+)?$/g.exec(value);\r\n        if (result) {\r\n            const [, int, frac, exp] = result;\r\n            value = int | 0;\r\n            frac && (value += frac % 1);\r\n            exp && (value *= Math.pow(10, exp.slice(1) | 0));\r\n        } else {\r\n            debugger;\r\n        }\r\n        return Object.assign(   //  Number(value)\r\n            new Literal(),\r\n            { raw: token.value, value: value, loc: { start, end } }\r\n        );\r\n    } ,\r\n);\r\n\r\n\r\nexport default <IPattern>[\r\n    [PARSE_NUMBER_LITERAL, CLEAR_WHITE_SPACE_CHARACHER],\r\n    [\r\n        node(\"Literal\", function ([[raw, value]]: any) {\r\n            return [\r\n                useKey(\"raw\", raw),\r\n                useKey(\"value\", value)\r\n            ];\r\n        }),\r\n        [\r\n            [COLLECT_STRING],\r\n            [\r\n                pick(function ({ value }: Token) {\r\n                    return [value, LITERAL_VALUE_MAP[value]]\r\n                }),\r\n                \"\",\r\n                [\"true\", \"false\", \"null\"]\r\n                , TEST_KEYWORD_BOUNDARY\r\n            ]\r\n        ]\r\n    ],\r\n    [\r\n        node(\"Object\", function ([tokens]: [Array<any>]) {\r\n            return useKey(\"children\", tokens.filter(\r\n                function (token) {\r\n                    if (token instanceof Token) {\r\n                        debugger;\r\n                        return false;\r\n                    }\r\n                    return true;\r\n                }\r\n            ));\r\n        }),\r\n        NO_COLLECT, \"{\", WRAP,\r\n        [\r\n            [NO_COLLECT, \"}\", UNWRAP],\r\n            [CLEAR_WHITE_SPACE_CHARACHER],\r\n            [\r\n                node(\"Identifier\", function ([[raw, value]]: any) {\r\n                    return [\r\n                        useKey(\"value\", value),\r\n                        useKey(\"raw\", raw)\r\n                    ]\r\n                }),\r\n                COLLECT_STRING,\r\n                node(\"Property\", function ([key, [value]]) {\r\n                    const props = [useKey(\"key\", key)];\r\n                    if (value.length === 1 && !(value[0] instanceof Token)) {\r\n                        props.push(useKey(\"value\", value[0]));\r\n                    } else {\r\n                        debugger;\r\n                    }\r\n                    return props;\r\n                }),\r\n                prev(),\r\n                WRAP,\r\n                [\r\n                    [CLEAR_WHITE_SPACE_CHARACHER],\r\n                    [\r\n                        NO_COLLECT, \":\", WRAP,\r\n                        FORK_IN_ROOT,\r\n                        PARSE_NUMBER_LITERAL,\r\n                        [\r\n                            [NO_CAPTURE, \"}\", UNWRAP, UNWRAP],\r\n                            [NO_COLLECT, \",\", UNWRAP, UNWRAP],\r\n                        ]\r\n                    ]\r\n                ]\r\n            ]\r\n        ]\r\n    ],\r\n    [\r\n        node(\"Array\", function ([tokens]: [Array<any>]) {\r\n            const children = [];\r\n            for (let i = 0, len = tokens.length; i < len; i += 2) {\r\n                let value = tokens[i];\r\n                let spearator = tokens[i + 1];\r\n                if (!spearator || (spearator.value === \",\" && i < len - 2)) {\r\n                    if (!(value instanceof Token)) {\r\n                        children.push(value);\r\n                        continue;\r\n                    }\r\n                }\r\n                debugger;\r\n                break;\r\n            }\r\n            return useKey(\"children\", children);\r\n        }),\r\n        NO_COLLECT, \"[\", WRAP,\r\n        FORK_IN_ROOT,\r\n        PARSE_NUMBER_LITERAL,\r\n        [\r\n            [NO_COLLECT, \"]\", UNWRAP],\r\n            [\",\"]\r\n        ]\r\n    ]\r\n];\r\n\r\n\r\n"],"names":["SCOPE","OPERATIONS","MARKS","Hook","mode","Node","constructor","type","map","useContent","super","this","Wrapper","NODE_MAP","eval","use","env","start","end","tokens","hookPoint","node","loc","addItem","item","key","value","content","push","splice","walk","token","Array","forEach","UseKey","Key","Merge","Prev","match","onlyToken","prev","Token","res","length","slice","Pipe","pipe","undefined","Pick","Call","NoCapture","offset","line","column","FINISH","String","WRAP","UNWRAP","UNWRAP_ALL","OPTION","SPLIT","NO_COLLECT","NO_CAPTURE","MARK_AS_ROOT","FORK_IN_PARENT","FORK_IN_ROOT","END","END_ON_LEFT","useKey","toString","val","pick","hook","fn","merge","MATCH_BEGIN","MATCH_END","MATCH_EOF","MERGE_ALL_TOKENS","reduce","concat","UNFOLD","ROOT","RESOLVE","TYPE","ROLL","PARENT","COLLECT","BUBBING_HOOKS","CAPTURING_HOOKS","SLICE_HOOKS","IGNORE_TESTS","RESOLVE_TYPE_SET","Set","Scanner","pattern","configure","useEscape","useFold","ignoreCase","scanTree","build","Object","assign","scan","options","resolveState","cpos","input","begin","matchPool","scopeStack","getPosition","hasEscape","isBegin","char","CURSOR","resolve","state","collect","toLowerCase","noResolve","pool","scopeNode","NODE","slices","hasBranch","hasScopeNode","shift","parent","splits","stackSize","backSteps","finallize","scope","USE_FOLD","pop","BACK_POINT","use_collect","startPos","len","hooks","sliceHooks","filter","has","backPoint","beginPos","cursorPos","unshift","collectSlices","useHook","wrap","START","BEGIN","unwrap","cursor","i","next","trim","found","beginIndex","endIndex","index","range","limit","RootStack","matchTree","nodes","bubbling_map","capturing_map","buildRule","buildKey","patterns","bubbleTable","captureTable","scopeChain","rsRule","ndepth","forkChain","setHook","maps","bubbleHooks","d","list","newNodes","newBubbleTable","newCaptureTable","addHook","h","create","test","captureHooks","getResolveNode","reverse","unwrapTokens","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","TEST_KEYWORD_BOUNDARY","THROW_TOKEN_ERROR","console","log","LITERAL_VALUE_MAP","true","false","null","COLLECT_STRING","CLEAR_WHITE_SPACE_CHARACHER","Literal","PARSE_NUMBER_LITERAL","result","exec","int","frac","exp","Math","pow","raw","props","children","spearator"],"sourceRoot":""}