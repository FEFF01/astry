{"version":3,"file":"js/../js/scanner.js","mappings":"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","sources":["webpack://astry/./js/scanner.ts"],"sourcesContent":["\r\n\r\n\r\nexport {\r\n    Scanner, OPERATIONS, HOOK_MODE, IScanEnv,\r\n    IPattern, Token,\r\n    IPosition, ISourceLocation,\r\n    UseKey, unwrapTokens\r\n}\r\n\r\ntype IScanEnv = {\r\n    tokens: Array<any>,\r\n    input: string,\r\n    begin: number,\r\n    offset: number,\r\n    end: number,\r\n    line: number,\r\n    column: number,\r\n    useFold: boolean,\r\n    useEscape: boolean,\r\n    ignoreCase: boolean,\r\n    hookPoint: number, // 用于指定当前钩子方法目标 token 位置\r\n}\r\n\r\n\r\nconst enum HOOK_MODE {\r\n    RESOLVE = 0b1,\r\n    CAPTURE = 0b10,\r\n    PIPE = 0b100\r\n    //LEFT_ASSOCIATIVE = 0b101\r\n}\r\n\r\ninterface IPosition {\r\n    offset: number,\r\n    line: number,\r\n    column: number\r\n}\r\ninterface ISourceLocation {\r\n    start: IPosition,\r\n    end: IPosition\r\n}\r\n\r\n\r\ntype IPattern = Hook\r\n    | string\r\n    | String    // 用于在不占用 string 描述空间的基础上，清晰的定义一些操作指令\r\n    | Array<\r\n        string  //  单段字符串不需要在数组内也能简化的声明为一个分支\r\n        | Array<IPattern>    //  其他内容需要被数组包裹\r\n    > // Array 代表 Pattern 内的分支 Pattern\r\n\r\nabstract class Hook {\r\n    mode: HOOK_MODE = HOOK_MODE.RESOLVE;\r\n    abstract use(env: IScanEnv, start: IPosition, end: IPosition): any\r\n}\r\n\r\nclass Node extends Hook {\r\n    static NODE_MAP = {};\r\n    public Wrapper: any;\r\n    constructor(\r\n        public type: string,\r\n        public map?: (tokens: Array<any>, env: IScanEnv, start: IPosition, end: IPosition) => any,\r\n        private useContent?: boolean\r\n    ) {\r\n        super();\r\n        this.Wrapper = Node.NODE_MAP[type] || (\r\n            Node.NODE_MAP[type] = eval(\r\n                `(function ${type}(){this.type=\"${type}\";})`\r\n            )\r\n        );\r\n    }\r\n    use(env: IScanEnv, start: IPosition, end: IPosition) {\r\n\r\n        let { tokens, hookPoint } = env;\r\n\r\n        const node = new this.Wrapper();\r\n        node.loc = { start, end };\r\n        let addItem = function (item: UseKey) {\r\n            node[item.key] = item.value;\r\n        }\r\n        if (this.useContent) {\r\n            const content = node.content = [];\r\n            addItem = function (item: UseKey) {\r\n                content.push(item);\r\n            }\r\n        }\r\n        tokens = tokens.splice(hookPoint);\r\n        if (this.map) {\r\n            tokens = this.map(tokens, env, start, end) || tokens;\r\n        }\r\n        walk(tokens);\r\n        env.tokens.push(node);\r\n\r\n        function walk(token: any) {\r\n            if (token instanceof Array) {\r\n                token.forEach(walk);\r\n            } else if (token instanceof UseKey) {\r\n                addItem(token);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nclass UseKey {\r\n    constructor(public key: string, public value: any) { }\r\n}\r\n\r\nclass Key extends Hook {\r\n    static Wrapper = UseKey;\r\n    constructor(public key: string, public map?: (token: any, env: IScanEnv, start: IPosition, end: IPosition) => any) {\r\n        super();\r\n    }\r\n    use(env: IScanEnv, start: IPosition, end: IPosition) {\r\n        let { tokens, hookPoint } = env;\r\n        let token = tokens[hookPoint];\r\n        this.map && (token = this.map(token, env, start, end) || token);\r\n        tokens.splice(hookPoint, 1, new UseKey(this.key, token));\r\n    }\r\n}\r\n\r\nclass Merge extends Hook {\r\n    constructor(public map: (tokens: Array<any>, env: IScanEnv, start: IPosition, end: IPosition) => any) {\r\n        super();\r\n    }\r\n    use(env: IScanEnv, start: IPosition, end: IPosition) {\r\n        let { tokens, hookPoint } = env;\r\n\r\n        tokens.push(this.map(tokens.splice(hookPoint), env, start, end));\r\n    }\r\n}\r\n\r\nclass Prev extends Hook {\r\n    constructor(\r\n        public match?: (token: Token | any, env: IScanEnv) => number | boolean,\r\n        public onlyToken?: boolean\r\n    ) {\r\n        super();\r\n    }\r\n    use(env: IScanEnv) {\r\n\r\n        let { tokens, hookPoint } = env;\r\n        hookPoint -= 1;\r\n        let prev = tokens[hookPoint];\r\n        if (!this.onlyToken || prev instanceof Token) {\r\n            if (this.match) {\r\n                let res = this.match(prev, env);\r\n                if (res) {\r\n                    if (typeof res === \"number\" && res !== prev.value.length) {\r\n                        tokens.splice(\r\n                            hookPoint, 1,\r\n                            prev.slice(0, -res), prev.slice(-res)\r\n                        );\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            env.hookPoint -= 1;\r\n        }\r\n    }\r\n}\r\nclass Pipe extends Hook {\r\n    mode = HOOK_MODE.PIPE;\r\n    constructor(public pipe: (token: any, env: IScanEnv, start: IPosition, end: IPosition) => any) {\r\n        super();\r\n    }\r\n    use(env: IScanEnv, start: IPosition, end: IPosition) {\r\n        let { tokens, hookPoint } = env;\r\n        let res = this.pipe(tokens[hookPoint], env, start, end);\r\n        if (res !== undefined) {\r\n            tokens[hookPoint] = res;\r\n        } else {\r\n            tokens.splice(hookPoint, 1);\r\n        }\r\n    }\r\n}\r\nclass Pick extends Pipe {\r\n    mode = HOOK_MODE.RESOLVE;\r\n}\r\n\r\nclass Call extends Hook {\r\n    constructor(\r\n        public use: (env: IScanEnv, start: IPosition, end: IPosition) => any,\r\n        public mode: HOOK_MODE\r\n    ) {\r\n        super();\r\n    }\r\n}\r\nclass NoCapture extends Hook {\r\n    mode = HOOK_MODE.CAPTURE;\r\n    constructor() {\r\n        super()\r\n    }\r\n    use(env: IScanEnv, start: IPosition, end: IPosition) {\r\n        let { tokens, hookPoint } = env;\r\n        tokens.splice(hookPoint, 1);\r\n        if (start.offset < env.offset/*end.offset === env.offset*/) {\r\n            env.offset = start.offset;\r\n            env.line = start.line;\r\n            env.column = start.column;\r\n        }\r\n    }\r\n}\r\n\r\nnamespace OPERATIONS {\r\n    export const\r\n        FINISH = new String(\"FINISH\"),\r\n        WRAP = new String(\"WRAP\"),\r\n        UNWRAP = new String(\"UNWRAP\"),\r\n        UNWRAP_ALL = new String(\"UNWRAP_ALL\"),\r\n        OPTION = new String(\"OPTION\"),\r\n        SPLIT = new String(\"SPLIT\"),\r\n        NO_COLLECT = new String(\"NO_COLLECT\"),\r\n        NO_CAPTURE = new String(\"NO_CAPTURE\"),\r\n        MARK_AS_ROOT = new String(\"MARK_AS_ROOT\"),\r\n        FORK_IN_PARENT = new String(\"FORK_IN_PARENT\"),\r\n        FORK_IN_ROOT = new String(\"FORK_IN_ROOT\"),\r\n        END = new String(\"END\"),\r\n        END_ON_LEFT = new String(\"END_ON_LEFT\");\r\n\r\n    export const useKey = function (key: string | Token, value: any) {\r\n        return new UseKey(key.toString(), value);\r\n    }\r\n\r\n    export const\r\n        node = function (\r\n            val: string,\r\n            map?: (tokens: Array<any>, env: IScanEnv, start: IPosition, end: IPosition) => any,\r\n            useContent = false,\r\n            mode = HOOK_MODE.RESOLVE\r\n        ) {\r\n            const node = new Node(val, map, useContent);\r\n            node.mode = mode;\r\n            return node;\r\n        },\r\n        key = function (val: string, map?: (token: any, env: IScanEnv, start: IPosition, end: IPosition) => any) {\r\n            return new Key(val, map);\r\n        },\r\n        pick = function (map?: (token: any, env: IScanEnv, start: IPosition, end: IPosition) => any) {\r\n            return new Pick(map || function () { });\r\n        },\r\n        hook = function (fn: (env: IScanEnv, start: IPosition, end: IPosition) => void, mode = HOOK_MODE.RESOLVE) {\r\n            return new Call(fn, mode);\r\n        },\r\n        pipe = function (pipe?: (token: any, env: IScanEnv, start: IPosition, end: IPosition) => any) {\r\n            return new Pipe(pipe || function () { });\r\n        },\r\n        prev = function (match?: (token: Token | any, env: IScanEnv) => number | boolean, onlyToken?: boolean) {\r\n            return new Prev(match, onlyToken);\r\n        },\r\n        merge = function (\r\n            map: (tokens: Array<any>, env: IScanEnv, start: IPosition, end: IPosition) => any\r\n                = function (tokens) { return tokens; }\r\n        ) {\r\n            return new Merge(map);\r\n        };\r\n\r\n\r\n\r\n    export const\r\n        MATCH_BEGIN = \"\",\r\n        MATCH_END = \"\",\r\n        MATCH_EOF: IPattern = [[\"\", \"\"]],\r\n        MERGE_ALL_TOKENS = merge(\r\n            function (tokens: Array<Token>) {\r\n                return tokens.reduce((res, token) => res.concat(token));\r\n            }\r\n        ),\r\n        UNFOLD = hook(function (env) {\r\n            const { tokens, hookPoint } = env;\r\n            for (const item of tokens.splice(hookPoint)) {\r\n                if (item instanceof Array) {\r\n                    tokens.push(...item);\r\n                } else {\r\n                    tokens.push(item);\r\n                }\r\n            }\r\n        }, HOOK_MODE.RESOLVE);\r\n}\r\n\r\n\r\nnamespace MARKS {\r\n    export const\r\n        FINISH = OPERATIONS.FINISH,\r\n        END = OPERATIONS.END,\r\n        END_ON_LEFT = OPERATIONS.END_ON_LEFT,\r\n        UNWRAP = OPERATIONS.UNWRAP,\r\n        WRAP = OPERATIONS.WRAP,\r\n        ROOT = new String(\"ROOT\");\r\n\r\n\r\n    export const\r\n        RESOLVE = \"_RESOLVE_\",\r\n        TYPE = \"_TYPE_\",\r\n        ROLL = \"_ROLL_\",\r\n        PARENT = \"_PARENT_\",\r\n        COLLECT = \"_COLLECT_\",\r\n        BUBBING_HOOKS = \"_BUBBING_HOOKS_\",\r\n        CAPTURING_HOOKS = \"_CAPTURING_HOOKS_\",\r\n        SLICE_HOOKS = \"_SLICE_HOOKS_\",\r\n        IGNORE_TESTS = \"_IGNORE_TESTS_\";\r\n\r\n\r\n\r\n    export const RESOLVE_TYPE_SET: Set<String> = new Set([\r\n        OPERATIONS.FINISH,\r\n        OPERATIONS.END,\r\n        OPERATIONS.END_ON_LEFT,\r\n        OPERATIONS.UNWRAP,\r\n        OPERATIONS.UNWRAP_ALL,\r\n        OPERATIONS.WRAP,\r\n        ROOT    // 只是个占位\r\n    ]);\r\n}\r\n\r\nenum SCOPE {\r\n    NODE, START, CURSOR, BACK_POINT, USE_FOLD\r\n}\r\n\r\ninterface IScope {\r\n    [SCOPE.NODE]: any,\r\n    [SCOPE.START]: IPosition,\r\n    [SCOPE.CURSOR]: IPosition,\r\n    [SCOPE.BACK_POINT]: number,\r\n    [SCOPE.USE_FOLD]: boolean\r\n}\r\n\r\ntype ISlices = Array<[IPosition, Hook[]]>;\r\n\r\ntype IResolveState = [any, IPosition, ISlices, number];\r\n\r\n\r\nclass Scanner {\r\n\r\n    private scanTree: Record<string, any>;\r\n    public useEscape = false;\r\n    public useFold = true;\r\n    public ignoreCase = false;\r\n    constructor(\r\n        pattern: IPattern,\r\n        configure?: { useEscape?: boolean, useFold?: boolean, ignoreCase?: boolean }\r\n    ) {\r\n        this.scanTree = build(pattern);\r\n        configure && Object.assign(this, configure);\r\n    }\r\n\r\n    scan(options: IScanEnv | string) {\r\n        let env = typeof options === \"string\" ? {\r\n            tokens: [],\r\n            input: options,\r\n            begin: 0,\r\n            offset: 0,\r\n            end: options.length,\r\n            line: 1,\r\n            column: 1,\r\n            useFold: this.useFold,\r\n            useEscape: this.useEscape,\r\n            ignoreCase: this.ignoreCase,\r\n            hookPoint: 0\r\n        } : options;\r\n\r\n        let matchPool: Array<[any, ISlices]> = [];\r\n        let scopeStack: Array<IScope> = [[\r\n            this.scanTree,\r\n            getPosition(), getPosition(),\r\n            0, false\r\n        ]];\r\n        let resolveState: IResolveState;\r\n        let hasEscape = 0;\r\n        let isBegin = true;\r\n\r\n\r\n        let cpos: IPosition;\r\n        while (true) {\r\n\r\n            if (!hasEscape) {\r\n                // 如果启用 useEscape 模式，字符捕获焦点从可能的 \\ 号开始\r\n                cpos = getPosition();\r\n            }\r\n\r\n            let char: string;\r\n\r\n            if (!isBegin) {\r\n\r\n                if (env.offset >= env.end) {\r\n\r\n                    // 首个匹配符为 \"\" 则代表匹配每一轮的开始\r\n                    // 当前面存在匹配符，后面出现的单独的 \"\" 匹配符则代表匹配输入内容的结束\r\n                    // 如果仅匹配输入内容的结束，可以这样描述 : [\"\",\"\"]\r\n\r\n                    if (\r\n                        scopeStack[0][SCOPE.CURSOR].offset < cpos.offset\r\n                    ) {// 匹配扫描过程已结束\r\n                        if (match(\"\") || resolve()) {\r\n                            return env;\r\n                        }\r\n                        if (env.offset < env.end) {\r\n                            break;\r\n                        }\r\n                        matchPool.length = 0;\r\n                        match(\"\");\r\n                    }\r\n                    if (matchPool.length) {\r\n                        const state = resolveState;\r\n                        match(\"\", true);\r\n                        // 仅匹配 OPERATIONS.MATCH_EOF 的 [\"\",\"\"] \r\n                        // 排除 OPERATIONS.MATCH_BEGIN OPERATIONS.MATCH_END 的 \"\"\r\n                        if (state !== resolveState && resolve()) {\r\n                            return env;\r\n                        }\r\n                    }\r\n                    if (scopeStack[0][SCOPE.CURSOR].offset < cpos.offset) {\r\n                        collect(scopeStack[0][SCOPE.CURSOR], cpos, null);\r\n                    }\r\n                    break;\r\n                }\r\n\r\n                char = env.input[env.offset];\r\n                env.offset += 1;\r\n\r\n                switch (char) {\r\n                    case \"\\r\":\r\n                        if (env.input[env.offset] !== \"\\n\") {\r\n                            //env.column = 0;\r\n                            break;\r\n                        }\r\n                        // 将 \\r\\n 归类为 \\n 处理\r\n                        char = \"\\n\";\r\n                        env.offset += 1;\r\n                    case \"\\n\":\r\n                        env.line += 1;\r\n                        env.column = 0;\r\n                        break;\r\n                }\r\n                env.column += 1;\r\n                env.ignoreCase && (char = char.toLowerCase());\r\n\r\n                if (env.useEscape) {\r\n                    if (char === \"\\\\\") {\r\n                        hasEscape ^= 1;\r\n                        if (hasEscape) {\r\n                            continue;\r\n                        }\r\n                    } else if (hasEscape) {\r\n                        hasEscape = 0;\r\n                        char = \"\\\\\" + char;\r\n                    }\r\n                }\r\n            } else {\r\n                char = \"\";\r\n                isBegin = false;\r\n            }\r\n            if (match(char)) {\r\n                return env;\r\n            }\r\n        }\r\n\r\n        return env;\r\n\r\n\r\n        function getPosition(): IPosition {\r\n            return { offset: env.offset, line: env.line, column: env.column }\r\n        }\r\n\r\n        function match(key: string, noResolve?: boolean) {\r\n            const pool = matchPool;\r\n\r\n            matchPool = [];\r\n\r\n            let node: any;\r\n            let slices: ISlices;\r\n            let hasBranch: boolean;\r\n\r\n            while (true) {\r\n                if (pool.length) {\r\n                    [node, slices] = pool.shift();\r\n                } else if (!resolveState && node !== scopeStack[0][SCOPE.NODE]) {\r\n                    node = scopeStack[0][SCOPE.NODE];\r\n                    slices = null;\r\n                } else {\r\n                    break;\r\n                }\r\n                hasBranch = false;\r\n\r\n                resolveState = walk(node, slices)\r\n                    || node[MARKS.ROLL] && walk(node[MARKS.ROLL], slices)\r\n                    || resolveState;\r\n            }\r\n\r\n\r\n            if (!noResolve && matchPool.length === 0 && resolve()) {\r\n                return true;\r\n            }\r\n\r\n            function walk(parent: any, slices?: ISlices): IResolveState {\r\n                let node = parent[key];\r\n                if (!node) {\r\n                    return;\r\n                }\r\n                if (!slices) {\r\n                    slices = [[cpos, parent[MARKS.CAPTURING_HOOKS]]];\r\n                } else if (hasBranch) {\r\n                    slices = slices.slice();\r\n                }\r\n                hasBranch = true;\r\n\r\n                matchPool.push([node, slices]);\r\n                if (node[MARKS.CAPTURING_HOOKS]) {\r\n                    slices.push([getPosition(), node[MARKS.CAPTURING_HOOKS]]);\r\n                }\r\n\r\n                if (!node[MARKS.RESOLVE]) {\r\n                    return;\r\n                } else {\r\n                    node = node[MARKS.RESOLVE];\r\n                }\r\n                return [node, getPosition(), slices, scopeStack.length];\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        function resolve() {\r\n            if (!resolveState) {\r\n                return;\r\n            }\r\n\r\n            const [node, { offset, line, column }, splits, stackSize] = resolveState;\r\n            scopeStack.splice(0, scopeStack.length - stackSize);\r\n            env.offset = offset;\r\n            env.line = line;\r\n            env.column = column;\r\n\r\n            let backSteps = finallize(node, splits, true);\r\n            if (backSteps > 0) {\r\n                return true;\r\n            }\r\n\r\n            if (backSteps < 0) {\r\n                do {\r\n                    const scope = scopeStack.shift();\r\n                    let tokens = env.tokens;\r\n                    if (scope[SCOPE.USE_FOLD]) {\r\n                        (env.tokens = tokens.shift()).pop();\r\n                    } else {\r\n                        tokens.length = scope[SCOPE.BACK_POINT];\r\n                    }\r\n                } while (++backSteps < 0)\r\n            }\r\n            //rollback(res);\r\n            resolveState = null;\r\n            isBegin = true;\r\n        }\r\n\r\n        function finallize(node: any, slices: ISlices, use_collect?: boolean): number {\r\n\r\n            let type = node[MARKS.TYPE];\r\n\r\n            const scope = scopeStack[0];\r\n            const startPos = slices[0][0];\r\n            let len = env.tokens.length;\r\n\r\n            if (use_collect) {\r\n\r\n                let hooks: Array<Hook>;\r\n                let sliceHooks = node[MARKS.SLICE_HOOKS];\r\n                if (sliceHooks) {\r\n                    hooks = slices[0][1];\r\n                    hooks && (hooks = hooks.filter(item => sliceHooks.has(item)));\r\n                }\r\n                collect(scope[SCOPE.CURSOR], startPos, hooks);\r\n            }\r\n\r\n            if (type === MARKS.WRAP) {\r\n                return wrap(node, slices, use_collect);\r\n            }\r\n\r\n            const hookPoint = env.tokens.length;\r\n\r\n            if (use_collect && type !== MARKS.END_ON_LEFT) {\r\n                let res = collectSlices(slices, node[MARKS.SLICE_HOOKS]);\r\n                if (res < 0) {\r\n                    env.tokens.length = len;\r\n                    return res + 1;\r\n                }\r\n            }\r\n            env.hookPoint = hookPoint;\r\n\r\n            if (type === MARKS.UNWRAP) {\r\n                return unwrap(node, slices);\r\n            } else {\r\n                let res = useHook(node[MARKS.BUBBING_HOOKS], startPos, getPosition());\r\n                if (res < 0) {\r\n                    env.tokens.length = len;\r\n                    return res + 1;\r\n                }\r\n                if (type !== MARKS.END_ON_LEFT) {\r\n                    scope[SCOPE.CURSOR] = getPosition();\r\n                } else {\r\n                    env.offset = startPos.offset;\r\n                    env.line = startPos.line;\r\n                    env.column = startPos.column;\r\n                    scope[SCOPE.CURSOR] = startPos;\r\n                    return 1;\r\n                }\r\n                return type !== MARKS.END ? res : 1;\r\n            }\r\n\r\n        }\r\n\r\n\r\n        function wrap(node: any, slices: ISlices, use_collect?: boolean) {\r\n            const { useFold, tokens } = env;\r\n            const backPoint = tokens.length;\r\n            let startPos = slices[0][0];\r\n\r\n            scopeStack.unshift([\r\n                node,\r\n                startPos, getPosition(),\r\n                backPoint, useFold\r\n            ]);\r\n\r\n            if (useFold) {\r\n                env.tokens = [tokens];\r\n                env.hookPoint = 1;\r\n            }\r\n\r\n\r\n            let backSteps = use_collect ? collectSlices(\r\n                slices,\r\n                node[MARKS.SLICE_HOOKS]\r\n            ) : 0;\r\n\r\n            if (backSteps >= 0) {\r\n                backSteps = useHook(node[MARKS.BUBBING_HOOKS], startPos, getPosition());\r\n                if (backSteps >= 0) {\r\n                    node = node[MARKS.RESOLVE];\r\n                    return node ? finallize(node, slices, false) : backSteps;\r\n                }\r\n            }\r\n            return backSteps;\r\n        }\r\n\r\n\r\n        function unwrap(node: any, slices: ISlices) {\r\n\r\n            const scope = scopeStack.shift();\r\n\r\n            if (scope[SCOPE.USE_FOLD]) {\r\n                let tokens = env.tokens.shift()\r\n                env.hookPoint = tokens.length;\r\n                tokens.push(env.tokens);\r\n                env.tokens = tokens;\r\n            }\r\n\r\n            let backSteps = useHook(\r\n                node[MARKS.BUBBING_HOOKS],\r\n                scope[SCOPE.START],\r\n                getPosition()\r\n            );\r\n            if (backSteps >= 0) {\r\n                node = node[MARKS.RESOLVE];\r\n\r\n                scopeStack[0][SCOPE.CURSOR] = getPosition();\r\n                if (node) {\r\n                    backSteps = finallize(node, slices, false);\r\n                    if (backSteps >= 0) {\r\n                        return backSteps;\r\n                    }\r\n                } else {\r\n                    return backSteps;\r\n                }\r\n            }\r\n            scopeStack.unshift(scope);\r\n            if (scope[SCOPE.USE_FOLD]) {\r\n                let tokens = env.tokens.pop();\r\n\r\n                tokens.unshift(env.tokens);\r\n                env.tokens = tokens;\r\n            }\r\n            return backSteps + 1;\r\n        }\r\n\r\n        function useHook(hooks: Array<Hook>, start: IPosition, end: IPosition): number {\r\n            for (const hook of hooks) {\r\n                let res = hook.use(env, start, end);\r\n                if (res < 0) {\r\n                    return res;\r\n                }\r\n            }\r\n            return 0;\r\n        }\r\n\r\n        function collect(start: IPosition, end: IPosition, hooks: Array<Hook>) {\r\n            let res: any = 0;\r\n            if (start.offset < end.offset) {\r\n                let { tokens } = env;\r\n                env.hookPoint = tokens.length;\r\n                tokens.push(\r\n                    new Token(\r\n                        env.input.slice(start.offset, end.offset),\r\n                        start,\r\n                        end\r\n                    )\r\n                );\r\n                if (hooks) {\r\n                    res = useHook(hooks, start, end);\r\n                }\r\n            }\r\n            return res;\r\n        }\r\n\r\n        function collectSlices(\r\n            slices: ISlices,\r\n            sliceHooks: Set<Hook>\r\n        ) {\r\n            let cursor = slices[0][0];\r\n            if (sliceHooks) {\r\n                for (let i = 1; i < slices.length; i += 1) {\r\n                    let [next, hooks] = slices[i];\r\n                    hooks = hooks.filter(item => sliceHooks.has(item));\r\n                    if (hooks.length) {\r\n                        const res = collect(cursor, next, hooks);\r\n                        if (res < 0) {\r\n                            return res;\r\n                        }\r\n                        cursor = next;\r\n                    }\r\n                }\r\n            }\r\n            return collect(cursor, getPosition(), null);\r\n        }\r\n    }\r\n}\r\n\r\n\r\nclass Token {\r\n\r\n    loc: ISourceLocation;\r\n\r\n    constructor(public value: string, start: IPosition, end: IPosition) {\r\n        this.loc = { start, end };\r\n    }\r\n    trim() {\r\n        const found = this.value.match(/^\\s*|\\s*$/gm);\r\n        return this.slice(found[0].length, this.value.length - found[1].length);\r\n    }\r\n    concat(token: Token) {\r\n        return new Token(this.value + token.value, this.loc.start, token.loc.end);\r\n    }\r\n    slice(beginIndex: number, endIndex = this.value.length) {\r\n        let { value, loc: { start, end } } = this;\r\n        let { offset, line, column } = start;\r\n        let index = 0;\r\n\r\n        if (endIndex < 0) {\r\n            endIndex = value.length + endIndex;\r\n        }\r\n        if (beginIndex < 0) {\r\n            beginIndex = value.length + beginIndex;\r\n        }\r\n        if (beginIndex > endIndex) {\r\n            endIndex = beginIndex;\r\n        }\r\n        const range = [beginIndex, endIndex].map(\r\n            function (limit): IPosition {\r\n                if (limit === 0) {\r\n                    return start;\r\n                }\r\n                if (limit === value.length) {\r\n                    return end;\r\n                }\r\n                while (index < limit) {\r\n                    if (value[index] === \"\\n\") {\r\n                        line += 1;\r\n                        column = 1;\r\n                    } else {\r\n                        column += 1;\r\n                    }\r\n                    index += 1;\r\n                }\r\n                return { offset: offset + limit, line, column }\r\n            }\r\n        )\r\n        return new Token(value.slice(beginIndex, endIndex), range[0], range[1]);\r\n    }\r\n    toString() {\r\n        return this.value;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\ntype HookStack = Array<Hook | HookStack | RootStack>;\r\ntype HookList = Array<Hook>;\r\n\r\nclass RootStack extends Array<Hook | HookStack> { }\r\n\r\ntype BubbleTable = Array<HookStack>;\r\ntype CaptureTable = Array<HookList>;\r\ntype BuildResult = [Array<any>, BubbleTable, CaptureTable];\r\n\r\nfunction build(pattern: IPattern): Record<string, any> {\r\n    const matchTree = { [MARKS.TYPE]: MARKS.ROOT };\r\n    const [nodes, bubbling_map, capturing_map] = buildRule(\r\n        [pattern],\r\n        [matchTree],\r\n        [[new RootStack()]],\r\n        [[]],\r\n        [matchTree]\r\n    );\r\n    for (let i = 0; i < nodes.length; i += 1) {\r\n        // 被省去 MARKS.FINISH 的描述自动补全\r\n        const node = nodes[i];\r\n        if (!MARKS.RESOLVE_TYPE_SET.has(node[MARKS.TYPE])) {\r\n            buildKey(MARKS.FINISH, [node], [bubbling_map[i]], [capturing_map[i]]);\r\n        }\r\n    }\r\n    return matchTree;\r\n}\r\n\r\n\r\nfunction buildRule(\r\n    patterns: Array<IPattern>,\r\n    nodes: Array<any>,\r\n    bubbleTable: BubbleTable,\r\n    captureTable: CaptureTable,\r\n    scopeChain: Array<any>\r\n): BuildResult {\r\n\r\n    const rsRule: Array<IPattern> = [];\r\n    let index = 0;\r\n    let key: IPattern;\r\n    while (index < patterns.length) {\r\n        let ndepth = 0, begin = index;\r\n        const forkChain: Array<number | String> = [];\r\n\r\n        while (true) {\r\n            if (patterns[index] === OPERATIONS.FORK_IN_ROOT) {\r\n                if (ndepth) {\r\n                    forkChain.push(ndepth);\r\n                    ndepth = 0;\r\n                }\r\n                forkChain.push(OPERATIONS.FORK_IN_ROOT);\r\n            } else if (patterns[index] === OPERATIONS.FORK_IN_PARENT) {\r\n                ndepth += 1;\r\n            } else {\r\n                break;\r\n            }\r\n            index += 1;\r\n        }\r\n\r\n        if (index !== begin) {\r\n            ndepth && forkChain.push(ndepth);\r\n\r\n            for (let node of nodes) {\r\n                let parent: any = node;\r\n                let cursor = 0;\r\n                for (let d of forkChain) {\r\n                    if (d === OPERATIONS.FORK_IN_ROOT) {\r\n                        parent = scopeChain[cursor++];\r\n                    } else {\r\n                        do {\r\n                            parent = parent[MARKS.PARENT];\r\n                            if (parent === scopeChain[cursor]) {\r\n                                cursor += 1;\r\n                            }\r\n                        } while (--(<number>d) >= 0)\r\n                    }\r\n                }\r\n                if (node[MARKS.ROLL] !== parent) {\r\n                    if (node[MARKS.ROLL]) {\r\n                        debugger;   // 暂不支持一个匹配路径存在多个 FORK 匹配（用不到）\r\n                    }\r\n                    node[MARKS.ROLL] = parent;\r\n                }\r\n            }\r\n            continue;\r\n        }\r\n\r\n        switch (key = patterns[index]) {\r\n            case OPERATIONS.NO_CAPTURE:\r\n            case OPERATIONS.NO_COLLECT:\r\n                rsRule.push(key);\r\n            case OPERATIONS.SPLIT:\r\n                setHook(null);\r\n                break;\r\n\r\n            case OPERATIONS.OPTION:\r\n                return walk(\r\n                    [\r\n                        rsRule.concat(patterns.slice(index + 1)),\r\n                        rsRule.concat(patterns.slice(index + 2))\r\n                    ],\r\n                    function (pattern) {\r\n                        return buildRule(\r\n                            pattern,\r\n                            nodes,\r\n                            bubbleTable.map(hooks => hooks.slice()),\r\n                            captureTable.map(maps => maps.slice()),\r\n                            scopeChain\r\n                        )\r\n                    }\r\n                );\r\n\r\n            case OPERATIONS.MARK_AS_ROOT:\r\n                patterns = rsRule.concat(patterns.slice(index + 1));\r\n                return walk(nodes, function (node, index) {\r\n                    const bubbleHooks = bubbleTable[index];\r\n                    return buildRule(\r\n                        patterns,\r\n                        [node],\r\n                        [[new RootStack(...<HookStack>bubbleHooks[0])].concat(bubbleHooks.slice(1))],\r\n                        [captureTable[index]],\r\n                        [node].concat(scopeChain)\r\n                    )\r\n                });\r\n            default:\r\n                if (key instanceof Hook) {\r\n                    setHook(key);\r\n                } else {\r\n                    if (key instanceof Array) {\r\n                        [nodes, bubbleTable, captureTable] = walk(key, function (item) {\r\n                            return (item instanceof Array ? buildRule : buildKey)(\r\n                                item, nodes,\r\n                                bubbleTable.map(hooks => hooks.slice()),\r\n                                captureTable.map(maps => maps.slice()),\r\n                                scopeChain\r\n                            )\r\n                        })\r\n                    } else {\r\n                        [nodes, bubbleTable, captureTable] = buildKey(key, nodes, bubbleTable, captureTable);\r\n                    }\r\n                    while (rsRule.length) {\r\n                        setHook(\r\n                            rsRule.shift() === OPERATIONS.NO_COLLECT\r\n                                ? OPERATIONS.pipe()\r\n                                : new NoCapture()\r\n                        );\r\n                    }\r\n                }\r\n                break;\r\n        }\r\n\r\n        index += 1;\r\n    }\r\n\r\n    return [nodes, bubbleTable, captureTable];\r\n\r\n\r\n    function walk(\r\n        list: Array<any>,\r\n        next: (item: any, index: number) => BuildResult\r\n    ): BuildResult {\r\n\r\n        let newNodes: Array<any> = [];\r\n        let newBubbleTable: Array<HookStack> = [];\r\n        let newCaptureTable: Array<any[]> = [];\r\n\r\n        for (let i = 0; i < list.length; i += 1) {\r\n            const res = next(list[i], i);\r\n            newNodes = newNodes.concat(res[0]);\r\n            newBubbleTable = newBubbleTable.concat(res[1]);\r\n            newCaptureTable = newCaptureTable.concat(res[2]);\r\n        }\r\n\r\n\r\n        return [newNodes, newBubbleTable, newCaptureTable];\r\n\r\n    }\r\n    function setHook(hook: Hook) {\r\n        if (hook === window.test) {\r\n            debugger;\r\n        }\r\n        if (!hook) {\r\n            hook = new Call(function () { }, HOOK_MODE.CAPTURE);\r\n            for (let i = 0; i < nodes.length; i += 1) {\r\n                MARKS.RESOLVE_TYPE_SET.has(nodes[i][MARKS.TYPE]) || addHook(i);\r\n            }\r\n            return;\r\n        }\r\n        switch (hook.mode) {\r\n            case HOOK_MODE.RESOLVE:\r\n                bubbleTable.forEach(hooks => hooks.push(<Hook>key));\r\n                break;\r\n            case HOOK_MODE.PIPE:\r\n            case HOOK_MODE.CAPTURE:\r\n                for (let i = 0; i < nodes.length; i += 1) {\r\n                    addHook(i);\r\n                }\r\n                break;\r\n        }\r\n        function addHook(index: number) {\r\n            const node = nodes[index];\r\n            const type = node[MARKS.TYPE];\r\n            if (hook.mode !== HOOK_MODE.PIPE && MARKS.RESOLVE_TYPE_SET.has(type)) {\r\n                node[MARKS.BUBBING_HOOKS].push(hook);\r\n            } else {\r\n                (\r\n                    node[MARKS.CAPTURING_HOOKS]\r\n                    || (node[MARKS.CAPTURING_HOOKS] = [])\r\n                ).push(hook);\r\n                captureTable[index].push(hook);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\nfunction buildKey(\r\n    key: any,\r\n    nodes: Array<any>,\r\n    bubbleTable: BubbleTable,\r\n    captureTable: CaptureTable,\r\n    scopeChain?: Array<any>\r\n): BuildResult {\r\n    if (typeof key === \"string\") {\r\n        if (/^[\\s\\S]?$/.test(key)) {\r\n            key = [key];\r\n        }\r\n        for (let i = 0; i < key.length; i += 1) {\r\n            nodes = nodes.map(function (node) {\r\n                return node[key[i]] || (node[key[i]] = { [MARKS.PARENT]: node });\r\n            });\r\n        }\r\n    } else if (MARKS.RESOLVE_TYPE_SET.has(key)) {\r\n\r\n        nodes = nodes.map(function (node, i) {\r\n\r\n            let bubbleHooks: HookStack = bubbleTable[i];\r\n            let captureHooks = captureTable[i];\r\n            captureTable[i] = [];\r\n\r\n            if (key === OPERATIONS.UNWRAP_ALL) {\r\n                key = OPERATIONS.UNWRAP;\r\n                if (!(bubbleHooks[0] instanceof RootStack)) {\r\n                    if (bubbleHooks.length > 1) {\r\n                        bubbleHooks[0] = (<HookStack>bubbleHooks[0]).concat(bubbleHooks.slice(1));\r\n                    }\r\n                    do {\r\n                        bubbleTable[i] = [bubbleHooks[0][0]];\r\n                        bubbleHooks = <HookStack>bubbleHooks[0];\r\n\r\n                        node = getResolveNode(node, key, bubbleHooks, captureHooks);\r\n                    } while (!(bubbleHooks[0] instanceof RootStack))\r\n                }\r\n            } else {\r\n                if (key === OPERATIONS.UNWRAP) {\r\n                    bubbleTable[i] = [bubbleHooks[0][0]];\r\n                    bubbleHooks = (<HookStack>bubbleHooks[0]).concat(bubbleHooks.slice(1));\r\n                } else if (key === OPERATIONS.WRAP) {\r\n                    bubbleTable[i] = [bubbleHooks];\r\n                    bubbleHooks = [];\r\n                } else {\r\n                    bubbleTable[i] = [bubbleHooks[0]];\r\n                }\r\n\r\n                node = getResolveNode(node, key, bubbleHooks, captureHooks);\r\n\r\n            }\r\n            return node;\r\n        });\r\n\r\n    } else {\r\n        debugger;\r\n    }\r\n    return [nodes, bubbleTable, captureTable];\r\n\r\n    function getResolveNode(\r\n        node: any, type: string,\r\n        bubbleHooks: HookStack, sliceHooks: HookList\r\n    ) {\r\n        if (node[MARKS.RESOLVE]) {\r\n            // 如果存在重复定义的 pattern 则这里会执行\r\n            debugger;\r\n        }\r\n        return node[MARKS.RESOLVE] = {\r\n            [MARKS.PARENT]: node,\r\n            [MARKS.TYPE]: type,\r\n            [MARKS.SLICE_HOOKS]: sliceHooks.length\r\n                ? new Set(sliceHooks.splice(0))\r\n                : null,\r\n            [MARKS.BUBBING_HOOKS]: bubbleHooks.slice(1).reverse()\r\n        };\r\n    }\r\n\r\n}\r\n\r\nfunction unwrapTokens(tokens: any) {\r\n    if (tokens instanceof Token) {\r\n        return tokens.value;\r\n    }\r\n    if (tokens instanceof Array) {\r\n        return tokens.map(unwrapTokens);\r\n    }\r\n    return tokens;\r\n}"],"names":["OPERATIONS","MARKS","SCOPE","Hook","mode","Node","constructor","type","map","useContent","super","this","Wrapper","NODE_MAP","eval","use","env","start","end","tokens","hookPoint","node","loc","addItem","item","key","value","content","push","splice","walk","token","Array","forEach","UseKey","Key","Merge","Prev","match","onlyToken","prev","Token","res","length","slice","Pipe","pipe","undefined","Pick","Call","NoCapture","offset","line","column","FINISH","String","WRAP","UNWRAP","UNWRAP_ALL","OPTION","SPLIT","NO_COLLECT","NO_CAPTURE","MARK_AS_ROOT","FORK_IN_PARENT","FORK_IN_ROOT","END","END_ON_LEFT","useKey","toString","val","pick","hook","fn","merge","MATCH_BEGIN","MATCH_END","MATCH_EOF","MERGE_ALL_TOKENS","reduce","concat","UNFOLD","ROOT","RESOLVE","TYPE","ROLL","PARENT","COLLECT","BUBBING_HOOKS","CAPTURING_HOOKS","SLICE_HOOKS","IGNORE_TESTS","RESOLVE_TYPE_SET","Set","Scanner","pattern","configure","useEscape","useFold","ignoreCase","scanTree","build","Object","assign","scan","options","resolveState","cpos","input","begin","matchPool","scopeStack","getPosition","hasEscape","isBegin","char","CURSOR","resolve","state","collect","toLowerCase","noResolve","pool","slices","hasBranch","shift","NODE","parent","splits","stackSize","backSteps","finallize","scope","USE_FOLD","pop","BACK_POINT","use_collect","startPos","len","hooks","sliceHooks","filter","has","backPoint","unshift","collectSlices","useHook","wrap","START","unwrap","cursor","i","next","trim","found","beginIndex","endIndex","index","range","limit","RootStack","matchTree","nodes","bubbling_map","capturing_map","buildRule","buildKey","patterns","bubbleTable","captureTable","scopeChain","rsRule","ndepth","forkChain","setHook","maps","bubbleHooks","d","list","newNodes","newBubbleTable","newCaptureTable","window","test","addHook","captureHooks","getResolveNode","reverse","unwrapTokens"],"sourceRoot":""}